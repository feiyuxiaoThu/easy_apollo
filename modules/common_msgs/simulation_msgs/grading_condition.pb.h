// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: modules/common_msgs/simulation_msgs/grading_condition.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3014000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3014000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "modules/map/proto/map_geometry.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[33]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto;
namespace apollo {
namespace simulation {
class AbnormalStopCondition;
class AbnormalStopConditionDefaultTypeInternal;
extern AbnormalStopConditionDefaultTypeInternal _AbnormalStopCondition_default_instance_;
class AccelerationCondition;
class AccelerationConditionDefaultTypeInternal;
extern AccelerationConditionDefaultTypeInternal _AccelerationCondition_default_instance_;
class AntiCheatingCondition;
class AntiCheatingConditionDefaultTypeInternal;
extern AntiCheatingConditionDefaultTypeInternal _AntiCheatingCondition_default_instance_;
class BrakeTapCondition;
class BrakeTapConditionDefaultTypeInternal;
extern BrakeTapConditionDefaultTypeInternal _BrakeTapCondition_default_instance_;
class CentripetalAccelerationCondition;
class CentripetalAccelerationConditionDefaultTypeInternal;
extern CentripetalAccelerationConditionDefaultTypeInternal _CentripetalAccelerationCondition_default_instance_;
class ChangeLaneAtJunctionCondition;
class ChangeLaneAtJunctionConditionDefaultTypeInternal;
extern ChangeLaneAtJunctionConditionDefaultTypeInternal _ChangeLaneAtJunctionCondition_default_instance_;
class CheckpointCondition;
class CheckpointConditionDefaultTypeInternal;
extern CheckpointConditionDefaultTypeInternal _CheckpointCondition_default_instance_;
class Condition;
class ConditionDefaultTypeInternal;
extern ConditionDefaultTypeInternal _Condition_default_instance_;
class CrosswalkStopCondition;
class CrosswalkStopConditionDefaultTypeInternal;
extern CrosswalkStopConditionDefaultTypeInternal _CrosswalkStopCondition_default_instance_;
class CrosswalkYieldCondition;
class CrosswalkYieldConditionDefaultTypeInternal;
extern CrosswalkYieldConditionDefaultTypeInternal _CrosswalkYieldCondition_default_instance_;
class DistToEndCondition;
class DistToEndConditionDefaultTypeInternal;
extern DistToEndConditionDefaultTypeInternal _DistToEndCondition_default_instance_;
class DistToLaneCenterCondition;
class DistToLaneCenterConditionDefaultTypeInternal;
extern DistToLaneCenterConditionDefaultTypeInternal _DistToLaneCenterCondition_default_instance_;
class FollowAndBypassCondition;
class FollowAndBypassConditionDefaultTypeInternal;
extern FollowAndBypassConditionDefaultTypeInternal _FollowAndBypassCondition_default_instance_;
class GradePlanning;
class GradePlanningDefaultTypeInternal;
extern GradePlanningDefaultTypeInternal _GradePlanning_default_instance_;
class JerkCondition;
class JerkConditionDefaultTypeInternal;
extern JerkConditionDefaultTypeInternal _JerkCondition_default_instance_;
class KeyPoint;
class KeyPointDefaultTypeInternal;
extern KeyPointDefaultTypeInternal _KeyPoint_default_instance_;
class KeyPointCondition;
class KeyPointConditionDefaultTypeInternal;
extern KeyPointConditionDefaultTypeInternal _KeyPointCondition_default_instance_;
class LimitedTimeParkingCondition;
class LimitedTimeParkingConditionDefaultTypeInternal;
extern LimitedTimeParkingConditionDefaultTypeInternal _LimitedTimeParkingCondition_default_instance_;
class LogicalCondition;
class LogicalConditionDefaultTypeInternal;
extern LogicalConditionDefaultTypeInternal _LogicalCondition_default_instance_;
class ObjectOverlapCondition;
class ObjectOverlapConditionDefaultTypeInternal;
extern ObjectOverlapConditionDefaultTypeInternal _ObjectOverlapCondition_default_instance_;
class ObstacleBypassCondition;
class ObstacleBypassConditionDefaultTypeInternal;
extern ObstacleBypassConditionDefaultTypeInternal _ObstacleBypassCondition_default_instance_;
class OnRoadCondition;
class OnRoadConditionDefaultTypeInternal;
extern OnRoadConditionDefaultTypeInternal _OnRoadCondition_default_instance_;
class RedLightStopCondition;
class RedLightStopConditionDefaultTypeInternal;
extern RedLightStopConditionDefaultTypeInternal _RedLightStopCondition_default_instance_;
class RegionOverlapCondition;
class RegionOverlapConditionDefaultTypeInternal;
extern RegionOverlapConditionDefaultTypeInternal _RegionOverlapCondition_default_instance_;
class RegionOverlapLWCondition;
class RegionOverlapLWConditionDefaultTypeInternal;
extern RegionOverlapLWConditionDefaultTypeInternal _RegionOverlapLWCondition_default_instance_;
class RoutingCondition;
class RoutingConditionDefaultTypeInternal;
extern RoutingConditionDefaultTypeInternal _RoutingCondition_default_instance_;
class RunRedLightCondition;
class RunRedLightConditionDefaultTypeInternal;
extern RunRedLightConditionDefaultTypeInternal _RunRedLightCondition_default_instance_;
class RunStopSignCondition;
class RunStopSignConditionDefaultTypeInternal;
extern RunStopSignConditionDefaultTypeInternal _RunStopSignCondition_default_instance_;
class SpeedCondition;
class SpeedConditionDefaultTypeInternal;
extern SpeedConditionDefaultTypeInternal _SpeedCondition_default_instance_;
class SpeedbumpLimitCondition;
class SpeedbumpLimitConditionDefaultTypeInternal;
extern SpeedbumpLimitConditionDefaultTypeInternal _SpeedbumpLimitCondition_default_instance_;
class SpinCondition;
class SpinConditionDefaultTypeInternal;
extern SpinConditionDefaultTypeInternal _SpinCondition_default_instance_;
class TimeLimitCondition;
class TimeLimitConditionDefaultTypeInternal;
extern TimeLimitConditionDefaultTypeInternal _TimeLimitCondition_default_instance_;
class WorkingZoneAvoidLimitCondition;
class WorkingZoneAvoidLimitConditionDefaultTypeInternal;
extern WorkingZoneAvoidLimitConditionDefaultTypeInternal _WorkingZoneAvoidLimitCondition_default_instance_;
}  // namespace simulation
}  // namespace apollo
PROTOBUF_NAMESPACE_OPEN
template<> ::apollo::simulation::AbnormalStopCondition* Arena::CreateMaybeMessage<::apollo::simulation::AbnormalStopCondition>(Arena*);
template<> ::apollo::simulation::AccelerationCondition* Arena::CreateMaybeMessage<::apollo::simulation::AccelerationCondition>(Arena*);
template<> ::apollo::simulation::AntiCheatingCondition* Arena::CreateMaybeMessage<::apollo::simulation::AntiCheatingCondition>(Arena*);
template<> ::apollo::simulation::BrakeTapCondition* Arena::CreateMaybeMessage<::apollo::simulation::BrakeTapCondition>(Arena*);
template<> ::apollo::simulation::CentripetalAccelerationCondition* Arena::CreateMaybeMessage<::apollo::simulation::CentripetalAccelerationCondition>(Arena*);
template<> ::apollo::simulation::ChangeLaneAtJunctionCondition* Arena::CreateMaybeMessage<::apollo::simulation::ChangeLaneAtJunctionCondition>(Arena*);
template<> ::apollo::simulation::CheckpointCondition* Arena::CreateMaybeMessage<::apollo::simulation::CheckpointCondition>(Arena*);
template<> ::apollo::simulation::Condition* Arena::CreateMaybeMessage<::apollo::simulation::Condition>(Arena*);
template<> ::apollo::simulation::CrosswalkStopCondition* Arena::CreateMaybeMessage<::apollo::simulation::CrosswalkStopCondition>(Arena*);
template<> ::apollo::simulation::CrosswalkYieldCondition* Arena::CreateMaybeMessage<::apollo::simulation::CrosswalkYieldCondition>(Arena*);
template<> ::apollo::simulation::DistToEndCondition* Arena::CreateMaybeMessage<::apollo::simulation::DistToEndCondition>(Arena*);
template<> ::apollo::simulation::DistToLaneCenterCondition* Arena::CreateMaybeMessage<::apollo::simulation::DistToLaneCenterCondition>(Arena*);
template<> ::apollo::simulation::FollowAndBypassCondition* Arena::CreateMaybeMessage<::apollo::simulation::FollowAndBypassCondition>(Arena*);
template<> ::apollo::simulation::GradePlanning* Arena::CreateMaybeMessage<::apollo::simulation::GradePlanning>(Arena*);
template<> ::apollo::simulation::JerkCondition* Arena::CreateMaybeMessage<::apollo::simulation::JerkCondition>(Arena*);
template<> ::apollo::simulation::KeyPoint* Arena::CreateMaybeMessage<::apollo::simulation::KeyPoint>(Arena*);
template<> ::apollo::simulation::KeyPointCondition* Arena::CreateMaybeMessage<::apollo::simulation::KeyPointCondition>(Arena*);
template<> ::apollo::simulation::LimitedTimeParkingCondition* Arena::CreateMaybeMessage<::apollo::simulation::LimitedTimeParkingCondition>(Arena*);
template<> ::apollo::simulation::LogicalCondition* Arena::CreateMaybeMessage<::apollo::simulation::LogicalCondition>(Arena*);
template<> ::apollo::simulation::ObjectOverlapCondition* Arena::CreateMaybeMessage<::apollo::simulation::ObjectOverlapCondition>(Arena*);
template<> ::apollo::simulation::ObstacleBypassCondition* Arena::CreateMaybeMessage<::apollo::simulation::ObstacleBypassCondition>(Arena*);
template<> ::apollo::simulation::OnRoadCondition* Arena::CreateMaybeMessage<::apollo::simulation::OnRoadCondition>(Arena*);
template<> ::apollo::simulation::RedLightStopCondition* Arena::CreateMaybeMessage<::apollo::simulation::RedLightStopCondition>(Arena*);
template<> ::apollo::simulation::RegionOverlapCondition* Arena::CreateMaybeMessage<::apollo::simulation::RegionOverlapCondition>(Arena*);
template<> ::apollo::simulation::RegionOverlapLWCondition* Arena::CreateMaybeMessage<::apollo::simulation::RegionOverlapLWCondition>(Arena*);
template<> ::apollo::simulation::RoutingCondition* Arena::CreateMaybeMessage<::apollo::simulation::RoutingCondition>(Arena*);
template<> ::apollo::simulation::RunRedLightCondition* Arena::CreateMaybeMessage<::apollo::simulation::RunRedLightCondition>(Arena*);
template<> ::apollo::simulation::RunStopSignCondition* Arena::CreateMaybeMessage<::apollo::simulation::RunStopSignCondition>(Arena*);
template<> ::apollo::simulation::SpeedCondition* Arena::CreateMaybeMessage<::apollo::simulation::SpeedCondition>(Arena*);
template<> ::apollo::simulation::SpeedbumpLimitCondition* Arena::CreateMaybeMessage<::apollo::simulation::SpeedbumpLimitCondition>(Arena*);
template<> ::apollo::simulation::SpinCondition* Arena::CreateMaybeMessage<::apollo::simulation::SpinCondition>(Arena*);
template<> ::apollo::simulation::TimeLimitCondition* Arena::CreateMaybeMessage<::apollo::simulation::TimeLimitCondition>(Arena*);
template<> ::apollo::simulation::WorkingZoneAvoidLimitCondition* Arena::CreateMaybeMessage<::apollo::simulation::WorkingZoneAvoidLimitCondition>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace apollo {
namespace simulation {

enum LogicalCondition_OperatorType : int {
  LogicalCondition_OperatorType_UNKNOWN = 0,
  LogicalCondition_OperatorType_NOT = 1,
  LogicalCondition_OperatorType_AND = 2,
  LogicalCondition_OperatorType_OR = 3,
  LogicalCondition_OperatorType_IMPLY = 4,
  LogicalCondition_OperatorType_XOR = 5
};
bool LogicalCondition_OperatorType_IsValid(int value);
constexpr LogicalCondition_OperatorType LogicalCondition_OperatorType_OperatorType_MIN = LogicalCondition_OperatorType_UNKNOWN;
constexpr LogicalCondition_OperatorType LogicalCondition_OperatorType_OperatorType_MAX = LogicalCondition_OperatorType_XOR;
constexpr int LogicalCondition_OperatorType_OperatorType_ARRAYSIZE = LogicalCondition_OperatorType_OperatorType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LogicalCondition_OperatorType_descriptor();
template<typename T>
inline const std::string& LogicalCondition_OperatorType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LogicalCondition_OperatorType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LogicalCondition_OperatorType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LogicalCondition_OperatorType_descriptor(), enum_t_value);
}
inline bool LogicalCondition_OperatorType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LogicalCondition_OperatorType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LogicalCondition_OperatorType>(
    LogicalCondition_OperatorType_descriptor(), name, value);
}
enum ObjectOverlapCondition_DirectionType : int {
  ObjectOverlapCondition_DirectionType_EXCLUDE_BACK = 0,
  ObjectOverlapCondition_DirectionType_INCLUDE_BACK = 1
};
bool ObjectOverlapCondition_DirectionType_IsValid(int value);
constexpr ObjectOverlapCondition_DirectionType ObjectOverlapCondition_DirectionType_DirectionType_MIN = ObjectOverlapCondition_DirectionType_EXCLUDE_BACK;
constexpr ObjectOverlapCondition_DirectionType ObjectOverlapCondition_DirectionType_DirectionType_MAX = ObjectOverlapCondition_DirectionType_INCLUDE_BACK;
constexpr int ObjectOverlapCondition_DirectionType_DirectionType_ARRAYSIZE = ObjectOverlapCondition_DirectionType_DirectionType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ObjectOverlapCondition_DirectionType_descriptor();
template<typename T>
inline const std::string& ObjectOverlapCondition_DirectionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ObjectOverlapCondition_DirectionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ObjectOverlapCondition_DirectionType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ObjectOverlapCondition_DirectionType_descriptor(), enum_t_value);
}
inline bool ObjectOverlapCondition_DirectionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ObjectOverlapCondition_DirectionType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ObjectOverlapCondition_DirectionType>(
    ObjectOverlapCondition_DirectionType_descriptor(), name, value);
}
// ===================================================================

class Condition PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.simulation.Condition) */ {
 public:
  inline Condition() : Condition(nullptr) {}
  virtual ~Condition();

  Condition(const Condition& from);
  Condition(Condition&& from) noexcept
    : Condition() {
    *this = ::std::move(from);
  }

  inline Condition& operator=(const Condition& from) {
    CopyFrom(from);
    return *this;
  }
  inline Condition& operator=(Condition&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Condition& default_instance();

  enum ConditionCase {
    kLogicalCondition = 1,
    kSpeedCondition = 2,
    kAccelerationCondition = 3,
    kJerkCondition = 4,
    kObjectOverlapCondition = 5,
    kRegionOverlapCondition = 6,
    kRegionOverlapLwCondition = 7,
    kSpinCondition = 8,
    kOnRoadCondition = 9,
    kRunRedLightCondition = 10,
    kChangeLaneAtJunctionCondition = 11,
    kRoutingCondition = 12,
    kCrosswalkYieldCondition = 13,
    kAbnormalStopCondition = 14,
    kBrakeTapCondition = 15,
    kRunStopSignCondition = 16,
    kCheckpointCondition = 17,
    kDistToEndCondition = 18,
    kDistToLaneCenterCondition = 19,
    kCrosswalkStopCondition = 20,
    kRedLightStopCondition = 21,
    kSpeedbumpLimitCondition = 22,
    kWorkingZoneAvoidLimitCondition = 23,
    kLimitedTimeParkingCondition = 24,
    kFollowAndBypassCondition = 25,
    kObstacleBypassCondition = 26,
    kCentripetalAccelerationCondition = 27,
    kTimeLimitCondition = 28,
    kAntiCheatingCondition = 29,
    kKeyPointCondition = 30,
    CONDITION_NOT_SET = 0,
  };

  static inline const Condition* internal_default_instance() {
    return reinterpret_cast<const Condition*>(
               &_Condition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Condition& a, Condition& b) {
    a.Swap(&b);
  }
  inline void Swap(Condition* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Condition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Condition* New() const final {
    return CreateMaybeMessage<Condition>(nullptr);
  }

  Condition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Condition>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Condition& from);
  void MergeFrom(const Condition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Condition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.simulation.Condition";
  }
  protected:
  explicit Condition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto);
    return ::descriptor_table_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGradePlanningFieldNumber = 100,
    kLogicalConditionFieldNumber = 1,
    kSpeedConditionFieldNumber = 2,
    kAccelerationConditionFieldNumber = 3,
    kJerkConditionFieldNumber = 4,
    kObjectOverlapConditionFieldNumber = 5,
    kRegionOverlapConditionFieldNumber = 6,
    kRegionOverlapLwConditionFieldNumber = 7,
    kSpinConditionFieldNumber = 8,
    kOnRoadConditionFieldNumber = 9,
    kRunRedLightConditionFieldNumber = 10,
    kChangeLaneAtJunctionConditionFieldNumber = 11,
    kRoutingConditionFieldNumber = 12,
    kCrosswalkYieldConditionFieldNumber = 13,
    kAbnormalStopConditionFieldNumber = 14,
    kBrakeTapConditionFieldNumber = 15,
    kRunStopSignConditionFieldNumber = 16,
    kCheckpointConditionFieldNumber = 17,
    kDistToEndConditionFieldNumber = 18,
    kDistToLaneCenterConditionFieldNumber = 19,
    kCrosswalkStopConditionFieldNumber = 20,
    kRedLightStopConditionFieldNumber = 21,
    kSpeedbumpLimitConditionFieldNumber = 22,
    kWorkingZoneAvoidLimitConditionFieldNumber = 23,
    kLimitedTimeParkingConditionFieldNumber = 24,
    kFollowAndBypassConditionFieldNumber = 25,
    kObstacleBypassConditionFieldNumber = 26,
    kCentripetalAccelerationConditionFieldNumber = 27,
    kTimeLimitConditionFieldNumber = 28,
    kAntiCheatingConditionFieldNumber = 29,
    kKeyPointConditionFieldNumber = 30,
  };
  // optional .apollo.simulation.GradePlanning grade_planning = 100;
  bool has_grade_planning() const;
  private:
  bool _internal_has_grade_planning() const;
  public:
  void clear_grade_planning();
  const ::apollo::simulation::GradePlanning& grade_planning() const;
  ::apollo::simulation::GradePlanning* release_grade_planning();
  ::apollo::simulation::GradePlanning* mutable_grade_planning();
  void set_allocated_grade_planning(::apollo::simulation::GradePlanning* grade_planning);
  private:
  const ::apollo::simulation::GradePlanning& _internal_grade_planning() const;
  ::apollo::simulation::GradePlanning* _internal_mutable_grade_planning();
  public:
  void unsafe_arena_set_allocated_grade_planning(
      ::apollo::simulation::GradePlanning* grade_planning);
  ::apollo::simulation::GradePlanning* unsafe_arena_release_grade_planning();

  // .apollo.simulation.LogicalCondition logical_condition = 1;
  bool has_logical_condition() const;
  private:
  bool _internal_has_logical_condition() const;
  public:
  void clear_logical_condition();
  const ::apollo::simulation::LogicalCondition& logical_condition() const;
  ::apollo::simulation::LogicalCondition* release_logical_condition();
  ::apollo::simulation::LogicalCondition* mutable_logical_condition();
  void set_allocated_logical_condition(::apollo::simulation::LogicalCondition* logical_condition);
  private:
  const ::apollo::simulation::LogicalCondition& _internal_logical_condition() const;
  ::apollo::simulation::LogicalCondition* _internal_mutable_logical_condition();
  public:
  void unsafe_arena_set_allocated_logical_condition(
      ::apollo::simulation::LogicalCondition* logical_condition);
  ::apollo::simulation::LogicalCondition* unsafe_arena_release_logical_condition();

  // .apollo.simulation.SpeedCondition speed_condition = 2;
  bool has_speed_condition() const;
  private:
  bool _internal_has_speed_condition() const;
  public:
  void clear_speed_condition();
  const ::apollo::simulation::SpeedCondition& speed_condition() const;
  ::apollo::simulation::SpeedCondition* release_speed_condition();
  ::apollo::simulation::SpeedCondition* mutable_speed_condition();
  void set_allocated_speed_condition(::apollo::simulation::SpeedCondition* speed_condition);
  private:
  const ::apollo::simulation::SpeedCondition& _internal_speed_condition() const;
  ::apollo::simulation::SpeedCondition* _internal_mutable_speed_condition();
  public:
  void unsafe_arena_set_allocated_speed_condition(
      ::apollo::simulation::SpeedCondition* speed_condition);
  ::apollo::simulation::SpeedCondition* unsafe_arena_release_speed_condition();

  // .apollo.simulation.AccelerationCondition acceleration_condition = 3;
  bool has_acceleration_condition() const;
  private:
  bool _internal_has_acceleration_condition() const;
  public:
  void clear_acceleration_condition();
  const ::apollo::simulation::AccelerationCondition& acceleration_condition() const;
  ::apollo::simulation::AccelerationCondition* release_acceleration_condition();
  ::apollo::simulation::AccelerationCondition* mutable_acceleration_condition();
  void set_allocated_acceleration_condition(::apollo::simulation::AccelerationCondition* acceleration_condition);
  private:
  const ::apollo::simulation::AccelerationCondition& _internal_acceleration_condition() const;
  ::apollo::simulation::AccelerationCondition* _internal_mutable_acceleration_condition();
  public:
  void unsafe_arena_set_allocated_acceleration_condition(
      ::apollo::simulation::AccelerationCondition* acceleration_condition);
  ::apollo::simulation::AccelerationCondition* unsafe_arena_release_acceleration_condition();

  // .apollo.simulation.JerkCondition jerk_condition = 4;
  bool has_jerk_condition() const;
  private:
  bool _internal_has_jerk_condition() const;
  public:
  void clear_jerk_condition();
  const ::apollo::simulation::JerkCondition& jerk_condition() const;
  ::apollo::simulation::JerkCondition* release_jerk_condition();
  ::apollo::simulation::JerkCondition* mutable_jerk_condition();
  void set_allocated_jerk_condition(::apollo::simulation::JerkCondition* jerk_condition);
  private:
  const ::apollo::simulation::JerkCondition& _internal_jerk_condition() const;
  ::apollo::simulation::JerkCondition* _internal_mutable_jerk_condition();
  public:
  void unsafe_arena_set_allocated_jerk_condition(
      ::apollo::simulation::JerkCondition* jerk_condition);
  ::apollo::simulation::JerkCondition* unsafe_arena_release_jerk_condition();

  // .apollo.simulation.ObjectOverlapCondition object_overlap_condition = 5;
  bool has_object_overlap_condition() const;
  private:
  bool _internal_has_object_overlap_condition() const;
  public:
  void clear_object_overlap_condition();
  const ::apollo::simulation::ObjectOverlapCondition& object_overlap_condition() const;
  ::apollo::simulation::ObjectOverlapCondition* release_object_overlap_condition();
  ::apollo::simulation::ObjectOverlapCondition* mutable_object_overlap_condition();
  void set_allocated_object_overlap_condition(::apollo::simulation::ObjectOverlapCondition* object_overlap_condition);
  private:
  const ::apollo::simulation::ObjectOverlapCondition& _internal_object_overlap_condition() const;
  ::apollo::simulation::ObjectOverlapCondition* _internal_mutable_object_overlap_condition();
  public:
  void unsafe_arena_set_allocated_object_overlap_condition(
      ::apollo::simulation::ObjectOverlapCondition* object_overlap_condition);
  ::apollo::simulation::ObjectOverlapCondition* unsafe_arena_release_object_overlap_condition();

  // .apollo.simulation.RegionOverlapCondition region_overlap_condition = 6;
  bool has_region_overlap_condition() const;
  private:
  bool _internal_has_region_overlap_condition() const;
  public:
  void clear_region_overlap_condition();
  const ::apollo::simulation::RegionOverlapCondition& region_overlap_condition() const;
  ::apollo::simulation::RegionOverlapCondition* release_region_overlap_condition();
  ::apollo::simulation::RegionOverlapCondition* mutable_region_overlap_condition();
  void set_allocated_region_overlap_condition(::apollo::simulation::RegionOverlapCondition* region_overlap_condition);
  private:
  const ::apollo::simulation::RegionOverlapCondition& _internal_region_overlap_condition() const;
  ::apollo::simulation::RegionOverlapCondition* _internal_mutable_region_overlap_condition();
  public:
  void unsafe_arena_set_allocated_region_overlap_condition(
      ::apollo::simulation::RegionOverlapCondition* region_overlap_condition);
  ::apollo::simulation::RegionOverlapCondition* unsafe_arena_release_region_overlap_condition();

  // .apollo.simulation.RegionOverlapLWCondition region_overlap_lw_condition = 7;
  bool has_region_overlap_lw_condition() const;
  private:
  bool _internal_has_region_overlap_lw_condition() const;
  public:
  void clear_region_overlap_lw_condition();
  const ::apollo::simulation::RegionOverlapLWCondition& region_overlap_lw_condition() const;
  ::apollo::simulation::RegionOverlapLWCondition* release_region_overlap_lw_condition();
  ::apollo::simulation::RegionOverlapLWCondition* mutable_region_overlap_lw_condition();
  void set_allocated_region_overlap_lw_condition(::apollo::simulation::RegionOverlapLWCondition* region_overlap_lw_condition);
  private:
  const ::apollo::simulation::RegionOverlapLWCondition& _internal_region_overlap_lw_condition() const;
  ::apollo::simulation::RegionOverlapLWCondition* _internal_mutable_region_overlap_lw_condition();
  public:
  void unsafe_arena_set_allocated_region_overlap_lw_condition(
      ::apollo::simulation::RegionOverlapLWCondition* region_overlap_lw_condition);
  ::apollo::simulation::RegionOverlapLWCondition* unsafe_arena_release_region_overlap_lw_condition();

  // .apollo.simulation.SpinCondition spin_condition = 8;
  bool has_spin_condition() const;
  private:
  bool _internal_has_spin_condition() const;
  public:
  void clear_spin_condition();
  const ::apollo::simulation::SpinCondition& spin_condition() const;
  ::apollo::simulation::SpinCondition* release_spin_condition();
  ::apollo::simulation::SpinCondition* mutable_spin_condition();
  void set_allocated_spin_condition(::apollo::simulation::SpinCondition* spin_condition);
  private:
  const ::apollo::simulation::SpinCondition& _internal_spin_condition() const;
  ::apollo::simulation::SpinCondition* _internal_mutable_spin_condition();
  public:
  void unsafe_arena_set_allocated_spin_condition(
      ::apollo::simulation::SpinCondition* spin_condition);
  ::apollo::simulation::SpinCondition* unsafe_arena_release_spin_condition();

  // .apollo.simulation.OnRoadCondition on_road_condition = 9;
  bool has_on_road_condition() const;
  private:
  bool _internal_has_on_road_condition() const;
  public:
  void clear_on_road_condition();
  const ::apollo::simulation::OnRoadCondition& on_road_condition() const;
  ::apollo::simulation::OnRoadCondition* release_on_road_condition();
  ::apollo::simulation::OnRoadCondition* mutable_on_road_condition();
  void set_allocated_on_road_condition(::apollo::simulation::OnRoadCondition* on_road_condition);
  private:
  const ::apollo::simulation::OnRoadCondition& _internal_on_road_condition() const;
  ::apollo::simulation::OnRoadCondition* _internal_mutable_on_road_condition();
  public:
  void unsafe_arena_set_allocated_on_road_condition(
      ::apollo::simulation::OnRoadCondition* on_road_condition);
  ::apollo::simulation::OnRoadCondition* unsafe_arena_release_on_road_condition();

  // .apollo.simulation.RunRedLightCondition run_red_light_condition = 10;
  bool has_run_red_light_condition() const;
  private:
  bool _internal_has_run_red_light_condition() const;
  public:
  void clear_run_red_light_condition();
  const ::apollo::simulation::RunRedLightCondition& run_red_light_condition() const;
  ::apollo::simulation::RunRedLightCondition* release_run_red_light_condition();
  ::apollo::simulation::RunRedLightCondition* mutable_run_red_light_condition();
  void set_allocated_run_red_light_condition(::apollo::simulation::RunRedLightCondition* run_red_light_condition);
  private:
  const ::apollo::simulation::RunRedLightCondition& _internal_run_red_light_condition() const;
  ::apollo::simulation::RunRedLightCondition* _internal_mutable_run_red_light_condition();
  public:
  void unsafe_arena_set_allocated_run_red_light_condition(
      ::apollo::simulation::RunRedLightCondition* run_red_light_condition);
  ::apollo::simulation::RunRedLightCondition* unsafe_arena_release_run_red_light_condition();

  // .apollo.simulation.ChangeLaneAtJunctionCondition change_lane_at_junction_condition = 11;
  bool has_change_lane_at_junction_condition() const;
  private:
  bool _internal_has_change_lane_at_junction_condition() const;
  public:
  void clear_change_lane_at_junction_condition();
  const ::apollo::simulation::ChangeLaneAtJunctionCondition& change_lane_at_junction_condition() const;
  ::apollo::simulation::ChangeLaneAtJunctionCondition* release_change_lane_at_junction_condition();
  ::apollo::simulation::ChangeLaneAtJunctionCondition* mutable_change_lane_at_junction_condition();
  void set_allocated_change_lane_at_junction_condition(::apollo::simulation::ChangeLaneAtJunctionCondition* change_lane_at_junction_condition);
  private:
  const ::apollo::simulation::ChangeLaneAtJunctionCondition& _internal_change_lane_at_junction_condition() const;
  ::apollo::simulation::ChangeLaneAtJunctionCondition* _internal_mutable_change_lane_at_junction_condition();
  public:
  void unsafe_arena_set_allocated_change_lane_at_junction_condition(
      ::apollo::simulation::ChangeLaneAtJunctionCondition* change_lane_at_junction_condition);
  ::apollo::simulation::ChangeLaneAtJunctionCondition* unsafe_arena_release_change_lane_at_junction_condition();

  // .apollo.simulation.RoutingCondition routing_condition = 12;
  bool has_routing_condition() const;
  private:
  bool _internal_has_routing_condition() const;
  public:
  void clear_routing_condition();
  const ::apollo::simulation::RoutingCondition& routing_condition() const;
  ::apollo::simulation::RoutingCondition* release_routing_condition();
  ::apollo::simulation::RoutingCondition* mutable_routing_condition();
  void set_allocated_routing_condition(::apollo::simulation::RoutingCondition* routing_condition);
  private:
  const ::apollo::simulation::RoutingCondition& _internal_routing_condition() const;
  ::apollo::simulation::RoutingCondition* _internal_mutable_routing_condition();
  public:
  void unsafe_arena_set_allocated_routing_condition(
      ::apollo::simulation::RoutingCondition* routing_condition);
  ::apollo::simulation::RoutingCondition* unsafe_arena_release_routing_condition();

  // .apollo.simulation.CrosswalkYieldCondition crosswalk_yield_condition = 13;
  bool has_crosswalk_yield_condition() const;
  private:
  bool _internal_has_crosswalk_yield_condition() const;
  public:
  void clear_crosswalk_yield_condition();
  const ::apollo::simulation::CrosswalkYieldCondition& crosswalk_yield_condition() const;
  ::apollo::simulation::CrosswalkYieldCondition* release_crosswalk_yield_condition();
  ::apollo::simulation::CrosswalkYieldCondition* mutable_crosswalk_yield_condition();
  void set_allocated_crosswalk_yield_condition(::apollo::simulation::CrosswalkYieldCondition* crosswalk_yield_condition);
  private:
  const ::apollo::simulation::CrosswalkYieldCondition& _internal_crosswalk_yield_condition() const;
  ::apollo::simulation::CrosswalkYieldCondition* _internal_mutable_crosswalk_yield_condition();
  public:
  void unsafe_arena_set_allocated_crosswalk_yield_condition(
      ::apollo::simulation::CrosswalkYieldCondition* crosswalk_yield_condition);
  ::apollo::simulation::CrosswalkYieldCondition* unsafe_arena_release_crosswalk_yield_condition();

  // .apollo.simulation.AbnormalStopCondition abnormal_stop_condition = 14;
  bool has_abnormal_stop_condition() const;
  private:
  bool _internal_has_abnormal_stop_condition() const;
  public:
  void clear_abnormal_stop_condition();
  const ::apollo::simulation::AbnormalStopCondition& abnormal_stop_condition() const;
  ::apollo::simulation::AbnormalStopCondition* release_abnormal_stop_condition();
  ::apollo::simulation::AbnormalStopCondition* mutable_abnormal_stop_condition();
  void set_allocated_abnormal_stop_condition(::apollo::simulation::AbnormalStopCondition* abnormal_stop_condition);
  private:
  const ::apollo::simulation::AbnormalStopCondition& _internal_abnormal_stop_condition() const;
  ::apollo::simulation::AbnormalStopCondition* _internal_mutable_abnormal_stop_condition();
  public:
  void unsafe_arena_set_allocated_abnormal_stop_condition(
      ::apollo::simulation::AbnormalStopCondition* abnormal_stop_condition);
  ::apollo::simulation::AbnormalStopCondition* unsafe_arena_release_abnormal_stop_condition();

  // .apollo.simulation.BrakeTapCondition brake_tap_condition = 15;
  bool has_brake_tap_condition() const;
  private:
  bool _internal_has_brake_tap_condition() const;
  public:
  void clear_brake_tap_condition();
  const ::apollo::simulation::BrakeTapCondition& brake_tap_condition() const;
  ::apollo::simulation::BrakeTapCondition* release_brake_tap_condition();
  ::apollo::simulation::BrakeTapCondition* mutable_brake_tap_condition();
  void set_allocated_brake_tap_condition(::apollo::simulation::BrakeTapCondition* brake_tap_condition);
  private:
  const ::apollo::simulation::BrakeTapCondition& _internal_brake_tap_condition() const;
  ::apollo::simulation::BrakeTapCondition* _internal_mutable_brake_tap_condition();
  public:
  void unsafe_arena_set_allocated_brake_tap_condition(
      ::apollo::simulation::BrakeTapCondition* brake_tap_condition);
  ::apollo::simulation::BrakeTapCondition* unsafe_arena_release_brake_tap_condition();

  // .apollo.simulation.RunStopSignCondition run_stop_sign_condition = 16;
  bool has_run_stop_sign_condition() const;
  private:
  bool _internal_has_run_stop_sign_condition() const;
  public:
  void clear_run_stop_sign_condition();
  const ::apollo::simulation::RunStopSignCondition& run_stop_sign_condition() const;
  ::apollo::simulation::RunStopSignCondition* release_run_stop_sign_condition();
  ::apollo::simulation::RunStopSignCondition* mutable_run_stop_sign_condition();
  void set_allocated_run_stop_sign_condition(::apollo::simulation::RunStopSignCondition* run_stop_sign_condition);
  private:
  const ::apollo::simulation::RunStopSignCondition& _internal_run_stop_sign_condition() const;
  ::apollo::simulation::RunStopSignCondition* _internal_mutable_run_stop_sign_condition();
  public:
  void unsafe_arena_set_allocated_run_stop_sign_condition(
      ::apollo::simulation::RunStopSignCondition* run_stop_sign_condition);
  ::apollo::simulation::RunStopSignCondition* unsafe_arena_release_run_stop_sign_condition();

  // .apollo.simulation.CheckpointCondition checkpoint_condition = 17;
  bool has_checkpoint_condition() const;
  private:
  bool _internal_has_checkpoint_condition() const;
  public:
  void clear_checkpoint_condition();
  const ::apollo::simulation::CheckpointCondition& checkpoint_condition() const;
  ::apollo::simulation::CheckpointCondition* release_checkpoint_condition();
  ::apollo::simulation::CheckpointCondition* mutable_checkpoint_condition();
  void set_allocated_checkpoint_condition(::apollo::simulation::CheckpointCondition* checkpoint_condition);
  private:
  const ::apollo::simulation::CheckpointCondition& _internal_checkpoint_condition() const;
  ::apollo::simulation::CheckpointCondition* _internal_mutable_checkpoint_condition();
  public:
  void unsafe_arena_set_allocated_checkpoint_condition(
      ::apollo::simulation::CheckpointCondition* checkpoint_condition);
  ::apollo::simulation::CheckpointCondition* unsafe_arena_release_checkpoint_condition();

  // .apollo.simulation.DistToEndCondition dist_to_end_condition = 18;
  bool has_dist_to_end_condition() const;
  private:
  bool _internal_has_dist_to_end_condition() const;
  public:
  void clear_dist_to_end_condition();
  const ::apollo::simulation::DistToEndCondition& dist_to_end_condition() const;
  ::apollo::simulation::DistToEndCondition* release_dist_to_end_condition();
  ::apollo::simulation::DistToEndCondition* mutable_dist_to_end_condition();
  void set_allocated_dist_to_end_condition(::apollo::simulation::DistToEndCondition* dist_to_end_condition);
  private:
  const ::apollo::simulation::DistToEndCondition& _internal_dist_to_end_condition() const;
  ::apollo::simulation::DistToEndCondition* _internal_mutable_dist_to_end_condition();
  public:
  void unsafe_arena_set_allocated_dist_to_end_condition(
      ::apollo::simulation::DistToEndCondition* dist_to_end_condition);
  ::apollo::simulation::DistToEndCondition* unsafe_arena_release_dist_to_end_condition();

  // .apollo.simulation.DistToLaneCenterCondition dist_to_lane_center_condition = 19;
  bool has_dist_to_lane_center_condition() const;
  private:
  bool _internal_has_dist_to_lane_center_condition() const;
  public:
  void clear_dist_to_lane_center_condition();
  const ::apollo::simulation::DistToLaneCenterCondition& dist_to_lane_center_condition() const;
  ::apollo::simulation::DistToLaneCenterCondition* release_dist_to_lane_center_condition();
  ::apollo::simulation::DistToLaneCenterCondition* mutable_dist_to_lane_center_condition();
  void set_allocated_dist_to_lane_center_condition(::apollo::simulation::DistToLaneCenterCondition* dist_to_lane_center_condition);
  private:
  const ::apollo::simulation::DistToLaneCenterCondition& _internal_dist_to_lane_center_condition() const;
  ::apollo::simulation::DistToLaneCenterCondition* _internal_mutable_dist_to_lane_center_condition();
  public:
  void unsafe_arena_set_allocated_dist_to_lane_center_condition(
      ::apollo::simulation::DistToLaneCenterCondition* dist_to_lane_center_condition);
  ::apollo::simulation::DistToLaneCenterCondition* unsafe_arena_release_dist_to_lane_center_condition();

  // .apollo.simulation.CrosswalkStopCondition crosswalk_stop_condition = 20;
  bool has_crosswalk_stop_condition() const;
  private:
  bool _internal_has_crosswalk_stop_condition() const;
  public:
  void clear_crosswalk_stop_condition();
  const ::apollo::simulation::CrosswalkStopCondition& crosswalk_stop_condition() const;
  ::apollo::simulation::CrosswalkStopCondition* release_crosswalk_stop_condition();
  ::apollo::simulation::CrosswalkStopCondition* mutable_crosswalk_stop_condition();
  void set_allocated_crosswalk_stop_condition(::apollo::simulation::CrosswalkStopCondition* crosswalk_stop_condition);
  private:
  const ::apollo::simulation::CrosswalkStopCondition& _internal_crosswalk_stop_condition() const;
  ::apollo::simulation::CrosswalkStopCondition* _internal_mutable_crosswalk_stop_condition();
  public:
  void unsafe_arena_set_allocated_crosswalk_stop_condition(
      ::apollo::simulation::CrosswalkStopCondition* crosswalk_stop_condition);
  ::apollo::simulation::CrosswalkStopCondition* unsafe_arena_release_crosswalk_stop_condition();

  // .apollo.simulation.RedLightStopCondition red_light_stop_condition = 21;
  bool has_red_light_stop_condition() const;
  private:
  bool _internal_has_red_light_stop_condition() const;
  public:
  void clear_red_light_stop_condition();
  const ::apollo::simulation::RedLightStopCondition& red_light_stop_condition() const;
  ::apollo::simulation::RedLightStopCondition* release_red_light_stop_condition();
  ::apollo::simulation::RedLightStopCondition* mutable_red_light_stop_condition();
  void set_allocated_red_light_stop_condition(::apollo::simulation::RedLightStopCondition* red_light_stop_condition);
  private:
  const ::apollo::simulation::RedLightStopCondition& _internal_red_light_stop_condition() const;
  ::apollo::simulation::RedLightStopCondition* _internal_mutable_red_light_stop_condition();
  public:
  void unsafe_arena_set_allocated_red_light_stop_condition(
      ::apollo::simulation::RedLightStopCondition* red_light_stop_condition);
  ::apollo::simulation::RedLightStopCondition* unsafe_arena_release_red_light_stop_condition();

  // .apollo.simulation.SpeedbumpLimitCondition speedbump_limit_condition = 22;
  bool has_speedbump_limit_condition() const;
  private:
  bool _internal_has_speedbump_limit_condition() const;
  public:
  void clear_speedbump_limit_condition();
  const ::apollo::simulation::SpeedbumpLimitCondition& speedbump_limit_condition() const;
  ::apollo::simulation::SpeedbumpLimitCondition* release_speedbump_limit_condition();
  ::apollo::simulation::SpeedbumpLimitCondition* mutable_speedbump_limit_condition();
  void set_allocated_speedbump_limit_condition(::apollo::simulation::SpeedbumpLimitCondition* speedbump_limit_condition);
  private:
  const ::apollo::simulation::SpeedbumpLimitCondition& _internal_speedbump_limit_condition() const;
  ::apollo::simulation::SpeedbumpLimitCondition* _internal_mutable_speedbump_limit_condition();
  public:
  void unsafe_arena_set_allocated_speedbump_limit_condition(
      ::apollo::simulation::SpeedbumpLimitCondition* speedbump_limit_condition);
  ::apollo::simulation::SpeedbumpLimitCondition* unsafe_arena_release_speedbump_limit_condition();

  // .apollo.simulation.WorkingZoneAvoidLimitCondition working_zone_avoid_limit_condition = 23;
  bool has_working_zone_avoid_limit_condition() const;
  private:
  bool _internal_has_working_zone_avoid_limit_condition() const;
  public:
  void clear_working_zone_avoid_limit_condition();
  const ::apollo::simulation::WorkingZoneAvoidLimitCondition& working_zone_avoid_limit_condition() const;
  ::apollo::simulation::WorkingZoneAvoidLimitCondition* release_working_zone_avoid_limit_condition();
  ::apollo::simulation::WorkingZoneAvoidLimitCondition* mutable_working_zone_avoid_limit_condition();
  void set_allocated_working_zone_avoid_limit_condition(::apollo::simulation::WorkingZoneAvoidLimitCondition* working_zone_avoid_limit_condition);
  private:
  const ::apollo::simulation::WorkingZoneAvoidLimitCondition& _internal_working_zone_avoid_limit_condition() const;
  ::apollo::simulation::WorkingZoneAvoidLimitCondition* _internal_mutable_working_zone_avoid_limit_condition();
  public:
  void unsafe_arena_set_allocated_working_zone_avoid_limit_condition(
      ::apollo::simulation::WorkingZoneAvoidLimitCondition* working_zone_avoid_limit_condition);
  ::apollo::simulation::WorkingZoneAvoidLimitCondition* unsafe_arena_release_working_zone_avoid_limit_condition();

  // .apollo.simulation.LimitedTimeParkingCondition limited_time_parking_condition = 24;
  bool has_limited_time_parking_condition() const;
  private:
  bool _internal_has_limited_time_parking_condition() const;
  public:
  void clear_limited_time_parking_condition();
  const ::apollo::simulation::LimitedTimeParkingCondition& limited_time_parking_condition() const;
  ::apollo::simulation::LimitedTimeParkingCondition* release_limited_time_parking_condition();
  ::apollo::simulation::LimitedTimeParkingCondition* mutable_limited_time_parking_condition();
  void set_allocated_limited_time_parking_condition(::apollo::simulation::LimitedTimeParkingCondition* limited_time_parking_condition);
  private:
  const ::apollo::simulation::LimitedTimeParkingCondition& _internal_limited_time_parking_condition() const;
  ::apollo::simulation::LimitedTimeParkingCondition* _internal_mutable_limited_time_parking_condition();
  public:
  void unsafe_arena_set_allocated_limited_time_parking_condition(
      ::apollo::simulation::LimitedTimeParkingCondition* limited_time_parking_condition);
  ::apollo::simulation::LimitedTimeParkingCondition* unsafe_arena_release_limited_time_parking_condition();

  // .apollo.simulation.FollowAndBypassCondition follow_and_bypass_condition = 25;
  bool has_follow_and_bypass_condition() const;
  private:
  bool _internal_has_follow_and_bypass_condition() const;
  public:
  void clear_follow_and_bypass_condition();
  const ::apollo::simulation::FollowAndBypassCondition& follow_and_bypass_condition() const;
  ::apollo::simulation::FollowAndBypassCondition* release_follow_and_bypass_condition();
  ::apollo::simulation::FollowAndBypassCondition* mutable_follow_and_bypass_condition();
  void set_allocated_follow_and_bypass_condition(::apollo::simulation::FollowAndBypassCondition* follow_and_bypass_condition);
  private:
  const ::apollo::simulation::FollowAndBypassCondition& _internal_follow_and_bypass_condition() const;
  ::apollo::simulation::FollowAndBypassCondition* _internal_mutable_follow_and_bypass_condition();
  public:
  void unsafe_arena_set_allocated_follow_and_bypass_condition(
      ::apollo::simulation::FollowAndBypassCondition* follow_and_bypass_condition);
  ::apollo::simulation::FollowAndBypassCondition* unsafe_arena_release_follow_and_bypass_condition();

  // .apollo.simulation.ObstacleBypassCondition obstacle_bypass_condition = 26;
  bool has_obstacle_bypass_condition() const;
  private:
  bool _internal_has_obstacle_bypass_condition() const;
  public:
  void clear_obstacle_bypass_condition();
  const ::apollo::simulation::ObstacleBypassCondition& obstacle_bypass_condition() const;
  ::apollo::simulation::ObstacleBypassCondition* release_obstacle_bypass_condition();
  ::apollo::simulation::ObstacleBypassCondition* mutable_obstacle_bypass_condition();
  void set_allocated_obstacle_bypass_condition(::apollo::simulation::ObstacleBypassCondition* obstacle_bypass_condition);
  private:
  const ::apollo::simulation::ObstacleBypassCondition& _internal_obstacle_bypass_condition() const;
  ::apollo::simulation::ObstacleBypassCondition* _internal_mutable_obstacle_bypass_condition();
  public:
  void unsafe_arena_set_allocated_obstacle_bypass_condition(
      ::apollo::simulation::ObstacleBypassCondition* obstacle_bypass_condition);
  ::apollo::simulation::ObstacleBypassCondition* unsafe_arena_release_obstacle_bypass_condition();

  // .apollo.simulation.CentripetalAccelerationCondition centripetal_acceleration_condition = 27;
  bool has_centripetal_acceleration_condition() const;
  private:
  bool _internal_has_centripetal_acceleration_condition() const;
  public:
  void clear_centripetal_acceleration_condition();
  const ::apollo::simulation::CentripetalAccelerationCondition& centripetal_acceleration_condition() const;
  ::apollo::simulation::CentripetalAccelerationCondition* release_centripetal_acceleration_condition();
  ::apollo::simulation::CentripetalAccelerationCondition* mutable_centripetal_acceleration_condition();
  void set_allocated_centripetal_acceleration_condition(::apollo::simulation::CentripetalAccelerationCondition* centripetal_acceleration_condition);
  private:
  const ::apollo::simulation::CentripetalAccelerationCondition& _internal_centripetal_acceleration_condition() const;
  ::apollo::simulation::CentripetalAccelerationCondition* _internal_mutable_centripetal_acceleration_condition();
  public:
  void unsafe_arena_set_allocated_centripetal_acceleration_condition(
      ::apollo::simulation::CentripetalAccelerationCondition* centripetal_acceleration_condition);
  ::apollo::simulation::CentripetalAccelerationCondition* unsafe_arena_release_centripetal_acceleration_condition();

  // .apollo.simulation.TimeLimitCondition time_limit_condition = 28;
  bool has_time_limit_condition() const;
  private:
  bool _internal_has_time_limit_condition() const;
  public:
  void clear_time_limit_condition();
  const ::apollo::simulation::TimeLimitCondition& time_limit_condition() const;
  ::apollo::simulation::TimeLimitCondition* release_time_limit_condition();
  ::apollo::simulation::TimeLimitCondition* mutable_time_limit_condition();
  void set_allocated_time_limit_condition(::apollo::simulation::TimeLimitCondition* time_limit_condition);
  private:
  const ::apollo::simulation::TimeLimitCondition& _internal_time_limit_condition() const;
  ::apollo::simulation::TimeLimitCondition* _internal_mutable_time_limit_condition();
  public:
  void unsafe_arena_set_allocated_time_limit_condition(
      ::apollo::simulation::TimeLimitCondition* time_limit_condition);
  ::apollo::simulation::TimeLimitCondition* unsafe_arena_release_time_limit_condition();

  // .apollo.simulation.AntiCheatingCondition anti_cheating_condition = 29;
  bool has_anti_cheating_condition() const;
  private:
  bool _internal_has_anti_cheating_condition() const;
  public:
  void clear_anti_cheating_condition();
  const ::apollo::simulation::AntiCheatingCondition& anti_cheating_condition() const;
  ::apollo::simulation::AntiCheatingCondition* release_anti_cheating_condition();
  ::apollo::simulation::AntiCheatingCondition* mutable_anti_cheating_condition();
  void set_allocated_anti_cheating_condition(::apollo::simulation::AntiCheatingCondition* anti_cheating_condition);
  private:
  const ::apollo::simulation::AntiCheatingCondition& _internal_anti_cheating_condition() const;
  ::apollo::simulation::AntiCheatingCondition* _internal_mutable_anti_cheating_condition();
  public:
  void unsafe_arena_set_allocated_anti_cheating_condition(
      ::apollo::simulation::AntiCheatingCondition* anti_cheating_condition);
  ::apollo::simulation::AntiCheatingCondition* unsafe_arena_release_anti_cheating_condition();

  // .apollo.simulation.KeyPointCondition key_point_condition = 30;
  bool has_key_point_condition() const;
  private:
  bool _internal_has_key_point_condition() const;
  public:
  void clear_key_point_condition();
  const ::apollo::simulation::KeyPointCondition& key_point_condition() const;
  ::apollo::simulation::KeyPointCondition* release_key_point_condition();
  ::apollo::simulation::KeyPointCondition* mutable_key_point_condition();
  void set_allocated_key_point_condition(::apollo::simulation::KeyPointCondition* key_point_condition);
  private:
  const ::apollo::simulation::KeyPointCondition& _internal_key_point_condition() const;
  ::apollo::simulation::KeyPointCondition* _internal_mutable_key_point_condition();
  public:
  void unsafe_arena_set_allocated_key_point_condition(
      ::apollo::simulation::KeyPointCondition* key_point_condition);
  ::apollo::simulation::KeyPointCondition* unsafe_arena_release_key_point_condition();

  void clear_condition();
  ConditionCase condition_case() const;
  // @@protoc_insertion_point(class_scope:apollo.simulation.Condition)
 private:
  class _Internal;
  void set_has_logical_condition();
  void set_has_speed_condition();
  void set_has_acceleration_condition();
  void set_has_jerk_condition();
  void set_has_object_overlap_condition();
  void set_has_region_overlap_condition();
  void set_has_region_overlap_lw_condition();
  void set_has_spin_condition();
  void set_has_on_road_condition();
  void set_has_run_red_light_condition();
  void set_has_change_lane_at_junction_condition();
  void set_has_routing_condition();
  void set_has_crosswalk_yield_condition();
  void set_has_abnormal_stop_condition();
  void set_has_brake_tap_condition();
  void set_has_run_stop_sign_condition();
  void set_has_checkpoint_condition();
  void set_has_dist_to_end_condition();
  void set_has_dist_to_lane_center_condition();
  void set_has_crosswalk_stop_condition();
  void set_has_red_light_stop_condition();
  void set_has_speedbump_limit_condition();
  void set_has_working_zone_avoid_limit_condition();
  void set_has_limited_time_parking_condition();
  void set_has_follow_and_bypass_condition();
  void set_has_obstacle_bypass_condition();
  void set_has_centripetal_acceleration_condition();
  void set_has_time_limit_condition();
  void set_has_anti_cheating_condition();
  void set_has_key_point_condition();

  inline bool has_condition() const;
  inline void clear_has_condition();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::apollo::simulation::GradePlanning* grade_planning_;
  union ConditionUnion {
    ConditionUnion() {}
    ::apollo::simulation::LogicalCondition* logical_condition_;
    ::apollo::simulation::SpeedCondition* speed_condition_;
    ::apollo::simulation::AccelerationCondition* acceleration_condition_;
    ::apollo::simulation::JerkCondition* jerk_condition_;
    ::apollo::simulation::ObjectOverlapCondition* object_overlap_condition_;
    ::apollo::simulation::RegionOverlapCondition* region_overlap_condition_;
    ::apollo::simulation::RegionOverlapLWCondition* region_overlap_lw_condition_;
    ::apollo::simulation::SpinCondition* spin_condition_;
    ::apollo::simulation::OnRoadCondition* on_road_condition_;
    ::apollo::simulation::RunRedLightCondition* run_red_light_condition_;
    ::apollo::simulation::ChangeLaneAtJunctionCondition* change_lane_at_junction_condition_;
    ::apollo::simulation::RoutingCondition* routing_condition_;
    ::apollo::simulation::CrosswalkYieldCondition* crosswalk_yield_condition_;
    ::apollo::simulation::AbnormalStopCondition* abnormal_stop_condition_;
    ::apollo::simulation::BrakeTapCondition* brake_tap_condition_;
    ::apollo::simulation::RunStopSignCondition* run_stop_sign_condition_;
    ::apollo::simulation::CheckpointCondition* checkpoint_condition_;
    ::apollo::simulation::DistToEndCondition* dist_to_end_condition_;
    ::apollo::simulation::DistToLaneCenterCondition* dist_to_lane_center_condition_;
    ::apollo::simulation::CrosswalkStopCondition* crosswalk_stop_condition_;
    ::apollo::simulation::RedLightStopCondition* red_light_stop_condition_;
    ::apollo::simulation::SpeedbumpLimitCondition* speedbump_limit_condition_;
    ::apollo::simulation::WorkingZoneAvoidLimitCondition* working_zone_avoid_limit_condition_;
    ::apollo::simulation::LimitedTimeParkingCondition* limited_time_parking_condition_;
    ::apollo::simulation::FollowAndBypassCondition* follow_and_bypass_condition_;
    ::apollo::simulation::ObstacleBypassCondition* obstacle_bypass_condition_;
    ::apollo::simulation::CentripetalAccelerationCondition* centripetal_acceleration_condition_;
    ::apollo::simulation::TimeLimitCondition* time_limit_condition_;
    ::apollo::simulation::AntiCheatingCondition* anti_cheating_condition_;
    ::apollo::simulation::KeyPointCondition* key_point_condition_;
  } condition_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto;
};
// -------------------------------------------------------------------

class GradePlanning PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.simulation.GradePlanning) */ {
 public:
  inline GradePlanning() : GradePlanning(nullptr) {}
  virtual ~GradePlanning();

  GradePlanning(const GradePlanning& from);
  GradePlanning(GradePlanning&& from) noexcept
    : GradePlanning() {
    *this = ::std::move(from);
  }

  inline GradePlanning& operator=(const GradePlanning& from) {
    CopyFrom(from);
    return *this;
  }
  inline GradePlanning& operator=(GradePlanning&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GradePlanning& default_instance();

  static inline const GradePlanning* internal_default_instance() {
    return reinterpret_cast<const GradePlanning*>(
               &_GradePlanning_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(GradePlanning& a, GradePlanning& b) {
    a.Swap(&b);
  }
  inline void Swap(GradePlanning* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GradePlanning* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GradePlanning* New() const final {
    return CreateMaybeMessage<GradePlanning>(nullptr);
  }

  GradePlanning* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GradePlanning>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GradePlanning& from);
  void MergeFrom(const GradePlanning& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GradePlanning* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.simulation.GradePlanning";
  }
  protected:
  explicit GradePlanning(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto);
    return ::descriptor_table_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDurationFieldNumber = 1,
    kUpdateObstaclesFieldNumber = 2,
    kUsePlanningAsHistoryFieldNumber = 3,
  };
  // optional sint32 duration = 1 [default = 0];
  bool has_duration() const;
  private:
  bool _internal_has_duration() const;
  public:
  void clear_duration();
  ::PROTOBUF_NAMESPACE_ID::int32 duration() const;
  void set_duration(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_duration() const;
  void _internal_set_duration(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional bool update_obstacles = 2 [default = false];
  bool has_update_obstacles() const;
  private:
  bool _internal_has_update_obstacles() const;
  public:
  void clear_update_obstacles();
  bool update_obstacles() const;
  void set_update_obstacles(bool value);
  private:
  bool _internal_update_obstacles() const;
  void _internal_set_update_obstacles(bool value);
  public:

  // optional bool use_planning_as_history = 3 [default = false];
  bool has_use_planning_as_history() const;
  private:
  bool _internal_has_use_planning_as_history() const;
  public:
  void clear_use_planning_as_history();
  bool use_planning_as_history() const;
  void set_use_planning_as_history(bool value);
  private:
  bool _internal_use_planning_as_history() const;
  void _internal_set_use_planning_as_history(bool value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.simulation.GradePlanning)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 duration_;
  bool update_obstacles_;
  bool use_planning_as_history_;
  friend struct ::TableStruct_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto;
};
// -------------------------------------------------------------------

class LogicalCondition PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.simulation.LogicalCondition) */ {
 public:
  inline LogicalCondition() : LogicalCondition(nullptr) {}
  virtual ~LogicalCondition();

  LogicalCondition(const LogicalCondition& from);
  LogicalCondition(LogicalCondition&& from) noexcept
    : LogicalCondition() {
    *this = ::std::move(from);
  }

  inline LogicalCondition& operator=(const LogicalCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogicalCondition& operator=(LogicalCondition&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LogicalCondition& default_instance();

  static inline const LogicalCondition* internal_default_instance() {
    return reinterpret_cast<const LogicalCondition*>(
               &_LogicalCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(LogicalCondition& a, LogicalCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(LogicalCondition* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogicalCondition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LogicalCondition* New() const final {
    return CreateMaybeMessage<LogicalCondition>(nullptr);
  }

  LogicalCondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LogicalCondition>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LogicalCondition& from);
  void MergeFrom(const LogicalCondition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogicalCondition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.simulation.LogicalCondition";
  }
  protected:
  explicit LogicalCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto);
    return ::descriptor_table_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef LogicalCondition_OperatorType OperatorType;
  static constexpr OperatorType UNKNOWN =
    LogicalCondition_OperatorType_UNKNOWN;
  static constexpr OperatorType NOT =
    LogicalCondition_OperatorType_NOT;
  static constexpr OperatorType AND =
    LogicalCondition_OperatorType_AND;
  static constexpr OperatorType OR =
    LogicalCondition_OperatorType_OR;
  static constexpr OperatorType IMPLY =
    LogicalCondition_OperatorType_IMPLY;
  static constexpr OperatorType XOR =
    LogicalCondition_OperatorType_XOR;
  static inline bool OperatorType_IsValid(int value) {
    return LogicalCondition_OperatorType_IsValid(value);
  }
  static constexpr OperatorType OperatorType_MIN =
    LogicalCondition_OperatorType_OperatorType_MIN;
  static constexpr OperatorType OperatorType_MAX =
    LogicalCondition_OperatorType_OperatorType_MAX;
  static constexpr int OperatorType_ARRAYSIZE =
    LogicalCondition_OperatorType_OperatorType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  OperatorType_descriptor() {
    return LogicalCondition_OperatorType_descriptor();
  }
  template<typename T>
  static inline const std::string& OperatorType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, OperatorType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function OperatorType_Name.");
    return LogicalCondition_OperatorType_Name(enum_t_value);
  }
  static inline bool OperatorType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      OperatorType* value) {
    return LogicalCondition_OperatorType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSubConditionFieldNumber = 2,
    kOperatorTypeFieldNumber = 1,
  };
  // repeated .apollo.simulation.Condition sub_condition = 2;
  int sub_condition_size() const;
  private:
  int _internal_sub_condition_size() const;
  public:
  void clear_sub_condition();
  ::apollo::simulation::Condition* mutable_sub_condition(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::simulation::Condition >*
      mutable_sub_condition();
  private:
  const ::apollo::simulation::Condition& _internal_sub_condition(int index) const;
  ::apollo::simulation::Condition* _internal_add_sub_condition();
  public:
  const ::apollo::simulation::Condition& sub_condition(int index) const;
  ::apollo::simulation::Condition* add_sub_condition();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::simulation::Condition >&
      sub_condition() const;

  // optional .apollo.simulation.LogicalCondition.OperatorType operator_type = 1;
  bool has_operator_type() const;
  private:
  bool _internal_has_operator_type() const;
  public:
  void clear_operator_type();
  ::apollo::simulation::LogicalCondition_OperatorType operator_type() const;
  void set_operator_type(::apollo::simulation::LogicalCondition_OperatorType value);
  private:
  ::apollo::simulation::LogicalCondition_OperatorType _internal_operator_type() const;
  void _internal_set_operator_type(::apollo::simulation::LogicalCondition_OperatorType value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.simulation.LogicalCondition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::simulation::Condition > sub_condition_;
  int operator_type_;
  friend struct ::TableStruct_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto;
};
// -------------------------------------------------------------------

class SpeedCondition PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.simulation.SpeedCondition) */ {
 public:
  inline SpeedCondition() : SpeedCondition(nullptr) {}
  virtual ~SpeedCondition();

  SpeedCondition(const SpeedCondition& from);
  SpeedCondition(SpeedCondition&& from) noexcept
    : SpeedCondition() {
    *this = ::std::move(from);
  }

  inline SpeedCondition& operator=(const SpeedCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpeedCondition& operator=(SpeedCondition&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SpeedCondition& default_instance();

  static inline const SpeedCondition* internal_default_instance() {
    return reinterpret_cast<const SpeedCondition*>(
               &_SpeedCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SpeedCondition& a, SpeedCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(SpeedCondition* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpeedCondition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SpeedCondition* New() const final {
    return CreateMaybeMessage<SpeedCondition>(nullptr);
  }

  SpeedCondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SpeedCondition>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SpeedCondition& from);
  void MergeFrom(const SpeedCondition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpeedCondition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.simulation.SpeedCondition";
  }
  protected:
  explicit SpeedCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto);
    return ::descriptor_table_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kUseScoreFieldNumber = 4,
    kMinSpeedFieldNumber = 2,
    kMaxSpeedFieldNumber = 3,
    kSingleDeductionFieldNumber = 5,
  };
  // optional string name = 1 [default = "speed"];
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional bool use_score = 4 [default = false];
  bool has_use_score() const;
  private:
  bool _internal_has_use_score() const;
  public:
  void clear_use_score();
  bool use_score() const;
  void set_use_score(bool value);
  private:
  bool _internal_use_score() const;
  void _internal_set_use_score(bool value);
  public:

  // optional double min_speed = 2 [default = -0.5];
  bool has_min_speed() const;
  private:
  bool _internal_has_min_speed() const;
  public:
  void clear_min_speed();
  double min_speed() const;
  void set_min_speed(double value);
  private:
  double _internal_min_speed() const;
  void _internal_set_min_speed(double value);
  public:

  // optional double max_speed = 3 [default = 1000];
  bool has_max_speed() const;
  private:
  bool _internal_has_max_speed() const;
  public:
  void clear_max_speed();
  double max_speed() const;
  void set_max_speed(double value);
  private:
  double _internal_max_speed() const;
  void _internal_set_max_speed(double value);
  public:

  // optional double single_deduction = 5 [default = 0.5];
  bool has_single_deduction() const;
  private:
  bool _internal_has_single_deduction() const;
  public:
  void clear_single_deduction();
  double single_deduction() const;
  void set_single_deduction(double value);
  private:
  double _internal_single_deduction() const;
  void _internal_set_single_deduction(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.simulation.SpeedCondition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  static const ::PROTOBUF_NAMESPACE_ID::internal::LazyString _i_give_permission_to_break_this_code_default_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  bool use_score_;
  double min_speed_;
  double max_speed_;
  double single_deduction_;
  friend struct ::TableStruct_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto;
};
// -------------------------------------------------------------------

class CentripetalAccelerationCondition PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.simulation.CentripetalAccelerationCondition) */ {
 public:
  inline CentripetalAccelerationCondition() : CentripetalAccelerationCondition(nullptr) {}
  virtual ~CentripetalAccelerationCondition();

  CentripetalAccelerationCondition(const CentripetalAccelerationCondition& from);
  CentripetalAccelerationCondition(CentripetalAccelerationCondition&& from) noexcept
    : CentripetalAccelerationCondition() {
    *this = ::std::move(from);
  }

  inline CentripetalAccelerationCondition& operator=(const CentripetalAccelerationCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline CentripetalAccelerationCondition& operator=(CentripetalAccelerationCondition&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CentripetalAccelerationCondition& default_instance();

  static inline const CentripetalAccelerationCondition* internal_default_instance() {
    return reinterpret_cast<const CentripetalAccelerationCondition*>(
               &_CentripetalAccelerationCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CentripetalAccelerationCondition& a, CentripetalAccelerationCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(CentripetalAccelerationCondition* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CentripetalAccelerationCondition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CentripetalAccelerationCondition* New() const final {
    return CreateMaybeMessage<CentripetalAccelerationCondition>(nullptr);
  }

  CentripetalAccelerationCondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CentripetalAccelerationCondition>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CentripetalAccelerationCondition& from);
  void MergeFrom(const CentripetalAccelerationCondition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CentripetalAccelerationCondition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.simulation.CentripetalAccelerationCondition";
  }
  protected:
  explicit CentripetalAccelerationCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto);
    return ::descriptor_table_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kUseScoreFieldNumber = 3,
    kMaxCentripetalAccelerationFieldNumber = 2,
    kSingleDeductionFieldNumber = 4,
  };
  // optional string name = 1 [default = "centripetal_acceleration"];
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional bool use_score = 3 [default = false];
  bool has_use_score() const;
  private:
  bool _internal_has_use_score() const;
  public:
  void clear_use_score();
  bool use_score() const;
  void set_use_score(bool value);
  private:
  bool _internal_use_score() const;
  void _internal_set_use_score(bool value);
  public:

  // optional double max_centripetal_acceleration = 2 [default = 2];
  bool has_max_centripetal_acceleration() const;
  private:
  bool _internal_has_max_centripetal_acceleration() const;
  public:
  void clear_max_centripetal_acceleration();
  double max_centripetal_acceleration() const;
  void set_max_centripetal_acceleration(double value);
  private:
  double _internal_max_centripetal_acceleration() const;
  void _internal_set_max_centripetal_acceleration(double value);
  public:

  // optional double single_deduction = 4 [default = 0.5];
  bool has_single_deduction() const;
  private:
  bool _internal_has_single_deduction() const;
  public:
  void clear_single_deduction();
  double single_deduction() const;
  void set_single_deduction(double value);
  private:
  double _internal_single_deduction() const;
  void _internal_set_single_deduction(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.simulation.CentripetalAccelerationCondition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  static const ::PROTOBUF_NAMESPACE_ID::internal::LazyString _i_give_permission_to_break_this_code_default_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  bool use_score_;
  double max_centripetal_acceleration_;
  double single_deduction_;
  friend struct ::TableStruct_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto;
};
// -------------------------------------------------------------------

class AccelerationCondition PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.simulation.AccelerationCondition) */ {
 public:
  inline AccelerationCondition() : AccelerationCondition(nullptr) {}
  virtual ~AccelerationCondition();

  AccelerationCondition(const AccelerationCondition& from);
  AccelerationCondition(AccelerationCondition&& from) noexcept
    : AccelerationCondition() {
    *this = ::std::move(from);
  }

  inline AccelerationCondition& operator=(const AccelerationCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccelerationCondition& operator=(AccelerationCondition&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AccelerationCondition& default_instance();

  static inline const AccelerationCondition* internal_default_instance() {
    return reinterpret_cast<const AccelerationCondition*>(
               &_AccelerationCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(AccelerationCondition& a, AccelerationCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(AccelerationCondition* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AccelerationCondition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AccelerationCondition* New() const final {
    return CreateMaybeMessage<AccelerationCondition>(nullptr);
  }

  AccelerationCondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AccelerationCondition>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AccelerationCondition& from);
  void MergeFrom(const AccelerationCondition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccelerationCondition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.simulation.AccelerationCondition";
  }
  protected:
  explicit AccelerationCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto);
    return ::descriptor_table_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kUseScoreFieldNumber = 4,
    kMinAccelerationFieldNumber = 2,
    kMaxAccelerationFieldNumber = 3,
    kSingleDeductionFieldNumber = 5,
  };
  // optional string name = 1 [default = "acceleration"];
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional bool use_score = 4 [default = false];
  bool has_use_score() const;
  private:
  bool _internal_has_use_score() const;
  public:
  void clear_use_score();
  bool use_score() const;
  void set_use_score(bool value);
  private:
  bool _internal_use_score() const;
  void _internal_set_use_score(bool value);
  public:

  // optional double min_acceleration = 2 [default = -1000];
  bool has_min_acceleration() const;
  private:
  bool _internal_has_min_acceleration() const;
  public:
  void clear_min_acceleration();
  double min_acceleration() const;
  void set_min_acceleration(double value);
  private:
  double _internal_min_acceleration() const;
  void _internal_set_min_acceleration(double value);
  public:

  // optional double max_acceleration = 3 [default = 1000];
  bool has_max_acceleration() const;
  private:
  bool _internal_has_max_acceleration() const;
  public:
  void clear_max_acceleration();
  double max_acceleration() const;
  void set_max_acceleration(double value);
  private:
  double _internal_max_acceleration() const;
  void _internal_set_max_acceleration(double value);
  public:

  // optional double single_deduction = 5 [default = 0.5];
  bool has_single_deduction() const;
  private:
  bool _internal_has_single_deduction() const;
  public:
  void clear_single_deduction();
  double single_deduction() const;
  void set_single_deduction(double value);
  private:
  double _internal_single_deduction() const;
  void _internal_set_single_deduction(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.simulation.AccelerationCondition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  static const ::PROTOBUF_NAMESPACE_ID::internal::LazyString _i_give_permission_to_break_this_code_default_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  bool use_score_;
  double min_acceleration_;
  double max_acceleration_;
  double single_deduction_;
  friend struct ::TableStruct_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto;
};
// -------------------------------------------------------------------

class JerkCondition PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.simulation.JerkCondition) */ {
 public:
  inline JerkCondition() : JerkCondition(nullptr) {}
  virtual ~JerkCondition();

  JerkCondition(const JerkCondition& from);
  JerkCondition(JerkCondition&& from) noexcept
    : JerkCondition() {
    *this = ::std::move(from);
  }

  inline JerkCondition& operator=(const JerkCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline JerkCondition& operator=(JerkCondition&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const JerkCondition& default_instance();

  static inline const JerkCondition* internal_default_instance() {
    return reinterpret_cast<const JerkCondition*>(
               &_JerkCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(JerkCondition& a, JerkCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(JerkCondition* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JerkCondition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline JerkCondition* New() const final {
    return CreateMaybeMessage<JerkCondition>(nullptr);
  }

  JerkCondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<JerkCondition>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const JerkCondition& from);
  void MergeFrom(const JerkCondition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JerkCondition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.simulation.JerkCondition";
  }
  protected:
  explicit JerkCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto);
    return ::descriptor_table_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kMinJerkFieldNumber = 2,
    kMaxJerkFieldNumber = 3,
  };
  // optional string name = 1 [default = "jerk"];
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional double min_jerk = 2 [default = -1000];
  bool has_min_jerk() const;
  private:
  bool _internal_has_min_jerk() const;
  public:
  void clear_min_jerk();
  double min_jerk() const;
  void set_min_jerk(double value);
  private:
  double _internal_min_jerk() const;
  void _internal_set_min_jerk(double value);
  public:

  // optional double max_jerk = 3 [default = 1000];
  bool has_max_jerk() const;
  private:
  bool _internal_has_max_jerk() const;
  public:
  void clear_max_jerk();
  double max_jerk() const;
  void set_max_jerk(double value);
  private:
  double _internal_max_jerk() const;
  void _internal_set_max_jerk(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.simulation.JerkCondition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  static const ::PROTOBUF_NAMESPACE_ID::internal::LazyString _i_give_permission_to_break_this_code_default_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  double min_jerk_;
  double max_jerk_;
  friend struct ::TableStruct_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto;
};
// -------------------------------------------------------------------

class SpinCondition PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.simulation.SpinCondition) */ {
 public:
  inline SpinCondition() : SpinCondition(nullptr) {}
  virtual ~SpinCondition();

  SpinCondition(const SpinCondition& from);
  SpinCondition(SpinCondition&& from) noexcept
    : SpinCondition() {
    *this = ::std::move(from);
  }

  inline SpinCondition& operator=(const SpinCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpinCondition& operator=(SpinCondition&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SpinCondition& default_instance();

  static inline const SpinCondition* internal_default_instance() {
    return reinterpret_cast<const SpinCondition*>(
               &_SpinCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SpinCondition& a, SpinCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(SpinCondition* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpinCondition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SpinCondition* New() const final {
    return CreateMaybeMessage<SpinCondition>(nullptr);
  }

  SpinCondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SpinCondition>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SpinCondition& from);
  void MergeFrom(const SpinCondition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpinCondition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.simulation.SpinCondition";
  }
  protected:
  explicit SpinCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto);
    return ::descriptor_table_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kMinSpinFieldNumber = 2,
    kMaxSpinFieldNumber = 3,
  };
  // optional string name = 1 [default = "spin"];
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional double min_spin = 2 [default = -1000];
  bool has_min_spin() const;
  private:
  bool _internal_has_min_spin() const;
  public:
  void clear_min_spin();
  double min_spin() const;
  void set_min_spin(double value);
  private:
  double _internal_min_spin() const;
  void _internal_set_min_spin(double value);
  public:

  // optional double max_spin = 3 [default = 1000];
  bool has_max_spin() const;
  private:
  bool _internal_has_max_spin() const;
  public:
  void clear_max_spin();
  double max_spin() const;
  void set_max_spin(double value);
  private:
  double _internal_max_spin() const;
  void _internal_set_max_spin(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.simulation.SpinCondition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  static const ::PROTOBUF_NAMESPACE_ID::internal::LazyString _i_give_permission_to_break_this_code_default_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  double min_spin_;
  double max_spin_;
  friend struct ::TableStruct_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto;
};
// -------------------------------------------------------------------

class ObjectOverlapCondition PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.simulation.ObjectOverlapCondition) */ {
 public:
  inline ObjectOverlapCondition() : ObjectOverlapCondition(nullptr) {}
  virtual ~ObjectOverlapCondition();

  ObjectOverlapCondition(const ObjectOverlapCondition& from);
  ObjectOverlapCondition(ObjectOverlapCondition&& from) noexcept
    : ObjectOverlapCondition() {
    *this = ::std::move(from);
  }

  inline ObjectOverlapCondition& operator=(const ObjectOverlapCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectOverlapCondition& operator=(ObjectOverlapCondition&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ObjectOverlapCondition& default_instance();

  static inline const ObjectOverlapCondition* internal_default_instance() {
    return reinterpret_cast<const ObjectOverlapCondition*>(
               &_ObjectOverlapCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ObjectOverlapCondition& a, ObjectOverlapCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(ObjectOverlapCondition* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectOverlapCondition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ObjectOverlapCondition* New() const final {
    return CreateMaybeMessage<ObjectOverlapCondition>(nullptr);
  }

  ObjectOverlapCondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ObjectOverlapCondition>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ObjectOverlapCondition& from);
  void MergeFrom(const ObjectOverlapCondition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectOverlapCondition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.simulation.ObjectOverlapCondition";
  }
  protected:
  explicit ObjectOverlapCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto);
    return ::descriptor_table_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ObjectOverlapCondition_DirectionType DirectionType;
  static constexpr DirectionType EXCLUDE_BACK =
    ObjectOverlapCondition_DirectionType_EXCLUDE_BACK;
  static constexpr DirectionType INCLUDE_BACK =
    ObjectOverlapCondition_DirectionType_INCLUDE_BACK;
  static inline bool DirectionType_IsValid(int value) {
    return ObjectOverlapCondition_DirectionType_IsValid(value);
  }
  static constexpr DirectionType DirectionType_MIN =
    ObjectOverlapCondition_DirectionType_DirectionType_MIN;
  static constexpr DirectionType DirectionType_MAX =
    ObjectOverlapCondition_DirectionType_DirectionType_MAX;
  static constexpr int DirectionType_ARRAYSIZE =
    ObjectOverlapCondition_DirectionType_DirectionType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  DirectionType_descriptor() {
    return ObjectOverlapCondition_DirectionType_descriptor();
  }
  template<typename T>
  static inline const std::string& DirectionType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, DirectionType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function DirectionType_Name.");
    return ObjectOverlapCondition_DirectionType_Name(enum_t_value);
  }
  static inline bool DirectionType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      DirectionType* value) {
    return ObjectOverlapCondition_DirectionType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kIgnoreObjectIdsFieldNumber = 5,
    kSourceObjectIdsFieldNumber = 1,
    kTargetObjectIdsFieldNumber = 2,
    kDistanceFieldNumber = 3,
    kDirectionFieldNumber = 4,
    kUseScoreFieldNumber = 6,
  };
  // repeated string ignore_object_ids = 5;
  int ignore_object_ids_size() const;
  private:
  int _internal_ignore_object_ids_size() const;
  public:
  void clear_ignore_object_ids();
  const std::string& ignore_object_ids(int index) const;
  std::string* mutable_ignore_object_ids(int index);
  void set_ignore_object_ids(int index, const std::string& value);
  void set_ignore_object_ids(int index, std::string&& value);
  void set_ignore_object_ids(int index, const char* value);
  void set_ignore_object_ids(int index, const char* value, size_t size);
  std::string* add_ignore_object_ids();
  void add_ignore_object_ids(const std::string& value);
  void add_ignore_object_ids(std::string&& value);
  void add_ignore_object_ids(const char* value);
  void add_ignore_object_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& ignore_object_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_ignore_object_ids();
  private:
  const std::string& _internal_ignore_object_ids(int index) const;
  std::string* _internal_add_ignore_object_ids();
  public:

  // optional string source_object_ids = 1;
  bool has_source_object_ids() const;
  private:
  bool _internal_has_source_object_ids() const;
  public:
  void clear_source_object_ids();
  const std::string& source_object_ids() const;
  void set_source_object_ids(const std::string& value);
  void set_source_object_ids(std::string&& value);
  void set_source_object_ids(const char* value);
  void set_source_object_ids(const char* value, size_t size);
  std::string* mutable_source_object_ids();
  std::string* release_source_object_ids();
  void set_allocated_source_object_ids(std::string* source_object_ids);
  private:
  const std::string& _internal_source_object_ids() const;
  void _internal_set_source_object_ids(const std::string& value);
  std::string* _internal_mutable_source_object_ids();
  public:

  // optional string target_object_ids = 2;
  bool has_target_object_ids() const;
  private:
  bool _internal_has_target_object_ids() const;
  public:
  void clear_target_object_ids();
  const std::string& target_object_ids() const;
  void set_target_object_ids(const std::string& value);
  void set_target_object_ids(std::string&& value);
  void set_target_object_ids(const char* value);
  void set_target_object_ids(const char* value, size_t size);
  std::string* mutable_target_object_ids();
  std::string* release_target_object_ids();
  void set_allocated_target_object_ids(std::string* target_object_ids);
  private:
  const std::string& _internal_target_object_ids() const;
  void _internal_set_target_object_ids(const std::string& value);
  std::string* _internal_mutable_target_object_ids();
  public:

  // optional double distance = 3;
  bool has_distance() const;
  private:
  bool _internal_has_distance() const;
  public:
  void clear_distance();
  double distance() const;
  void set_distance(double value);
  private:
  double _internal_distance() const;
  void _internal_set_distance(double value);
  public:

  // optional .apollo.simulation.ObjectOverlapCondition.DirectionType direction = 4 [default = EXCLUDE_BACK];
  bool has_direction() const;
  private:
  bool _internal_has_direction() const;
  public:
  void clear_direction();
  ::apollo::simulation::ObjectOverlapCondition_DirectionType direction() const;
  void set_direction(::apollo::simulation::ObjectOverlapCondition_DirectionType value);
  private:
  ::apollo::simulation::ObjectOverlapCondition_DirectionType _internal_direction() const;
  void _internal_set_direction(::apollo::simulation::ObjectOverlapCondition_DirectionType value);
  public:

  // optional bool use_score = 6 [default = false];
  bool has_use_score() const;
  private:
  bool _internal_has_use_score() const;
  public:
  void clear_use_score();
  bool use_score() const;
  void set_use_score(bool value);
  private:
  bool _internal_use_score() const;
  void _internal_set_use_score(bool value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.simulation.ObjectOverlapCondition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> ignore_object_ids_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr source_object_ids_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr target_object_ids_;
  double distance_;
  int direction_;
  bool use_score_;
  friend struct ::TableStruct_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto;
};
// -------------------------------------------------------------------

class RegionOverlapCondition PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.simulation.RegionOverlapCondition) */ {
 public:
  inline RegionOverlapCondition() : RegionOverlapCondition(nullptr) {}
  virtual ~RegionOverlapCondition();

  RegionOverlapCondition(const RegionOverlapCondition& from);
  RegionOverlapCondition(RegionOverlapCondition&& from) noexcept
    : RegionOverlapCondition() {
    *this = ::std::move(from);
  }

  inline RegionOverlapCondition& operator=(const RegionOverlapCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegionOverlapCondition& operator=(RegionOverlapCondition&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RegionOverlapCondition& default_instance();

  static inline const RegionOverlapCondition* internal_default_instance() {
    return reinterpret_cast<const RegionOverlapCondition*>(
               &_RegionOverlapCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(RegionOverlapCondition& a, RegionOverlapCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(RegionOverlapCondition* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegionOverlapCondition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RegionOverlapCondition* New() const final {
    return CreateMaybeMessage<RegionOverlapCondition>(nullptr);
  }

  RegionOverlapCondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RegionOverlapCondition>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RegionOverlapCondition& from);
  void MergeFrom(const RegionOverlapCondition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegionOverlapCondition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.simulation.RegionOverlapCondition";
  }
  protected:
  explicit RegionOverlapCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto);
    return ::descriptor_table_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegionCornerXyFieldNumber = 2,
    kObjectIdsFieldNumber = 1,
    kHeadingFieldNumber = 4,
    kRequireFullyContainFieldNumber = 3,
    kUseScoreFieldNumber = 5,
  };
  // repeated double region_corner_xy = 2 [packed = true];
  int region_corner_xy_size() const;
  private:
  int _internal_region_corner_xy_size() const;
  public:
  void clear_region_corner_xy();
  private:
  double _internal_region_corner_xy(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_region_corner_xy() const;
  void _internal_add_region_corner_xy(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_region_corner_xy();
  public:
  double region_corner_xy(int index) const;
  void set_region_corner_xy(int index, double value);
  void add_region_corner_xy(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      region_corner_xy() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_region_corner_xy();

  // optional string object_ids = 1;
  bool has_object_ids() const;
  private:
  bool _internal_has_object_ids() const;
  public:
  void clear_object_ids();
  const std::string& object_ids() const;
  void set_object_ids(const std::string& value);
  void set_object_ids(std::string&& value);
  void set_object_ids(const char* value);
  void set_object_ids(const char* value, size_t size);
  std::string* mutable_object_ids();
  std::string* release_object_ids();
  void set_allocated_object_ids(std::string* object_ids);
  private:
  const std::string& _internal_object_ids() const;
  void _internal_set_object_ids(const std::string& value);
  std::string* _internal_mutable_object_ids();
  public:

  // optional double heading = 4;
  bool has_heading() const;
  private:
  bool _internal_has_heading() const;
  public:
  void clear_heading();
  double heading() const;
  void set_heading(double value);
  private:
  double _internal_heading() const;
  void _internal_set_heading(double value);
  public:

  // optional bool require_fully_contain = 3;
  bool has_require_fully_contain() const;
  private:
  bool _internal_has_require_fully_contain() const;
  public:
  void clear_require_fully_contain();
  bool require_fully_contain() const;
  void set_require_fully_contain(bool value);
  private:
  bool _internal_require_fully_contain() const;
  void _internal_set_require_fully_contain(bool value);
  public:

  // optional bool use_score = 5 [default = false];
  bool has_use_score() const;
  private:
  bool _internal_has_use_score() const;
  public:
  void clear_use_score();
  bool use_score() const;
  void set_use_score(bool value);
  private:
  bool _internal_use_score() const;
  void _internal_set_use_score(bool value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.simulation.RegionOverlapCondition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > region_corner_xy_;
  mutable std::atomic<int> _region_corner_xy_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr object_ids_;
  double heading_;
  bool require_fully_contain_;
  bool use_score_;
  friend struct ::TableStruct_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto;
};
// -------------------------------------------------------------------

class RegionOverlapLWCondition PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.simulation.RegionOverlapLWCondition) */ {
 public:
  inline RegionOverlapLWCondition() : RegionOverlapLWCondition(nullptr) {}
  virtual ~RegionOverlapLWCondition();

  RegionOverlapLWCondition(const RegionOverlapLWCondition& from);
  RegionOverlapLWCondition(RegionOverlapLWCondition&& from) noexcept
    : RegionOverlapLWCondition() {
    *this = ::std::move(from);
  }

  inline RegionOverlapLWCondition& operator=(const RegionOverlapLWCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegionOverlapLWCondition& operator=(RegionOverlapLWCondition&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RegionOverlapLWCondition& default_instance();

  static inline const RegionOverlapLWCondition* internal_default_instance() {
    return reinterpret_cast<const RegionOverlapLWCondition*>(
               &_RegionOverlapLWCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(RegionOverlapLWCondition& a, RegionOverlapLWCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(RegionOverlapLWCondition* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegionOverlapLWCondition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RegionOverlapLWCondition* New() const final {
    return CreateMaybeMessage<RegionOverlapLWCondition>(nullptr);
  }

  RegionOverlapLWCondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RegionOverlapLWCondition>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RegionOverlapLWCondition& from);
  void MergeFrom(const RegionOverlapLWCondition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegionOverlapLWCondition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.simulation.RegionOverlapLWCondition";
  }
  protected:
  explicit RegionOverlapLWCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto);
    return ::descriptor_table_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdsFieldNumber = 1,
    kXFieldNumber = 2,
    kYFieldNumber = 3,
    kLengthFieldNumber = 4,
    kWidthFieldNumber = 5,
    kRequireFullyContainFieldNumber = 6,
    kUseScoreFieldNumber = 7,
  };
  // optional string object_ids = 1;
  bool has_object_ids() const;
  private:
  bool _internal_has_object_ids() const;
  public:
  void clear_object_ids();
  const std::string& object_ids() const;
  void set_object_ids(const std::string& value);
  void set_object_ids(std::string&& value);
  void set_object_ids(const char* value);
  void set_object_ids(const char* value, size_t size);
  std::string* mutable_object_ids();
  std::string* release_object_ids();
  void set_allocated_object_ids(std::string* object_ids);
  private:
  const std::string& _internal_object_ids() const;
  void _internal_set_object_ids(const std::string& value);
  std::string* _internal_mutable_object_ids();
  public:

  // optional double x = 2;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  double x() const;
  void set_x(double value);
  private:
  double _internal_x() const;
  void _internal_set_x(double value);
  public:

  // optional double y = 3;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  double y() const;
  void set_y(double value);
  private:
  double _internal_y() const;
  void _internal_set_y(double value);
  public:

  // optional double length = 4;
  bool has_length() const;
  private:
  bool _internal_has_length() const;
  public:
  void clear_length();
  double length() const;
  void set_length(double value);
  private:
  double _internal_length() const;
  void _internal_set_length(double value);
  public:

  // optional double width = 5;
  bool has_width() const;
  private:
  bool _internal_has_width() const;
  public:
  void clear_width();
  double width() const;
  void set_width(double value);
  private:
  double _internal_width() const;
  void _internal_set_width(double value);
  public:

  // optional bool require_fully_contain = 6;
  bool has_require_fully_contain() const;
  private:
  bool _internal_has_require_fully_contain() const;
  public:
  void clear_require_fully_contain();
  bool require_fully_contain() const;
  void set_require_fully_contain(bool value);
  private:
  bool _internal_require_fully_contain() const;
  void _internal_set_require_fully_contain(bool value);
  public:

  // optional bool use_score = 7 [default = false];
  bool has_use_score() const;
  private:
  bool _internal_has_use_score() const;
  public:
  void clear_use_score();
  bool use_score() const;
  void set_use_score(bool value);
  private:
  bool _internal_use_score() const;
  void _internal_set_use_score(bool value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.simulation.RegionOverlapLWCondition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr object_ids_;
  double x_;
  double y_;
  double length_;
  double width_;
  bool require_fully_contain_;
  bool use_score_;
  friend struct ::TableStruct_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto;
};
// -------------------------------------------------------------------

class OnRoadCondition PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.simulation.OnRoadCondition) */ {
 public:
  inline OnRoadCondition() : OnRoadCondition(nullptr) {}
  virtual ~OnRoadCondition();

  OnRoadCondition(const OnRoadCondition& from);
  OnRoadCondition(OnRoadCondition&& from) noexcept
    : OnRoadCondition() {
    *this = ::std::move(from);
  }

  inline OnRoadCondition& operator=(const OnRoadCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline OnRoadCondition& operator=(OnRoadCondition&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const OnRoadCondition& default_instance();

  static inline const OnRoadCondition* internal_default_instance() {
    return reinterpret_cast<const OnRoadCondition*>(
               &_OnRoadCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(OnRoadCondition& a, OnRoadCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(OnRoadCondition* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OnRoadCondition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OnRoadCondition* New() const final {
    return CreateMaybeMessage<OnRoadCondition>(nullptr);
  }

  OnRoadCondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OnRoadCondition>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const OnRoadCondition& from);
  void MergeFrom(const OnRoadCondition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OnRoadCondition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.simulation.OnRoadCondition";
  }
  protected:
  explicit OnRoadCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto);
    return ::descriptor_table_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUseRoadBoundaryFieldNumber = 1,
    kUseScoreFieldNumber = 2,
  };
  // optional bool use_road_boundary = 1 [default = false];
  bool has_use_road_boundary() const;
  private:
  bool _internal_has_use_road_boundary() const;
  public:
  void clear_use_road_boundary();
  bool use_road_boundary() const;
  void set_use_road_boundary(bool value);
  private:
  bool _internal_use_road_boundary() const;
  void _internal_set_use_road_boundary(bool value);
  public:

  // optional bool use_score = 2 [default = false];
  bool has_use_score() const;
  private:
  bool _internal_has_use_score() const;
  public:
  void clear_use_score();
  bool use_score() const;
  void set_use_score(bool value);
  private:
  bool _internal_use_score() const;
  void _internal_set_use_score(bool value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.simulation.OnRoadCondition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool use_road_boundary_;
  bool use_score_;
  friend struct ::TableStruct_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto;
};
// -------------------------------------------------------------------

class RunRedLightCondition PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.simulation.RunRedLightCondition) */ {
 public:
  inline RunRedLightCondition() : RunRedLightCondition(nullptr) {}
  virtual ~RunRedLightCondition();

  RunRedLightCondition(const RunRedLightCondition& from);
  RunRedLightCondition(RunRedLightCondition&& from) noexcept
    : RunRedLightCondition() {
    *this = ::std::move(from);
  }

  inline RunRedLightCondition& operator=(const RunRedLightCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline RunRedLightCondition& operator=(RunRedLightCondition&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RunRedLightCondition& default_instance();

  static inline const RunRedLightCondition* internal_default_instance() {
    return reinterpret_cast<const RunRedLightCondition*>(
               &_RunRedLightCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(RunRedLightCondition& a, RunRedLightCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(RunRedLightCondition* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RunRedLightCondition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RunRedLightCondition* New() const final {
    return CreateMaybeMessage<RunRedLightCondition>(nullptr);
  }

  RunRedLightCondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RunRedLightCondition>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RunRedLightCondition& from);
  void MergeFrom(const RunRedLightCondition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RunRedLightCondition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.simulation.RunRedLightCondition";
  }
  protected:
  explicit RunRedLightCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto);
    return ::descriptor_table_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUseScoreFieldNumber = 1,
  };
  // optional bool use_score = 1 [default = false];
  bool has_use_score() const;
  private:
  bool _internal_has_use_score() const;
  public:
  void clear_use_score();
  bool use_score() const;
  void set_use_score(bool value);
  private:
  bool _internal_use_score() const;
  void _internal_set_use_score(bool value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.simulation.RunRedLightCondition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool use_score_;
  friend struct ::TableStruct_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto;
};
// -------------------------------------------------------------------

class RedLightStopCondition PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.simulation.RedLightStopCondition) */ {
 public:
  inline RedLightStopCondition() : RedLightStopCondition(nullptr) {}
  virtual ~RedLightStopCondition();

  RedLightStopCondition(const RedLightStopCondition& from);
  RedLightStopCondition(RedLightStopCondition&& from) noexcept
    : RedLightStopCondition() {
    *this = ::std::move(from);
  }

  inline RedLightStopCondition& operator=(const RedLightStopCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline RedLightStopCondition& operator=(RedLightStopCondition&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RedLightStopCondition& default_instance();

  static inline const RedLightStopCondition* internal_default_instance() {
    return reinterpret_cast<const RedLightStopCondition*>(
               &_RedLightStopCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(RedLightStopCondition& a, RedLightStopCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(RedLightStopCondition* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RedLightStopCondition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RedLightStopCondition* New() const final {
    return CreateMaybeMessage<RedLightStopCondition>(nullptr);
  }

  RedLightStopCondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RedLightStopCondition>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RedLightStopCondition& from);
  void MergeFrom(const RedLightStopCondition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RedLightStopCondition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.simulation.RedLightStopCondition";
  }
  protected:
  explicit RedLightStopCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto);
    return ::descriptor_table_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUseScoreFieldNumber = 3,
    kMinDistanceFieldNumber = 1,
    kMaxDistanceFieldNumber = 2,
    kSingleDeductionFieldNumber = 4,
  };
  // optional bool use_score = 3 [default = false];
  bool has_use_score() const;
  private:
  bool _internal_has_use_score() const;
  public:
  void clear_use_score();
  bool use_score() const;
  void set_use_score(bool value);
  private:
  bool _internal_use_score() const;
  void _internal_set_use_score(bool value);
  public:

  // optional double min_distance = 1 [default = 2];
  bool has_min_distance() const;
  private:
  bool _internal_has_min_distance() const;
  public:
  void clear_min_distance();
  double min_distance() const;
  void set_min_distance(double value);
  private:
  double _internal_min_distance() const;
  void _internal_set_min_distance(double value);
  public:

  // optional double max_distance = 2 [default = 2.2];
  bool has_max_distance() const;
  private:
  bool _internal_has_max_distance() const;
  public:
  void clear_max_distance();
  double max_distance() const;
  void set_max_distance(double value);
  private:
  double _internal_max_distance() const;
  void _internal_set_max_distance(double value);
  public:

  // optional double single_deduction = 4 [default = 5];
  bool has_single_deduction() const;
  private:
  bool _internal_has_single_deduction() const;
  public:
  void clear_single_deduction();
  double single_deduction() const;
  void set_single_deduction(double value);
  private:
  double _internal_single_deduction() const;
  void _internal_set_single_deduction(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.simulation.RedLightStopCondition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool use_score_;
  double min_distance_;
  double max_distance_;
  double single_deduction_;
  friend struct ::TableStruct_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto;
};
// -------------------------------------------------------------------

class ChangeLaneAtJunctionCondition PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.simulation.ChangeLaneAtJunctionCondition) */ {
 public:
  inline ChangeLaneAtJunctionCondition() : ChangeLaneAtJunctionCondition(nullptr) {}
  virtual ~ChangeLaneAtJunctionCondition();

  ChangeLaneAtJunctionCondition(const ChangeLaneAtJunctionCondition& from);
  ChangeLaneAtJunctionCondition(ChangeLaneAtJunctionCondition&& from) noexcept
    : ChangeLaneAtJunctionCondition() {
    *this = ::std::move(from);
  }

  inline ChangeLaneAtJunctionCondition& operator=(const ChangeLaneAtJunctionCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangeLaneAtJunctionCondition& operator=(ChangeLaneAtJunctionCondition&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ChangeLaneAtJunctionCondition& default_instance();

  static inline const ChangeLaneAtJunctionCondition* internal_default_instance() {
    return reinterpret_cast<const ChangeLaneAtJunctionCondition*>(
               &_ChangeLaneAtJunctionCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ChangeLaneAtJunctionCondition& a, ChangeLaneAtJunctionCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(ChangeLaneAtJunctionCondition* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChangeLaneAtJunctionCondition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ChangeLaneAtJunctionCondition* New() const final {
    return CreateMaybeMessage<ChangeLaneAtJunctionCondition>(nullptr);
  }

  ChangeLaneAtJunctionCondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ChangeLaneAtJunctionCondition>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ChangeLaneAtJunctionCondition& from);
  void MergeFrom(const ChangeLaneAtJunctionCondition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChangeLaneAtJunctionCondition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.simulation.ChangeLaneAtJunctionCondition";
  }
  protected:
  explicit ChangeLaneAtJunctionCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto);
    return ::descriptor_table_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:apollo.simulation.ChangeLaneAtJunctionCondition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto;
};
// -------------------------------------------------------------------

class RoutingCondition PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.simulation.RoutingCondition) */ {
 public:
  inline RoutingCondition() : RoutingCondition(nullptr) {}
  virtual ~RoutingCondition();

  RoutingCondition(const RoutingCondition& from);
  RoutingCondition(RoutingCondition&& from) noexcept
    : RoutingCondition() {
    *this = ::std::move(from);
  }

  inline RoutingCondition& operator=(const RoutingCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoutingCondition& operator=(RoutingCondition&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RoutingCondition& default_instance();

  static inline const RoutingCondition* internal_default_instance() {
    return reinterpret_cast<const RoutingCondition*>(
               &_RoutingCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(RoutingCondition& a, RoutingCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(RoutingCondition* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoutingCondition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RoutingCondition* New() const final {
    return CreateMaybeMessage<RoutingCondition>(nullptr);
  }

  RoutingCondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RoutingCondition>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RoutingCondition& from);
  void MergeFrom(const RoutingCondition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoutingCondition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.simulation.RoutingCondition";
  }
  protected:
  explicit RoutingCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto);
    return ::descriptor_table_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:apollo.simulation.RoutingCondition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto;
};
// -------------------------------------------------------------------

class CrosswalkYieldCondition PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.simulation.CrosswalkYieldCondition) */ {
 public:
  inline CrosswalkYieldCondition() : CrosswalkYieldCondition(nullptr) {}
  virtual ~CrosswalkYieldCondition();

  CrosswalkYieldCondition(const CrosswalkYieldCondition& from);
  CrosswalkYieldCondition(CrosswalkYieldCondition&& from) noexcept
    : CrosswalkYieldCondition() {
    *this = ::std::move(from);
  }

  inline CrosswalkYieldCondition& operator=(const CrosswalkYieldCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline CrosswalkYieldCondition& operator=(CrosswalkYieldCondition&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CrosswalkYieldCondition& default_instance();

  static inline const CrosswalkYieldCondition* internal_default_instance() {
    return reinterpret_cast<const CrosswalkYieldCondition*>(
               &_CrosswalkYieldCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(CrosswalkYieldCondition& a, CrosswalkYieldCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(CrosswalkYieldCondition* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CrosswalkYieldCondition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CrosswalkYieldCondition* New() const final {
    return CreateMaybeMessage<CrosswalkYieldCondition>(nullptr);
  }

  CrosswalkYieldCondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CrosswalkYieldCondition>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CrosswalkYieldCondition& from);
  void MergeFrom(const CrosswalkYieldCondition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CrosswalkYieldCondition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.simulation.CrosswalkYieldCondition";
  }
  protected:
  explicit CrosswalkYieldCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto);
    return ::descriptor_table_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:apollo.simulation.CrosswalkYieldCondition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto;
};
// -------------------------------------------------------------------

class CrosswalkStopCondition PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.simulation.CrosswalkStopCondition) */ {
 public:
  inline CrosswalkStopCondition() : CrosswalkStopCondition(nullptr) {}
  virtual ~CrosswalkStopCondition();

  CrosswalkStopCondition(const CrosswalkStopCondition& from);
  CrosswalkStopCondition(CrosswalkStopCondition&& from) noexcept
    : CrosswalkStopCondition() {
    *this = ::std::move(from);
  }

  inline CrosswalkStopCondition& operator=(const CrosswalkStopCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline CrosswalkStopCondition& operator=(CrosswalkStopCondition&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CrosswalkStopCondition& default_instance();

  static inline const CrosswalkStopCondition* internal_default_instance() {
    return reinterpret_cast<const CrosswalkStopCondition*>(
               &_CrosswalkStopCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(CrosswalkStopCondition& a, CrosswalkStopCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(CrosswalkStopCondition* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CrosswalkStopCondition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CrosswalkStopCondition* New() const final {
    return CreateMaybeMessage<CrosswalkStopCondition>(nullptr);
  }

  CrosswalkStopCondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CrosswalkStopCondition>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CrosswalkStopCondition& from);
  void MergeFrom(const CrosswalkStopCondition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CrosswalkStopCondition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.simulation.CrosswalkStopCondition";
  }
  protected:
  explicit CrosswalkStopCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto);
    return ::descriptor_table_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUseScoreFieldNumber = 3,
    kMinDistanceFieldNumber = 1,
    kMaxDistanceFieldNumber = 2,
    kSingleDeductionFieldNumber = 4,
  };
  // optional bool use_score = 3 [default = false];
  bool has_use_score() const;
  private:
  bool _internal_has_use_score() const;
  public:
  void clear_use_score();
  bool use_score() const;
  void set_use_score(bool value);
  private:
  bool _internal_use_score() const;
  void _internal_set_use_score(bool value);
  public:

  // optional double min_distance = 1 [default = 2.2];
  bool has_min_distance() const;
  private:
  bool _internal_has_min_distance() const;
  public:
  void clear_min_distance();
  double min_distance() const;
  void set_min_distance(double value);
  private:
  double _internal_min_distance() const;
  void _internal_set_min_distance(double value);
  public:

  // optional double max_distance = 2 [default = 2.7];
  bool has_max_distance() const;
  private:
  bool _internal_has_max_distance() const;
  public:
  void clear_max_distance();
  double max_distance() const;
  void set_max_distance(double value);
  private:
  double _internal_max_distance() const;
  void _internal_set_max_distance(double value);
  public:

  // optional double single_deduction = 4 [default = 5];
  bool has_single_deduction() const;
  private:
  bool _internal_has_single_deduction() const;
  public:
  void clear_single_deduction();
  double single_deduction() const;
  void set_single_deduction(double value);
  private:
  double _internal_single_deduction() const;
  void _internal_set_single_deduction(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.simulation.CrosswalkStopCondition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool use_score_;
  double min_distance_;
  double max_distance_;
  double single_deduction_;
  friend struct ::TableStruct_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto;
};
// -------------------------------------------------------------------

class AbnormalStopCondition PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.simulation.AbnormalStopCondition) */ {
 public:
  inline AbnormalStopCondition() : AbnormalStopCondition(nullptr) {}
  virtual ~AbnormalStopCondition();

  AbnormalStopCondition(const AbnormalStopCondition& from);
  AbnormalStopCondition(AbnormalStopCondition&& from) noexcept
    : AbnormalStopCondition() {
    *this = ::std::move(from);
  }

  inline AbnormalStopCondition& operator=(const AbnormalStopCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline AbnormalStopCondition& operator=(AbnormalStopCondition&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AbnormalStopCondition& default_instance();

  static inline const AbnormalStopCondition* internal_default_instance() {
    return reinterpret_cast<const AbnormalStopCondition*>(
               &_AbnormalStopCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(AbnormalStopCondition& a, AbnormalStopCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(AbnormalStopCondition* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AbnormalStopCondition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AbnormalStopCondition* New() const final {
    return CreateMaybeMessage<AbnormalStopCondition>(nullptr);
  }

  AbnormalStopCondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AbnormalStopCondition>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AbnormalStopCondition& from);
  void MergeFrom(const AbnormalStopCondition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AbnormalStopCondition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.simulation.AbnormalStopCondition";
  }
  protected:
  explicit AbnormalStopCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto);
    return ::descriptor_table_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 3,
    kYFieldNumber = 4,
    kDurationFieldNumber = 1,
    kDistanceFieldNumber = 2,
  };
  // optional double x = 3;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  double x() const;
  void set_x(double value);
  private:
  double _internal_x() const;
  void _internal_set_x(double value);
  public:

  // optional double y = 4;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  double y() const;
  void set_y(double value);
  private:
  double _internal_y() const;
  void _internal_set_y(double value);
  public:

  // optional double duration = 1 [default = 5];
  bool has_duration() const;
  private:
  bool _internal_has_duration() const;
  public:
  void clear_duration();
  double duration() const;
  void set_duration(double value);
  private:
  double _internal_duration() const;
  void _internal_set_duration(double value);
  public:

  // optional double distance = 2 [default = 10];
  bool has_distance() const;
  private:
  bool _internal_has_distance() const;
  public:
  void clear_distance();
  double distance() const;
  void set_distance(double value);
  private:
  double _internal_distance() const;
  void _internal_set_distance(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.simulation.AbnormalStopCondition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double x_;
  double y_;
  double duration_;
  double distance_;
  friend struct ::TableStruct_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto;
};
// -------------------------------------------------------------------

class BrakeTapCondition PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.simulation.BrakeTapCondition) */ {
 public:
  inline BrakeTapCondition() : BrakeTapCondition(nullptr) {}
  virtual ~BrakeTapCondition();

  BrakeTapCondition(const BrakeTapCondition& from);
  BrakeTapCondition(BrakeTapCondition&& from) noexcept
    : BrakeTapCondition() {
    *this = ::std::move(from);
  }

  inline BrakeTapCondition& operator=(const BrakeTapCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline BrakeTapCondition& operator=(BrakeTapCondition&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BrakeTapCondition& default_instance();

  static inline const BrakeTapCondition* internal_default_instance() {
    return reinterpret_cast<const BrakeTapCondition*>(
               &_BrakeTapCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(BrakeTapCondition& a, BrakeTapCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(BrakeTapCondition* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BrakeTapCondition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BrakeTapCondition* New() const final {
    return CreateMaybeMessage<BrakeTapCondition>(nullptr);
  }

  BrakeTapCondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BrakeTapCondition>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BrakeTapCondition& from);
  void MergeFrom(const BrakeTapCondition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BrakeTapCondition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.simulation.BrakeTapCondition";
  }
  protected:
  explicit BrakeTapCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto);
    return ::descriptor_table_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMinDurationFieldNumber = 1,
    kMaxDurationFieldNumber = 2,
  };
  // optional double min_duration = 1 [default = 1];
  bool has_min_duration() const;
  private:
  bool _internal_has_min_duration() const;
  public:
  void clear_min_duration();
  double min_duration() const;
  void set_min_duration(double value);
  private:
  double _internal_min_duration() const;
  void _internal_set_min_duration(double value);
  public:

  // optional double max_duration = 2 [default = 4];
  bool has_max_duration() const;
  private:
  bool _internal_has_max_duration() const;
  public:
  void clear_max_duration();
  double max_duration() const;
  void set_max_duration(double value);
  private:
  double _internal_max_duration() const;
  void _internal_set_max_duration(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.simulation.BrakeTapCondition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double min_duration_;
  double max_duration_;
  friend struct ::TableStruct_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto;
};
// -------------------------------------------------------------------

class RunStopSignCondition PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.simulation.RunStopSignCondition) */ {
 public:
  inline RunStopSignCondition() : RunStopSignCondition(nullptr) {}
  virtual ~RunStopSignCondition();

  RunStopSignCondition(const RunStopSignCondition& from);
  RunStopSignCondition(RunStopSignCondition&& from) noexcept
    : RunStopSignCondition() {
    *this = ::std::move(from);
  }

  inline RunStopSignCondition& operator=(const RunStopSignCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline RunStopSignCondition& operator=(RunStopSignCondition&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RunStopSignCondition& default_instance();

  static inline const RunStopSignCondition* internal_default_instance() {
    return reinterpret_cast<const RunStopSignCondition*>(
               &_RunStopSignCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(RunStopSignCondition& a, RunStopSignCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(RunStopSignCondition* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RunStopSignCondition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RunStopSignCondition* New() const final {
    return CreateMaybeMessage<RunStopSignCondition>(nullptr);
  }

  RunStopSignCondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RunStopSignCondition>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RunStopSignCondition& from);
  void MergeFrom(const RunStopSignCondition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RunStopSignCondition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.simulation.RunStopSignCondition";
  }
  protected:
  explicit RunStopSignCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto);
    return ::descriptor_table_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDistanceFieldNumber = 1,
  };
  // optional double distance = 1 [default = 2];
  bool has_distance() const;
  private:
  bool _internal_has_distance() const;
  public:
  void clear_distance();
  double distance() const;
  void set_distance(double value);
  private:
  double _internal_distance() const;
  void _internal_set_distance(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.simulation.RunStopSignCondition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double distance_;
  friend struct ::TableStruct_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto;
};
// -------------------------------------------------------------------

class CheckpointCondition PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.simulation.CheckpointCondition) */ {
 public:
  inline CheckpointCondition() : CheckpointCondition(nullptr) {}
  virtual ~CheckpointCondition();

  CheckpointCondition(const CheckpointCondition& from);
  CheckpointCondition(CheckpointCondition&& from) noexcept
    : CheckpointCondition() {
    *this = ::std::move(from);
  }

  inline CheckpointCondition& operator=(const CheckpointCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckpointCondition& operator=(CheckpointCondition&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CheckpointCondition& default_instance();

  static inline const CheckpointCondition* internal_default_instance() {
    return reinterpret_cast<const CheckpointCondition*>(
               &_CheckpointCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(CheckpointCondition& a, CheckpointCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(CheckpointCondition* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckpointCondition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CheckpointCondition* New() const final {
    return CreateMaybeMessage<CheckpointCondition>(nullptr);
  }

  CheckpointCondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CheckpointCondition>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CheckpointCondition& from);
  void MergeFrom(const CheckpointCondition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CheckpointCondition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.simulation.CheckpointCondition";
  }
  protected:
  explicit CheckpointCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto);
    return ::descriptor_table_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCheckpointFieldNumber = 1,
  };
  // repeated .apollo.simulation.Condition checkpoint = 1;
  int checkpoint_size() const;
  private:
  int _internal_checkpoint_size() const;
  public:
  void clear_checkpoint();
  ::apollo::simulation::Condition* mutable_checkpoint(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::simulation::Condition >*
      mutable_checkpoint();
  private:
  const ::apollo::simulation::Condition& _internal_checkpoint(int index) const;
  ::apollo::simulation::Condition* _internal_add_checkpoint();
  public:
  const ::apollo::simulation::Condition& checkpoint(int index) const;
  ::apollo::simulation::Condition* add_checkpoint();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::simulation::Condition >&
      checkpoint() const;

  // @@protoc_insertion_point(class_scope:apollo.simulation.CheckpointCondition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::simulation::Condition > checkpoint_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto;
};
// -------------------------------------------------------------------

class DistToEndCondition PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.simulation.DistToEndCondition) */ {
 public:
  inline DistToEndCondition() : DistToEndCondition(nullptr) {}
  virtual ~DistToEndCondition();

  DistToEndCondition(const DistToEndCondition& from);
  DistToEndCondition(DistToEndCondition&& from) noexcept
    : DistToEndCondition() {
    *this = ::std::move(from);
  }

  inline DistToEndCondition& operator=(const DistToEndCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline DistToEndCondition& operator=(DistToEndCondition&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DistToEndCondition& default_instance();

  static inline const DistToEndCondition* internal_default_instance() {
    return reinterpret_cast<const DistToEndCondition*>(
               &_DistToEndCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(DistToEndCondition& a, DistToEndCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(DistToEndCondition* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DistToEndCondition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DistToEndCondition* New() const final {
    return CreateMaybeMessage<DistToEndCondition>(nullptr);
  }

  DistToEndCondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DistToEndCondition>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DistToEndCondition& from);
  void MergeFrom(const DistToEndCondition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DistToEndCondition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.simulation.DistToEndCondition";
  }
  protected:
  explicit DistToEndCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto);
    return ::descriptor_table_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:apollo.simulation.DistToEndCondition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto;
};
// -------------------------------------------------------------------

class DistToLaneCenterCondition PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.simulation.DistToLaneCenterCondition) */ {
 public:
  inline DistToLaneCenterCondition() : DistToLaneCenterCondition(nullptr) {}
  virtual ~DistToLaneCenterCondition();

  DistToLaneCenterCondition(const DistToLaneCenterCondition& from);
  DistToLaneCenterCondition(DistToLaneCenterCondition&& from) noexcept
    : DistToLaneCenterCondition() {
    *this = ::std::move(from);
  }

  inline DistToLaneCenterCondition& operator=(const DistToLaneCenterCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline DistToLaneCenterCondition& operator=(DistToLaneCenterCondition&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DistToLaneCenterCondition& default_instance();

  static inline const DistToLaneCenterCondition* internal_default_instance() {
    return reinterpret_cast<const DistToLaneCenterCondition*>(
               &_DistToLaneCenterCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(DistToLaneCenterCondition& a, DistToLaneCenterCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(DistToLaneCenterCondition* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DistToLaneCenterCondition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DistToLaneCenterCondition* New() const final {
    return CreateMaybeMessage<DistToLaneCenterCondition>(nullptr);
  }

  DistToLaneCenterCondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DistToLaneCenterCondition>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DistToLaneCenterCondition& from);
  void MergeFrom(const DistToLaneCenterCondition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DistToLaneCenterCondition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.simulation.DistToLaneCenterCondition";
  }
  protected:
  explicit DistToLaneCenterCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto);
    return ::descriptor_table_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:apollo.simulation.DistToLaneCenterCondition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto;
};
// -------------------------------------------------------------------

class TimeLimitCondition PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.simulation.TimeLimitCondition) */ {
 public:
  inline TimeLimitCondition() : TimeLimitCondition(nullptr) {}
  virtual ~TimeLimitCondition();

  TimeLimitCondition(const TimeLimitCondition& from);
  TimeLimitCondition(TimeLimitCondition&& from) noexcept
    : TimeLimitCondition() {
    *this = ::std::move(from);
  }

  inline TimeLimitCondition& operator=(const TimeLimitCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline TimeLimitCondition& operator=(TimeLimitCondition&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TimeLimitCondition& default_instance();

  static inline const TimeLimitCondition* internal_default_instance() {
    return reinterpret_cast<const TimeLimitCondition*>(
               &_TimeLimitCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(TimeLimitCondition& a, TimeLimitCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(TimeLimitCondition* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TimeLimitCondition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TimeLimitCondition* New() const final {
    return CreateMaybeMessage<TimeLimitCondition>(nullptr);
  }

  TimeLimitCondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TimeLimitCondition>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TimeLimitCondition& from);
  void MergeFrom(const TimeLimitCondition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TimeLimitCondition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.simulation.TimeLimitCondition";
  }
  protected:
  explicit TimeLimitCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto);
    return ::descriptor_table_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimeoutFieldNumber = 1,
    kUseScoreFieldNumber = 2,
  };
  // optional double timeout = 1;
  bool has_timeout() const;
  private:
  bool _internal_has_timeout() const;
  public:
  void clear_timeout();
  double timeout() const;
  void set_timeout(double value);
  private:
  double _internal_timeout() const;
  void _internal_set_timeout(double value);
  public:

  // optional bool use_score = 2 [default = false];
  bool has_use_score() const;
  private:
  bool _internal_has_use_score() const;
  public:
  void clear_use_score();
  bool use_score() const;
  void set_use_score(bool value);
  private:
  bool _internal_use_score() const;
  void _internal_set_use_score(bool value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.simulation.TimeLimitCondition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double timeout_;
  bool use_score_;
  friend struct ::TableStruct_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto;
};
// -------------------------------------------------------------------

class SpeedbumpLimitCondition PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.simulation.SpeedbumpLimitCondition) */ {
 public:
  inline SpeedbumpLimitCondition() : SpeedbumpLimitCondition(nullptr) {}
  virtual ~SpeedbumpLimitCondition();

  SpeedbumpLimitCondition(const SpeedbumpLimitCondition& from);
  SpeedbumpLimitCondition(SpeedbumpLimitCondition&& from) noexcept
    : SpeedbumpLimitCondition() {
    *this = ::std::move(from);
  }

  inline SpeedbumpLimitCondition& operator=(const SpeedbumpLimitCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpeedbumpLimitCondition& operator=(SpeedbumpLimitCondition&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SpeedbumpLimitCondition& default_instance();

  static inline const SpeedbumpLimitCondition* internal_default_instance() {
    return reinterpret_cast<const SpeedbumpLimitCondition*>(
               &_SpeedbumpLimitCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(SpeedbumpLimitCondition& a, SpeedbumpLimitCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(SpeedbumpLimitCondition* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpeedbumpLimitCondition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SpeedbumpLimitCondition* New() const final {
    return CreateMaybeMessage<SpeedbumpLimitCondition>(nullptr);
  }

  SpeedbumpLimitCondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SpeedbumpLimitCondition>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SpeedbumpLimitCondition& from);
  void MergeFrom(const SpeedbumpLimitCondition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpeedbumpLimitCondition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.simulation.SpeedbumpLimitCondition";
  }
  protected:
  explicit SpeedbumpLimitCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto);
    return ::descriptor_table_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUseScoreFieldNumber = 4,
    kSpeedbumpHalfWidthFieldNumber = 1,
    kMaxSpeedFieldNumber = 2,
    kDeductionSpeedUnitFieldNumber = 3,
    kSingleDeductionFieldNumber = 5,
  };
  // optional bool use_score = 4 [default = false];
  bool has_use_score() const;
  private:
  bool _internal_has_use_score() const;
  public:
  void clear_use_score();
  bool use_score() const;
  void set_use_score(bool value);
  private:
  bool _internal_use_score() const;
  void _internal_set_use_score(bool value);
  public:

  // optional double speedbump_half_width = 1 [default = 0.2];
  bool has_speedbump_half_width() const;
  private:
  bool _internal_has_speedbump_half_width() const;
  public:
  void clear_speedbump_half_width();
  double speedbump_half_width() const;
  void set_speedbump_half_width(double value);
  private:
  double _internal_speedbump_half_width() const;
  void _internal_set_speedbump_half_width(double value);
  public:

  // optional double max_speed = 2 [default = 3];
  bool has_max_speed() const;
  private:
  bool _internal_has_max_speed() const;
  public:
  void clear_max_speed();
  double max_speed() const;
  void set_max_speed(double value);
  private:
  double _internal_max_speed() const;
  void _internal_set_max_speed(double value);
  public:

  // optional double deduction_speed_unit = 3 [default = 1];
  bool has_deduction_speed_unit() const;
  private:
  bool _internal_has_deduction_speed_unit() const;
  public:
  void clear_deduction_speed_unit();
  double deduction_speed_unit() const;
  void set_deduction_speed_unit(double value);
  private:
  double _internal_deduction_speed_unit() const;
  void _internal_set_deduction_speed_unit(double value);
  public:

  // optional double single_deduction = 5 [default = 5];
  bool has_single_deduction() const;
  private:
  bool _internal_has_single_deduction() const;
  public:
  void clear_single_deduction();
  double single_deduction() const;
  void set_single_deduction(double value);
  private:
  double _internal_single_deduction() const;
  void _internal_set_single_deduction(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.simulation.SpeedbumpLimitCondition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool use_score_;
  double speedbump_half_width_;
  double max_speed_;
  double deduction_speed_unit_;
  double single_deduction_;
  friend struct ::TableStruct_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto;
};
// -------------------------------------------------------------------

class WorkingZoneAvoidLimitCondition PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.simulation.WorkingZoneAvoidLimitCondition) */ {
 public:
  inline WorkingZoneAvoidLimitCondition() : WorkingZoneAvoidLimitCondition(nullptr) {}
  virtual ~WorkingZoneAvoidLimitCondition();

  WorkingZoneAvoidLimitCondition(const WorkingZoneAvoidLimitCondition& from);
  WorkingZoneAvoidLimitCondition(WorkingZoneAvoidLimitCondition&& from) noexcept
    : WorkingZoneAvoidLimitCondition() {
    *this = ::std::move(from);
  }

  inline WorkingZoneAvoidLimitCondition& operator=(const WorkingZoneAvoidLimitCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkingZoneAvoidLimitCondition& operator=(WorkingZoneAvoidLimitCondition&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const WorkingZoneAvoidLimitCondition& default_instance();

  static inline const WorkingZoneAvoidLimitCondition* internal_default_instance() {
    return reinterpret_cast<const WorkingZoneAvoidLimitCondition*>(
               &_WorkingZoneAvoidLimitCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(WorkingZoneAvoidLimitCondition& a, WorkingZoneAvoidLimitCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkingZoneAvoidLimitCondition* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkingZoneAvoidLimitCondition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WorkingZoneAvoidLimitCondition* New() const final {
    return CreateMaybeMessage<WorkingZoneAvoidLimitCondition>(nullptr);
  }

  WorkingZoneAvoidLimitCondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WorkingZoneAvoidLimitCondition>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const WorkingZoneAvoidLimitCondition& from);
  void MergeFrom(const WorkingZoneAvoidLimitCondition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkingZoneAvoidLimitCondition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.simulation.WorkingZoneAvoidLimitCondition";
  }
  protected:
  explicit WorkingZoneAvoidLimitCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto);
    return ::descriptor_table_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWorkingZoneFieldNumber = 1,
    kWholeAreaFieldNumber = 3,
    kUseScoreFieldNumber = 4,
    kMaxSpeedFieldNumber = 2,
    kSingleDeductionFieldNumber = 5,
  };
  // repeated .apollo.hdmap.Polygon working_zone = 1;
  int working_zone_size() const;
  private:
  int _internal_working_zone_size() const;
  public:
  void clear_working_zone();
  ::apollo::hdmap::Polygon* mutable_working_zone(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::hdmap::Polygon >*
      mutable_working_zone();
  private:
  const ::apollo::hdmap::Polygon& _internal_working_zone(int index) const;
  ::apollo::hdmap::Polygon* _internal_add_working_zone();
  public:
  const ::apollo::hdmap::Polygon& working_zone(int index) const;
  ::apollo::hdmap::Polygon* add_working_zone();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::hdmap::Polygon >&
      working_zone() const;

  // optional .apollo.hdmap.Polygon whole_area = 3;
  bool has_whole_area() const;
  private:
  bool _internal_has_whole_area() const;
  public:
  void clear_whole_area();
  const ::apollo::hdmap::Polygon& whole_area() const;
  ::apollo::hdmap::Polygon* release_whole_area();
  ::apollo::hdmap::Polygon* mutable_whole_area();
  void set_allocated_whole_area(::apollo::hdmap::Polygon* whole_area);
  private:
  const ::apollo::hdmap::Polygon& _internal_whole_area() const;
  ::apollo::hdmap::Polygon* _internal_mutable_whole_area();
  public:
  void unsafe_arena_set_allocated_whole_area(
      ::apollo::hdmap::Polygon* whole_area);
  ::apollo::hdmap::Polygon* unsafe_arena_release_whole_area();

  // optional bool use_score = 4 [default = false];
  bool has_use_score() const;
  private:
  bool _internal_has_use_score() const;
  public:
  void clear_use_score();
  bool use_score() const;
  void set_use_score(bool value);
  private:
  bool _internal_use_score() const;
  void _internal_set_use_score(bool value);
  public:

  // optional double max_speed = 2 [default = 8.33];
  bool has_max_speed() const;
  private:
  bool _internal_has_max_speed() const;
  public:
  void clear_max_speed();
  double max_speed() const;
  void set_max_speed(double value);
  private:
  double _internal_max_speed() const;
  void _internal_set_max_speed(double value);
  public:

  // optional double single_deduction = 5 [default = 3];
  bool has_single_deduction() const;
  private:
  bool _internal_has_single_deduction() const;
  public:
  void clear_single_deduction();
  double single_deduction() const;
  void set_single_deduction(double value);
  private:
  double _internal_single_deduction() const;
  void _internal_set_single_deduction(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.simulation.WorkingZoneAvoidLimitCondition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::hdmap::Polygon > working_zone_;
  ::apollo::hdmap::Polygon* whole_area_;
  bool use_score_;
  double max_speed_;
  double single_deduction_;
  friend struct ::TableStruct_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto;
};
// -------------------------------------------------------------------

class LimitedTimeParkingCondition PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.simulation.LimitedTimeParkingCondition) */ {
 public:
  inline LimitedTimeParkingCondition() : LimitedTimeParkingCondition(nullptr) {}
  virtual ~LimitedTimeParkingCondition();

  LimitedTimeParkingCondition(const LimitedTimeParkingCondition& from);
  LimitedTimeParkingCondition(LimitedTimeParkingCondition&& from) noexcept
    : LimitedTimeParkingCondition() {
    *this = ::std::move(from);
  }

  inline LimitedTimeParkingCondition& operator=(const LimitedTimeParkingCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline LimitedTimeParkingCondition& operator=(LimitedTimeParkingCondition&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LimitedTimeParkingCondition& default_instance();

  static inline const LimitedTimeParkingCondition* internal_default_instance() {
    return reinterpret_cast<const LimitedTimeParkingCondition*>(
               &_LimitedTimeParkingCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(LimitedTimeParkingCondition& a, LimitedTimeParkingCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(LimitedTimeParkingCondition* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LimitedTimeParkingCondition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LimitedTimeParkingCondition* New() const final {
    return CreateMaybeMessage<LimitedTimeParkingCondition>(nullptr);
  }

  LimitedTimeParkingCondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LimitedTimeParkingCondition>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LimitedTimeParkingCondition& from);
  void MergeFrom(const LimitedTimeParkingCondition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LimitedTimeParkingCondition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.simulation.LimitedTimeParkingCondition";
  }
  protected:
  explicit LimitedTimeParkingCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto);
    return ::descriptor_table_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParkingLotFieldNumber = 1,
    kUseScoreFieldNumber = 2,
    kSingleDeductionFieldNumber = 3,
  };
  // optional .apollo.hdmap.Polygon parking_lot = 1;
  bool has_parking_lot() const;
  private:
  bool _internal_has_parking_lot() const;
  public:
  void clear_parking_lot();
  const ::apollo::hdmap::Polygon& parking_lot() const;
  ::apollo::hdmap::Polygon* release_parking_lot();
  ::apollo::hdmap::Polygon* mutable_parking_lot();
  void set_allocated_parking_lot(::apollo::hdmap::Polygon* parking_lot);
  private:
  const ::apollo::hdmap::Polygon& _internal_parking_lot() const;
  ::apollo::hdmap::Polygon* _internal_mutable_parking_lot();
  public:
  void unsafe_arena_set_allocated_parking_lot(
      ::apollo::hdmap::Polygon* parking_lot);
  ::apollo::hdmap::Polygon* unsafe_arena_release_parking_lot();

  // optional bool use_score = 2 [default = false];
  bool has_use_score() const;
  private:
  bool _internal_has_use_score() const;
  public:
  void clear_use_score();
  bool use_score() const;
  void set_use_score(bool value);
  private:
  bool _internal_use_score() const;
  void _internal_set_use_score(bool value);
  public:

  // optional double single_deduction = 3 [default = 5];
  bool has_single_deduction() const;
  private:
  bool _internal_has_single_deduction() const;
  public:
  void clear_single_deduction();
  double single_deduction() const;
  void set_single_deduction(double value);
  private:
  double _internal_single_deduction() const;
  void _internal_set_single_deduction(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.simulation.LimitedTimeParkingCondition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::apollo::hdmap::Polygon* parking_lot_;
  bool use_score_;
  double single_deduction_;
  friend struct ::TableStruct_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto;
};
// -------------------------------------------------------------------

class FollowAndBypassCondition PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.simulation.FollowAndBypassCondition) */ {
 public:
  inline FollowAndBypassCondition() : FollowAndBypassCondition(nullptr) {}
  virtual ~FollowAndBypassCondition();

  FollowAndBypassCondition(const FollowAndBypassCondition& from);
  FollowAndBypassCondition(FollowAndBypassCondition&& from) noexcept
    : FollowAndBypassCondition() {
    *this = ::std::move(from);
  }

  inline FollowAndBypassCondition& operator=(const FollowAndBypassCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline FollowAndBypassCondition& operator=(FollowAndBypassCondition&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FollowAndBypassCondition& default_instance();

  static inline const FollowAndBypassCondition* internal_default_instance() {
    return reinterpret_cast<const FollowAndBypassCondition*>(
               &_FollowAndBypassCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(FollowAndBypassCondition& a, FollowAndBypassCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(FollowAndBypassCondition* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FollowAndBypassCondition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FollowAndBypassCondition* New() const final {
    return CreateMaybeMessage<FollowAndBypassCondition>(nullptr);
  }

  FollowAndBypassCondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FollowAndBypassCondition>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FollowAndBypassCondition& from);
  void MergeFrom(const FollowAndBypassCondition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FollowAndBypassCondition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.simulation.FollowAndBypassCondition";
  }
  protected:
  explicit FollowAndBypassCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto);
    return ::descriptor_table_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObstacleIdFieldNumber = 3,
    kTestRangeFieldNumber = 1,
    kEndLineFieldNumber = 4,
    kUseScoreFieldNumber = 5,
    kDivideSpeedFieldNumber = 2,
  };
  // optional string obstacle_id = 3;
  bool has_obstacle_id() const;
  private:
  bool _internal_has_obstacle_id() const;
  public:
  void clear_obstacle_id();
  const std::string& obstacle_id() const;
  void set_obstacle_id(const std::string& value);
  void set_obstacle_id(std::string&& value);
  void set_obstacle_id(const char* value);
  void set_obstacle_id(const char* value, size_t size);
  std::string* mutable_obstacle_id();
  std::string* release_obstacle_id();
  void set_allocated_obstacle_id(std::string* obstacle_id);
  private:
  const std::string& _internal_obstacle_id() const;
  void _internal_set_obstacle_id(const std::string& value);
  std::string* _internal_mutable_obstacle_id();
  public:

  // optional .apollo.hdmap.Polygon test_range = 1;
  bool has_test_range() const;
  private:
  bool _internal_has_test_range() const;
  public:
  void clear_test_range();
  const ::apollo::hdmap::Polygon& test_range() const;
  ::apollo::hdmap::Polygon* release_test_range();
  ::apollo::hdmap::Polygon* mutable_test_range();
  void set_allocated_test_range(::apollo::hdmap::Polygon* test_range);
  private:
  const ::apollo::hdmap::Polygon& _internal_test_range() const;
  ::apollo::hdmap::Polygon* _internal_mutable_test_range();
  public:
  void unsafe_arena_set_allocated_test_range(
      ::apollo::hdmap::Polygon* test_range);
  ::apollo::hdmap::Polygon* unsafe_arena_release_test_range();

  // optional .apollo.hdmap.LineSegment end_line = 4;
  bool has_end_line() const;
  private:
  bool _internal_has_end_line() const;
  public:
  void clear_end_line();
  const ::apollo::hdmap::LineSegment& end_line() const;
  ::apollo::hdmap::LineSegment* release_end_line();
  ::apollo::hdmap::LineSegment* mutable_end_line();
  void set_allocated_end_line(::apollo::hdmap::LineSegment* end_line);
  private:
  const ::apollo::hdmap::LineSegment& _internal_end_line() const;
  ::apollo::hdmap::LineSegment* _internal_mutable_end_line();
  public:
  void unsafe_arena_set_allocated_end_line(
      ::apollo::hdmap::LineSegment* end_line);
  ::apollo::hdmap::LineSegment* unsafe_arena_release_end_line();

  // optional bool use_score = 5 [default = false];
  bool has_use_score() const;
  private:
  bool _internal_has_use_score() const;
  public:
  void clear_use_score();
  bool use_score() const;
  void set_use_score(bool value);
  private:
  bool _internal_use_score() const;
  void _internal_set_use_score(bool value);
  public:

  // optional double divide_speed = 2 [default = 3];
  bool has_divide_speed() const;
  private:
  bool _internal_has_divide_speed() const;
  public:
  void clear_divide_speed();
  double divide_speed() const;
  void set_divide_speed(double value);
  private:
  double _internal_divide_speed() const;
  void _internal_set_divide_speed(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.simulation.FollowAndBypassCondition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr obstacle_id_;
  ::apollo::hdmap::Polygon* test_range_;
  ::apollo::hdmap::LineSegment* end_line_;
  bool use_score_;
  double divide_speed_;
  friend struct ::TableStruct_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto;
};
// -------------------------------------------------------------------

class ObstacleBypassCondition PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.simulation.ObstacleBypassCondition) */ {
 public:
  inline ObstacleBypassCondition() : ObstacleBypassCondition(nullptr) {}
  virtual ~ObstacleBypassCondition();

  ObstacleBypassCondition(const ObstacleBypassCondition& from);
  ObstacleBypassCondition(ObstacleBypassCondition&& from) noexcept
    : ObstacleBypassCondition() {
    *this = ::std::move(from);
  }

  inline ObstacleBypassCondition& operator=(const ObstacleBypassCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObstacleBypassCondition& operator=(ObstacleBypassCondition&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ObstacleBypassCondition& default_instance();

  static inline const ObstacleBypassCondition* internal_default_instance() {
    return reinterpret_cast<const ObstacleBypassCondition*>(
               &_ObstacleBypassCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(ObstacleBypassCondition& a, ObstacleBypassCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(ObstacleBypassCondition* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObstacleBypassCondition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ObstacleBypassCondition* New() const final {
    return CreateMaybeMessage<ObstacleBypassCondition>(nullptr);
  }

  ObstacleBypassCondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ObstacleBypassCondition>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ObstacleBypassCondition& from);
  void MergeFrom(const ObstacleBypassCondition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObstacleBypassCondition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.simulation.ObstacleBypassCondition";
  }
  protected:
  explicit ObstacleBypassCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto);
    return ::descriptor_table_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObstacleIdFieldNumber = 2,
    kTestRangeFieldNumber = 1,
    kUseScoreFieldNumber = 5,
    kMinLateralDistanceFieldNumber = 3,
    kMaxSpeedFieldNumber = 4,
    kSingleDeductionFieldNumber = 6,
  };
  // optional string obstacle_id = 2;
  bool has_obstacle_id() const;
  private:
  bool _internal_has_obstacle_id() const;
  public:
  void clear_obstacle_id();
  const std::string& obstacle_id() const;
  void set_obstacle_id(const std::string& value);
  void set_obstacle_id(std::string&& value);
  void set_obstacle_id(const char* value);
  void set_obstacle_id(const char* value, size_t size);
  std::string* mutable_obstacle_id();
  std::string* release_obstacle_id();
  void set_allocated_obstacle_id(std::string* obstacle_id);
  private:
  const std::string& _internal_obstacle_id() const;
  void _internal_set_obstacle_id(const std::string& value);
  std::string* _internal_mutable_obstacle_id();
  public:

  // optional .apollo.hdmap.Polygon test_range = 1;
  bool has_test_range() const;
  private:
  bool _internal_has_test_range() const;
  public:
  void clear_test_range();
  const ::apollo::hdmap::Polygon& test_range() const;
  ::apollo::hdmap::Polygon* release_test_range();
  ::apollo::hdmap::Polygon* mutable_test_range();
  void set_allocated_test_range(::apollo::hdmap::Polygon* test_range);
  private:
  const ::apollo::hdmap::Polygon& _internal_test_range() const;
  ::apollo::hdmap::Polygon* _internal_mutable_test_range();
  public:
  void unsafe_arena_set_allocated_test_range(
      ::apollo::hdmap::Polygon* test_range);
  ::apollo::hdmap::Polygon* unsafe_arena_release_test_range();

  // optional bool use_score = 5 [default = false];
  bool has_use_score() const;
  private:
  bool _internal_has_use_score() const;
  public:
  void clear_use_score();
  bool use_score() const;
  void set_use_score(bool value);
  private:
  bool _internal_use_score() const;
  void _internal_set_use_score(bool value);
  public:

  // optional double min_lateral_distance = 3 [default = 1];
  bool has_min_lateral_distance() const;
  private:
  bool _internal_has_min_lateral_distance() const;
  public:
  void clear_min_lateral_distance();
  double min_lateral_distance() const;
  void set_min_lateral_distance(double value);
  private:
  double _internal_min_lateral_distance() const;
  void _internal_set_min_lateral_distance(double value);
  public:

  // optional double max_speed = 4 [default = 5];
  bool has_max_speed() const;
  private:
  bool _internal_has_max_speed() const;
  public:
  void clear_max_speed();
  double max_speed() const;
  void set_max_speed(double value);
  private:
  double _internal_max_speed() const;
  void _internal_set_max_speed(double value);
  public:

  // optional double single_deduction = 6 [default = 5];
  bool has_single_deduction() const;
  private:
  bool _internal_has_single_deduction() const;
  public:
  void clear_single_deduction();
  double single_deduction() const;
  void set_single_deduction(double value);
  private:
  double _internal_single_deduction() const;
  void _internal_set_single_deduction(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.simulation.ObstacleBypassCondition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr obstacle_id_;
  ::apollo::hdmap::Polygon* test_range_;
  bool use_score_;
  double min_lateral_distance_;
  double max_speed_;
  double single_deduction_;
  friend struct ::TableStruct_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto;
};
// -------------------------------------------------------------------

class AntiCheatingCondition PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.simulation.AntiCheatingCondition) */ {
 public:
  inline AntiCheatingCondition() : AntiCheatingCondition(nullptr) {}
  virtual ~AntiCheatingCondition();

  AntiCheatingCondition(const AntiCheatingCondition& from);
  AntiCheatingCondition(AntiCheatingCondition&& from) noexcept
    : AntiCheatingCondition() {
    *this = ::std::move(from);
  }

  inline AntiCheatingCondition& operator=(const AntiCheatingCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline AntiCheatingCondition& operator=(AntiCheatingCondition&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AntiCheatingCondition& default_instance();

  static inline const AntiCheatingCondition* internal_default_instance() {
    return reinterpret_cast<const AntiCheatingCondition*>(
               &_AntiCheatingCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(AntiCheatingCondition& a, AntiCheatingCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(AntiCheatingCondition* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AntiCheatingCondition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AntiCheatingCondition* New() const final {
    return CreateMaybeMessage<AntiCheatingCondition>(nullptr);
  }

  AntiCheatingCondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AntiCheatingCondition>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AntiCheatingCondition& from);
  void MergeFrom(const AntiCheatingCondition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AntiCheatingCondition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.simulation.AntiCheatingCondition";
  }
  protected:
  explicit AntiCheatingCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto);
    return ::descriptor_table_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUseScoreFieldNumber = 1,
  };
  // optional bool use_score = 1 [default = false];
  bool has_use_score() const;
  private:
  bool _internal_has_use_score() const;
  public:
  void clear_use_score();
  bool use_score() const;
  void set_use_score(bool value);
  private:
  bool _internal_use_score() const;
  void _internal_set_use_score(bool value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.simulation.AntiCheatingCondition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool use_score_;
  friend struct ::TableStruct_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto;
};
// -------------------------------------------------------------------

class KeyPoint PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.simulation.KeyPoint) */ {
 public:
  inline KeyPoint() : KeyPoint(nullptr) {}
  virtual ~KeyPoint();

  KeyPoint(const KeyPoint& from);
  KeyPoint(KeyPoint&& from) noexcept
    : KeyPoint() {
    *this = ::std::move(from);
  }

  inline KeyPoint& operator=(const KeyPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyPoint& operator=(KeyPoint&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const KeyPoint& default_instance();

  static inline const KeyPoint* internal_default_instance() {
    return reinterpret_cast<const KeyPoint*>(
               &_KeyPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(KeyPoint& a, KeyPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(KeyPoint* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyPoint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline KeyPoint* New() const final {
    return CreateMaybeMessage<KeyPoint>(nullptr);
  }

  KeyPoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<KeyPoint>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const KeyPoint& from);
  void MergeFrom(const KeyPoint& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyPoint* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.simulation.KeyPoint";
  }
  protected:
  explicit KeyPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto);
    return ::descriptor_table_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
    kRadiusFieldNumber = 4,
  };
  // optional double x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  double x() const;
  void set_x(double value);
  private:
  double _internal_x() const;
  void _internal_set_x(double value);
  public:

  // optional double y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  double y() const;
  void set_y(double value);
  private:
  double _internal_y() const;
  void _internal_set_y(double value);
  public:

  // optional double z = 3 [default = 0];
  bool has_z() const;
  private:
  bool _internal_has_z() const;
  public:
  void clear_z();
  double z() const;
  void set_z(double value);
  private:
  double _internal_z() const;
  void _internal_set_z(double value);
  public:

  // optional double radius = 4 [default = 2];
  bool has_radius() const;
  private:
  bool _internal_has_radius() const;
  public:
  void clear_radius();
  double radius() const;
  void set_radius(double value);
  private:
  double _internal_radius() const;
  void _internal_set_radius(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.simulation.KeyPoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double x_;
  double y_;
  double z_;
  double radius_;
  friend struct ::TableStruct_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto;
};
// -------------------------------------------------------------------

class KeyPointCondition PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.simulation.KeyPointCondition) */ {
 public:
  inline KeyPointCondition() : KeyPointCondition(nullptr) {}
  virtual ~KeyPointCondition();

  KeyPointCondition(const KeyPointCondition& from);
  KeyPointCondition(KeyPointCondition&& from) noexcept
    : KeyPointCondition() {
    *this = ::std::move(from);
  }

  inline KeyPointCondition& operator=(const KeyPointCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyPointCondition& operator=(KeyPointCondition&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const KeyPointCondition& default_instance();

  static inline const KeyPointCondition* internal_default_instance() {
    return reinterpret_cast<const KeyPointCondition*>(
               &_KeyPointCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(KeyPointCondition& a, KeyPointCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(KeyPointCondition* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyPointCondition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline KeyPointCondition* New() const final {
    return CreateMaybeMessage<KeyPointCondition>(nullptr);
  }

  KeyPointCondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<KeyPointCondition>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const KeyPointCondition& from);
  void MergeFrom(const KeyPointCondition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyPointCondition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.simulation.KeyPointCondition";
  }
  protected:
  explicit KeyPointCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto);
    return ::descriptor_table_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointFieldNumber = 4,
    kUseScoreFieldNumber = 1,
    kInOrderFieldNumber = 2,
    kRadiusFieldNumber = 3,
  };
  // repeated .apollo.simulation.KeyPoint point = 4;
  int point_size() const;
  private:
  int _internal_point_size() const;
  public:
  void clear_point();
  ::apollo::simulation::KeyPoint* mutable_point(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::simulation::KeyPoint >*
      mutable_point();
  private:
  const ::apollo::simulation::KeyPoint& _internal_point(int index) const;
  ::apollo::simulation::KeyPoint* _internal_add_point();
  public:
  const ::apollo::simulation::KeyPoint& point(int index) const;
  ::apollo::simulation::KeyPoint* add_point();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::simulation::KeyPoint >&
      point() const;

  // optional bool use_score = 1 [default = false];
  bool has_use_score() const;
  private:
  bool _internal_has_use_score() const;
  public:
  void clear_use_score();
  bool use_score() const;
  void set_use_score(bool value);
  private:
  bool _internal_use_score() const;
  void _internal_set_use_score(bool value);
  public:

  // optional bool in_order = 2 [default = true];
  bool has_in_order() const;
  private:
  bool _internal_has_in_order() const;
  public:
  void clear_in_order();
  bool in_order() const;
  void set_in_order(bool value);
  private:
  bool _internal_in_order() const;
  void _internal_set_in_order(bool value);
  public:

  // optional double radius = 3 [default = 2];
  bool has_radius() const;
  private:
  bool _internal_has_radius() const;
  public:
  void clear_radius();
  double radius() const;
  void set_radius(double value);
  private:
  double _internal_radius() const;
  void _internal_set_radius(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.simulation.KeyPointCondition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::simulation::KeyPoint > point_;
  bool use_score_;
  bool in_order_;
  double radius_;
  friend struct ::TableStruct_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Condition

// .apollo.simulation.LogicalCondition logical_condition = 1;
inline bool Condition::_internal_has_logical_condition() const {
  return condition_case() == kLogicalCondition;
}
inline bool Condition::has_logical_condition() const {
  return _internal_has_logical_condition();
}
inline void Condition::set_has_logical_condition() {
  _oneof_case_[0] = kLogicalCondition;
}
inline void Condition::clear_logical_condition() {
  if (_internal_has_logical_condition()) {
    if (GetArena() == nullptr) {
      delete condition_.logical_condition_;
    }
    clear_has_condition();
  }
}
inline ::apollo::simulation::LogicalCondition* Condition::release_logical_condition() {
  // @@protoc_insertion_point(field_release:apollo.simulation.Condition.logical_condition)
  if (_internal_has_logical_condition()) {
    clear_has_condition();
      ::apollo::simulation::LogicalCondition* temp = condition_.logical_condition_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    condition_.logical_condition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::simulation::LogicalCondition& Condition::_internal_logical_condition() const {
  return _internal_has_logical_condition()
      ? *condition_.logical_condition_
      : reinterpret_cast< ::apollo::simulation::LogicalCondition&>(::apollo::simulation::_LogicalCondition_default_instance_);
}
inline const ::apollo::simulation::LogicalCondition& Condition::logical_condition() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.Condition.logical_condition)
  return _internal_logical_condition();
}
inline ::apollo::simulation::LogicalCondition* Condition::unsafe_arena_release_logical_condition() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.simulation.Condition.logical_condition)
  if (_internal_has_logical_condition()) {
    clear_has_condition();
    ::apollo::simulation::LogicalCondition* temp = condition_.logical_condition_;
    condition_.logical_condition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_logical_condition(::apollo::simulation::LogicalCondition* logical_condition) {
  clear_condition();
  if (logical_condition) {
    set_has_logical_condition();
    condition_.logical_condition_ = logical_condition;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.simulation.Condition.logical_condition)
}
inline ::apollo::simulation::LogicalCondition* Condition::_internal_mutable_logical_condition() {
  if (!_internal_has_logical_condition()) {
    clear_condition();
    set_has_logical_condition();
    condition_.logical_condition_ = CreateMaybeMessage< ::apollo::simulation::LogicalCondition >(GetArena());
  }
  return condition_.logical_condition_;
}
inline ::apollo::simulation::LogicalCondition* Condition::mutable_logical_condition() {
  // @@protoc_insertion_point(field_mutable:apollo.simulation.Condition.logical_condition)
  return _internal_mutable_logical_condition();
}

// .apollo.simulation.SpeedCondition speed_condition = 2;
inline bool Condition::_internal_has_speed_condition() const {
  return condition_case() == kSpeedCondition;
}
inline bool Condition::has_speed_condition() const {
  return _internal_has_speed_condition();
}
inline void Condition::set_has_speed_condition() {
  _oneof_case_[0] = kSpeedCondition;
}
inline void Condition::clear_speed_condition() {
  if (_internal_has_speed_condition()) {
    if (GetArena() == nullptr) {
      delete condition_.speed_condition_;
    }
    clear_has_condition();
  }
}
inline ::apollo::simulation::SpeedCondition* Condition::release_speed_condition() {
  // @@protoc_insertion_point(field_release:apollo.simulation.Condition.speed_condition)
  if (_internal_has_speed_condition()) {
    clear_has_condition();
      ::apollo::simulation::SpeedCondition* temp = condition_.speed_condition_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    condition_.speed_condition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::simulation::SpeedCondition& Condition::_internal_speed_condition() const {
  return _internal_has_speed_condition()
      ? *condition_.speed_condition_
      : reinterpret_cast< ::apollo::simulation::SpeedCondition&>(::apollo::simulation::_SpeedCondition_default_instance_);
}
inline const ::apollo::simulation::SpeedCondition& Condition::speed_condition() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.Condition.speed_condition)
  return _internal_speed_condition();
}
inline ::apollo::simulation::SpeedCondition* Condition::unsafe_arena_release_speed_condition() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.simulation.Condition.speed_condition)
  if (_internal_has_speed_condition()) {
    clear_has_condition();
    ::apollo::simulation::SpeedCondition* temp = condition_.speed_condition_;
    condition_.speed_condition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_speed_condition(::apollo::simulation::SpeedCondition* speed_condition) {
  clear_condition();
  if (speed_condition) {
    set_has_speed_condition();
    condition_.speed_condition_ = speed_condition;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.simulation.Condition.speed_condition)
}
inline ::apollo::simulation::SpeedCondition* Condition::_internal_mutable_speed_condition() {
  if (!_internal_has_speed_condition()) {
    clear_condition();
    set_has_speed_condition();
    condition_.speed_condition_ = CreateMaybeMessage< ::apollo::simulation::SpeedCondition >(GetArena());
  }
  return condition_.speed_condition_;
}
inline ::apollo::simulation::SpeedCondition* Condition::mutable_speed_condition() {
  // @@protoc_insertion_point(field_mutable:apollo.simulation.Condition.speed_condition)
  return _internal_mutable_speed_condition();
}

// .apollo.simulation.AccelerationCondition acceleration_condition = 3;
inline bool Condition::_internal_has_acceleration_condition() const {
  return condition_case() == kAccelerationCondition;
}
inline bool Condition::has_acceleration_condition() const {
  return _internal_has_acceleration_condition();
}
inline void Condition::set_has_acceleration_condition() {
  _oneof_case_[0] = kAccelerationCondition;
}
inline void Condition::clear_acceleration_condition() {
  if (_internal_has_acceleration_condition()) {
    if (GetArena() == nullptr) {
      delete condition_.acceleration_condition_;
    }
    clear_has_condition();
  }
}
inline ::apollo::simulation::AccelerationCondition* Condition::release_acceleration_condition() {
  // @@protoc_insertion_point(field_release:apollo.simulation.Condition.acceleration_condition)
  if (_internal_has_acceleration_condition()) {
    clear_has_condition();
      ::apollo::simulation::AccelerationCondition* temp = condition_.acceleration_condition_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    condition_.acceleration_condition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::simulation::AccelerationCondition& Condition::_internal_acceleration_condition() const {
  return _internal_has_acceleration_condition()
      ? *condition_.acceleration_condition_
      : reinterpret_cast< ::apollo::simulation::AccelerationCondition&>(::apollo::simulation::_AccelerationCondition_default_instance_);
}
inline const ::apollo::simulation::AccelerationCondition& Condition::acceleration_condition() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.Condition.acceleration_condition)
  return _internal_acceleration_condition();
}
inline ::apollo::simulation::AccelerationCondition* Condition::unsafe_arena_release_acceleration_condition() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.simulation.Condition.acceleration_condition)
  if (_internal_has_acceleration_condition()) {
    clear_has_condition();
    ::apollo::simulation::AccelerationCondition* temp = condition_.acceleration_condition_;
    condition_.acceleration_condition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_acceleration_condition(::apollo::simulation::AccelerationCondition* acceleration_condition) {
  clear_condition();
  if (acceleration_condition) {
    set_has_acceleration_condition();
    condition_.acceleration_condition_ = acceleration_condition;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.simulation.Condition.acceleration_condition)
}
inline ::apollo::simulation::AccelerationCondition* Condition::_internal_mutable_acceleration_condition() {
  if (!_internal_has_acceleration_condition()) {
    clear_condition();
    set_has_acceleration_condition();
    condition_.acceleration_condition_ = CreateMaybeMessage< ::apollo::simulation::AccelerationCondition >(GetArena());
  }
  return condition_.acceleration_condition_;
}
inline ::apollo::simulation::AccelerationCondition* Condition::mutable_acceleration_condition() {
  // @@protoc_insertion_point(field_mutable:apollo.simulation.Condition.acceleration_condition)
  return _internal_mutable_acceleration_condition();
}

// .apollo.simulation.JerkCondition jerk_condition = 4;
inline bool Condition::_internal_has_jerk_condition() const {
  return condition_case() == kJerkCondition;
}
inline bool Condition::has_jerk_condition() const {
  return _internal_has_jerk_condition();
}
inline void Condition::set_has_jerk_condition() {
  _oneof_case_[0] = kJerkCondition;
}
inline void Condition::clear_jerk_condition() {
  if (_internal_has_jerk_condition()) {
    if (GetArena() == nullptr) {
      delete condition_.jerk_condition_;
    }
    clear_has_condition();
  }
}
inline ::apollo::simulation::JerkCondition* Condition::release_jerk_condition() {
  // @@protoc_insertion_point(field_release:apollo.simulation.Condition.jerk_condition)
  if (_internal_has_jerk_condition()) {
    clear_has_condition();
      ::apollo::simulation::JerkCondition* temp = condition_.jerk_condition_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    condition_.jerk_condition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::simulation::JerkCondition& Condition::_internal_jerk_condition() const {
  return _internal_has_jerk_condition()
      ? *condition_.jerk_condition_
      : reinterpret_cast< ::apollo::simulation::JerkCondition&>(::apollo::simulation::_JerkCondition_default_instance_);
}
inline const ::apollo::simulation::JerkCondition& Condition::jerk_condition() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.Condition.jerk_condition)
  return _internal_jerk_condition();
}
inline ::apollo::simulation::JerkCondition* Condition::unsafe_arena_release_jerk_condition() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.simulation.Condition.jerk_condition)
  if (_internal_has_jerk_condition()) {
    clear_has_condition();
    ::apollo::simulation::JerkCondition* temp = condition_.jerk_condition_;
    condition_.jerk_condition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_jerk_condition(::apollo::simulation::JerkCondition* jerk_condition) {
  clear_condition();
  if (jerk_condition) {
    set_has_jerk_condition();
    condition_.jerk_condition_ = jerk_condition;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.simulation.Condition.jerk_condition)
}
inline ::apollo::simulation::JerkCondition* Condition::_internal_mutable_jerk_condition() {
  if (!_internal_has_jerk_condition()) {
    clear_condition();
    set_has_jerk_condition();
    condition_.jerk_condition_ = CreateMaybeMessage< ::apollo::simulation::JerkCondition >(GetArena());
  }
  return condition_.jerk_condition_;
}
inline ::apollo::simulation::JerkCondition* Condition::mutable_jerk_condition() {
  // @@protoc_insertion_point(field_mutable:apollo.simulation.Condition.jerk_condition)
  return _internal_mutable_jerk_condition();
}

// .apollo.simulation.ObjectOverlapCondition object_overlap_condition = 5;
inline bool Condition::_internal_has_object_overlap_condition() const {
  return condition_case() == kObjectOverlapCondition;
}
inline bool Condition::has_object_overlap_condition() const {
  return _internal_has_object_overlap_condition();
}
inline void Condition::set_has_object_overlap_condition() {
  _oneof_case_[0] = kObjectOverlapCondition;
}
inline void Condition::clear_object_overlap_condition() {
  if (_internal_has_object_overlap_condition()) {
    if (GetArena() == nullptr) {
      delete condition_.object_overlap_condition_;
    }
    clear_has_condition();
  }
}
inline ::apollo::simulation::ObjectOverlapCondition* Condition::release_object_overlap_condition() {
  // @@protoc_insertion_point(field_release:apollo.simulation.Condition.object_overlap_condition)
  if (_internal_has_object_overlap_condition()) {
    clear_has_condition();
      ::apollo::simulation::ObjectOverlapCondition* temp = condition_.object_overlap_condition_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    condition_.object_overlap_condition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::simulation::ObjectOverlapCondition& Condition::_internal_object_overlap_condition() const {
  return _internal_has_object_overlap_condition()
      ? *condition_.object_overlap_condition_
      : reinterpret_cast< ::apollo::simulation::ObjectOverlapCondition&>(::apollo::simulation::_ObjectOverlapCondition_default_instance_);
}
inline const ::apollo::simulation::ObjectOverlapCondition& Condition::object_overlap_condition() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.Condition.object_overlap_condition)
  return _internal_object_overlap_condition();
}
inline ::apollo::simulation::ObjectOverlapCondition* Condition::unsafe_arena_release_object_overlap_condition() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.simulation.Condition.object_overlap_condition)
  if (_internal_has_object_overlap_condition()) {
    clear_has_condition();
    ::apollo::simulation::ObjectOverlapCondition* temp = condition_.object_overlap_condition_;
    condition_.object_overlap_condition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_object_overlap_condition(::apollo::simulation::ObjectOverlapCondition* object_overlap_condition) {
  clear_condition();
  if (object_overlap_condition) {
    set_has_object_overlap_condition();
    condition_.object_overlap_condition_ = object_overlap_condition;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.simulation.Condition.object_overlap_condition)
}
inline ::apollo::simulation::ObjectOverlapCondition* Condition::_internal_mutable_object_overlap_condition() {
  if (!_internal_has_object_overlap_condition()) {
    clear_condition();
    set_has_object_overlap_condition();
    condition_.object_overlap_condition_ = CreateMaybeMessage< ::apollo::simulation::ObjectOverlapCondition >(GetArena());
  }
  return condition_.object_overlap_condition_;
}
inline ::apollo::simulation::ObjectOverlapCondition* Condition::mutable_object_overlap_condition() {
  // @@protoc_insertion_point(field_mutable:apollo.simulation.Condition.object_overlap_condition)
  return _internal_mutable_object_overlap_condition();
}

// .apollo.simulation.RegionOverlapCondition region_overlap_condition = 6;
inline bool Condition::_internal_has_region_overlap_condition() const {
  return condition_case() == kRegionOverlapCondition;
}
inline bool Condition::has_region_overlap_condition() const {
  return _internal_has_region_overlap_condition();
}
inline void Condition::set_has_region_overlap_condition() {
  _oneof_case_[0] = kRegionOverlapCondition;
}
inline void Condition::clear_region_overlap_condition() {
  if (_internal_has_region_overlap_condition()) {
    if (GetArena() == nullptr) {
      delete condition_.region_overlap_condition_;
    }
    clear_has_condition();
  }
}
inline ::apollo::simulation::RegionOverlapCondition* Condition::release_region_overlap_condition() {
  // @@protoc_insertion_point(field_release:apollo.simulation.Condition.region_overlap_condition)
  if (_internal_has_region_overlap_condition()) {
    clear_has_condition();
      ::apollo::simulation::RegionOverlapCondition* temp = condition_.region_overlap_condition_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    condition_.region_overlap_condition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::simulation::RegionOverlapCondition& Condition::_internal_region_overlap_condition() const {
  return _internal_has_region_overlap_condition()
      ? *condition_.region_overlap_condition_
      : reinterpret_cast< ::apollo::simulation::RegionOverlapCondition&>(::apollo::simulation::_RegionOverlapCondition_default_instance_);
}
inline const ::apollo::simulation::RegionOverlapCondition& Condition::region_overlap_condition() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.Condition.region_overlap_condition)
  return _internal_region_overlap_condition();
}
inline ::apollo::simulation::RegionOverlapCondition* Condition::unsafe_arena_release_region_overlap_condition() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.simulation.Condition.region_overlap_condition)
  if (_internal_has_region_overlap_condition()) {
    clear_has_condition();
    ::apollo::simulation::RegionOverlapCondition* temp = condition_.region_overlap_condition_;
    condition_.region_overlap_condition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_region_overlap_condition(::apollo::simulation::RegionOverlapCondition* region_overlap_condition) {
  clear_condition();
  if (region_overlap_condition) {
    set_has_region_overlap_condition();
    condition_.region_overlap_condition_ = region_overlap_condition;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.simulation.Condition.region_overlap_condition)
}
inline ::apollo::simulation::RegionOverlapCondition* Condition::_internal_mutable_region_overlap_condition() {
  if (!_internal_has_region_overlap_condition()) {
    clear_condition();
    set_has_region_overlap_condition();
    condition_.region_overlap_condition_ = CreateMaybeMessage< ::apollo::simulation::RegionOverlapCondition >(GetArena());
  }
  return condition_.region_overlap_condition_;
}
inline ::apollo::simulation::RegionOverlapCondition* Condition::mutable_region_overlap_condition() {
  // @@protoc_insertion_point(field_mutable:apollo.simulation.Condition.region_overlap_condition)
  return _internal_mutable_region_overlap_condition();
}

// .apollo.simulation.RegionOverlapLWCondition region_overlap_lw_condition = 7;
inline bool Condition::_internal_has_region_overlap_lw_condition() const {
  return condition_case() == kRegionOverlapLwCondition;
}
inline bool Condition::has_region_overlap_lw_condition() const {
  return _internal_has_region_overlap_lw_condition();
}
inline void Condition::set_has_region_overlap_lw_condition() {
  _oneof_case_[0] = kRegionOverlapLwCondition;
}
inline void Condition::clear_region_overlap_lw_condition() {
  if (_internal_has_region_overlap_lw_condition()) {
    if (GetArena() == nullptr) {
      delete condition_.region_overlap_lw_condition_;
    }
    clear_has_condition();
  }
}
inline ::apollo::simulation::RegionOverlapLWCondition* Condition::release_region_overlap_lw_condition() {
  // @@protoc_insertion_point(field_release:apollo.simulation.Condition.region_overlap_lw_condition)
  if (_internal_has_region_overlap_lw_condition()) {
    clear_has_condition();
      ::apollo::simulation::RegionOverlapLWCondition* temp = condition_.region_overlap_lw_condition_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    condition_.region_overlap_lw_condition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::simulation::RegionOverlapLWCondition& Condition::_internal_region_overlap_lw_condition() const {
  return _internal_has_region_overlap_lw_condition()
      ? *condition_.region_overlap_lw_condition_
      : reinterpret_cast< ::apollo::simulation::RegionOverlapLWCondition&>(::apollo::simulation::_RegionOverlapLWCondition_default_instance_);
}
inline const ::apollo::simulation::RegionOverlapLWCondition& Condition::region_overlap_lw_condition() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.Condition.region_overlap_lw_condition)
  return _internal_region_overlap_lw_condition();
}
inline ::apollo::simulation::RegionOverlapLWCondition* Condition::unsafe_arena_release_region_overlap_lw_condition() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.simulation.Condition.region_overlap_lw_condition)
  if (_internal_has_region_overlap_lw_condition()) {
    clear_has_condition();
    ::apollo::simulation::RegionOverlapLWCondition* temp = condition_.region_overlap_lw_condition_;
    condition_.region_overlap_lw_condition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_region_overlap_lw_condition(::apollo::simulation::RegionOverlapLWCondition* region_overlap_lw_condition) {
  clear_condition();
  if (region_overlap_lw_condition) {
    set_has_region_overlap_lw_condition();
    condition_.region_overlap_lw_condition_ = region_overlap_lw_condition;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.simulation.Condition.region_overlap_lw_condition)
}
inline ::apollo::simulation::RegionOverlapLWCondition* Condition::_internal_mutable_region_overlap_lw_condition() {
  if (!_internal_has_region_overlap_lw_condition()) {
    clear_condition();
    set_has_region_overlap_lw_condition();
    condition_.region_overlap_lw_condition_ = CreateMaybeMessage< ::apollo::simulation::RegionOverlapLWCondition >(GetArena());
  }
  return condition_.region_overlap_lw_condition_;
}
inline ::apollo::simulation::RegionOverlapLWCondition* Condition::mutable_region_overlap_lw_condition() {
  // @@protoc_insertion_point(field_mutable:apollo.simulation.Condition.region_overlap_lw_condition)
  return _internal_mutable_region_overlap_lw_condition();
}

// .apollo.simulation.SpinCondition spin_condition = 8;
inline bool Condition::_internal_has_spin_condition() const {
  return condition_case() == kSpinCondition;
}
inline bool Condition::has_spin_condition() const {
  return _internal_has_spin_condition();
}
inline void Condition::set_has_spin_condition() {
  _oneof_case_[0] = kSpinCondition;
}
inline void Condition::clear_spin_condition() {
  if (_internal_has_spin_condition()) {
    if (GetArena() == nullptr) {
      delete condition_.spin_condition_;
    }
    clear_has_condition();
  }
}
inline ::apollo::simulation::SpinCondition* Condition::release_spin_condition() {
  // @@protoc_insertion_point(field_release:apollo.simulation.Condition.spin_condition)
  if (_internal_has_spin_condition()) {
    clear_has_condition();
      ::apollo::simulation::SpinCondition* temp = condition_.spin_condition_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    condition_.spin_condition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::simulation::SpinCondition& Condition::_internal_spin_condition() const {
  return _internal_has_spin_condition()
      ? *condition_.spin_condition_
      : reinterpret_cast< ::apollo::simulation::SpinCondition&>(::apollo::simulation::_SpinCondition_default_instance_);
}
inline const ::apollo::simulation::SpinCondition& Condition::spin_condition() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.Condition.spin_condition)
  return _internal_spin_condition();
}
inline ::apollo::simulation::SpinCondition* Condition::unsafe_arena_release_spin_condition() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.simulation.Condition.spin_condition)
  if (_internal_has_spin_condition()) {
    clear_has_condition();
    ::apollo::simulation::SpinCondition* temp = condition_.spin_condition_;
    condition_.spin_condition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_spin_condition(::apollo::simulation::SpinCondition* spin_condition) {
  clear_condition();
  if (spin_condition) {
    set_has_spin_condition();
    condition_.spin_condition_ = spin_condition;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.simulation.Condition.spin_condition)
}
inline ::apollo::simulation::SpinCondition* Condition::_internal_mutable_spin_condition() {
  if (!_internal_has_spin_condition()) {
    clear_condition();
    set_has_spin_condition();
    condition_.spin_condition_ = CreateMaybeMessage< ::apollo::simulation::SpinCondition >(GetArena());
  }
  return condition_.spin_condition_;
}
inline ::apollo::simulation::SpinCondition* Condition::mutable_spin_condition() {
  // @@protoc_insertion_point(field_mutable:apollo.simulation.Condition.spin_condition)
  return _internal_mutable_spin_condition();
}

// .apollo.simulation.OnRoadCondition on_road_condition = 9;
inline bool Condition::_internal_has_on_road_condition() const {
  return condition_case() == kOnRoadCondition;
}
inline bool Condition::has_on_road_condition() const {
  return _internal_has_on_road_condition();
}
inline void Condition::set_has_on_road_condition() {
  _oneof_case_[0] = kOnRoadCondition;
}
inline void Condition::clear_on_road_condition() {
  if (_internal_has_on_road_condition()) {
    if (GetArena() == nullptr) {
      delete condition_.on_road_condition_;
    }
    clear_has_condition();
  }
}
inline ::apollo::simulation::OnRoadCondition* Condition::release_on_road_condition() {
  // @@protoc_insertion_point(field_release:apollo.simulation.Condition.on_road_condition)
  if (_internal_has_on_road_condition()) {
    clear_has_condition();
      ::apollo::simulation::OnRoadCondition* temp = condition_.on_road_condition_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    condition_.on_road_condition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::simulation::OnRoadCondition& Condition::_internal_on_road_condition() const {
  return _internal_has_on_road_condition()
      ? *condition_.on_road_condition_
      : reinterpret_cast< ::apollo::simulation::OnRoadCondition&>(::apollo::simulation::_OnRoadCondition_default_instance_);
}
inline const ::apollo::simulation::OnRoadCondition& Condition::on_road_condition() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.Condition.on_road_condition)
  return _internal_on_road_condition();
}
inline ::apollo::simulation::OnRoadCondition* Condition::unsafe_arena_release_on_road_condition() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.simulation.Condition.on_road_condition)
  if (_internal_has_on_road_condition()) {
    clear_has_condition();
    ::apollo::simulation::OnRoadCondition* temp = condition_.on_road_condition_;
    condition_.on_road_condition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_on_road_condition(::apollo::simulation::OnRoadCondition* on_road_condition) {
  clear_condition();
  if (on_road_condition) {
    set_has_on_road_condition();
    condition_.on_road_condition_ = on_road_condition;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.simulation.Condition.on_road_condition)
}
inline ::apollo::simulation::OnRoadCondition* Condition::_internal_mutable_on_road_condition() {
  if (!_internal_has_on_road_condition()) {
    clear_condition();
    set_has_on_road_condition();
    condition_.on_road_condition_ = CreateMaybeMessage< ::apollo::simulation::OnRoadCondition >(GetArena());
  }
  return condition_.on_road_condition_;
}
inline ::apollo::simulation::OnRoadCondition* Condition::mutable_on_road_condition() {
  // @@protoc_insertion_point(field_mutable:apollo.simulation.Condition.on_road_condition)
  return _internal_mutable_on_road_condition();
}

// .apollo.simulation.RunRedLightCondition run_red_light_condition = 10;
inline bool Condition::_internal_has_run_red_light_condition() const {
  return condition_case() == kRunRedLightCondition;
}
inline bool Condition::has_run_red_light_condition() const {
  return _internal_has_run_red_light_condition();
}
inline void Condition::set_has_run_red_light_condition() {
  _oneof_case_[0] = kRunRedLightCondition;
}
inline void Condition::clear_run_red_light_condition() {
  if (_internal_has_run_red_light_condition()) {
    if (GetArena() == nullptr) {
      delete condition_.run_red_light_condition_;
    }
    clear_has_condition();
  }
}
inline ::apollo::simulation::RunRedLightCondition* Condition::release_run_red_light_condition() {
  // @@protoc_insertion_point(field_release:apollo.simulation.Condition.run_red_light_condition)
  if (_internal_has_run_red_light_condition()) {
    clear_has_condition();
      ::apollo::simulation::RunRedLightCondition* temp = condition_.run_red_light_condition_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    condition_.run_red_light_condition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::simulation::RunRedLightCondition& Condition::_internal_run_red_light_condition() const {
  return _internal_has_run_red_light_condition()
      ? *condition_.run_red_light_condition_
      : reinterpret_cast< ::apollo::simulation::RunRedLightCondition&>(::apollo::simulation::_RunRedLightCondition_default_instance_);
}
inline const ::apollo::simulation::RunRedLightCondition& Condition::run_red_light_condition() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.Condition.run_red_light_condition)
  return _internal_run_red_light_condition();
}
inline ::apollo::simulation::RunRedLightCondition* Condition::unsafe_arena_release_run_red_light_condition() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.simulation.Condition.run_red_light_condition)
  if (_internal_has_run_red_light_condition()) {
    clear_has_condition();
    ::apollo::simulation::RunRedLightCondition* temp = condition_.run_red_light_condition_;
    condition_.run_red_light_condition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_run_red_light_condition(::apollo::simulation::RunRedLightCondition* run_red_light_condition) {
  clear_condition();
  if (run_red_light_condition) {
    set_has_run_red_light_condition();
    condition_.run_red_light_condition_ = run_red_light_condition;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.simulation.Condition.run_red_light_condition)
}
inline ::apollo::simulation::RunRedLightCondition* Condition::_internal_mutable_run_red_light_condition() {
  if (!_internal_has_run_red_light_condition()) {
    clear_condition();
    set_has_run_red_light_condition();
    condition_.run_red_light_condition_ = CreateMaybeMessage< ::apollo::simulation::RunRedLightCondition >(GetArena());
  }
  return condition_.run_red_light_condition_;
}
inline ::apollo::simulation::RunRedLightCondition* Condition::mutable_run_red_light_condition() {
  // @@protoc_insertion_point(field_mutable:apollo.simulation.Condition.run_red_light_condition)
  return _internal_mutable_run_red_light_condition();
}

// .apollo.simulation.ChangeLaneAtJunctionCondition change_lane_at_junction_condition = 11;
inline bool Condition::_internal_has_change_lane_at_junction_condition() const {
  return condition_case() == kChangeLaneAtJunctionCondition;
}
inline bool Condition::has_change_lane_at_junction_condition() const {
  return _internal_has_change_lane_at_junction_condition();
}
inline void Condition::set_has_change_lane_at_junction_condition() {
  _oneof_case_[0] = kChangeLaneAtJunctionCondition;
}
inline void Condition::clear_change_lane_at_junction_condition() {
  if (_internal_has_change_lane_at_junction_condition()) {
    if (GetArena() == nullptr) {
      delete condition_.change_lane_at_junction_condition_;
    }
    clear_has_condition();
  }
}
inline ::apollo::simulation::ChangeLaneAtJunctionCondition* Condition::release_change_lane_at_junction_condition() {
  // @@protoc_insertion_point(field_release:apollo.simulation.Condition.change_lane_at_junction_condition)
  if (_internal_has_change_lane_at_junction_condition()) {
    clear_has_condition();
      ::apollo::simulation::ChangeLaneAtJunctionCondition* temp = condition_.change_lane_at_junction_condition_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    condition_.change_lane_at_junction_condition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::simulation::ChangeLaneAtJunctionCondition& Condition::_internal_change_lane_at_junction_condition() const {
  return _internal_has_change_lane_at_junction_condition()
      ? *condition_.change_lane_at_junction_condition_
      : reinterpret_cast< ::apollo::simulation::ChangeLaneAtJunctionCondition&>(::apollo::simulation::_ChangeLaneAtJunctionCondition_default_instance_);
}
inline const ::apollo::simulation::ChangeLaneAtJunctionCondition& Condition::change_lane_at_junction_condition() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.Condition.change_lane_at_junction_condition)
  return _internal_change_lane_at_junction_condition();
}
inline ::apollo::simulation::ChangeLaneAtJunctionCondition* Condition::unsafe_arena_release_change_lane_at_junction_condition() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.simulation.Condition.change_lane_at_junction_condition)
  if (_internal_has_change_lane_at_junction_condition()) {
    clear_has_condition();
    ::apollo::simulation::ChangeLaneAtJunctionCondition* temp = condition_.change_lane_at_junction_condition_;
    condition_.change_lane_at_junction_condition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_change_lane_at_junction_condition(::apollo::simulation::ChangeLaneAtJunctionCondition* change_lane_at_junction_condition) {
  clear_condition();
  if (change_lane_at_junction_condition) {
    set_has_change_lane_at_junction_condition();
    condition_.change_lane_at_junction_condition_ = change_lane_at_junction_condition;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.simulation.Condition.change_lane_at_junction_condition)
}
inline ::apollo::simulation::ChangeLaneAtJunctionCondition* Condition::_internal_mutable_change_lane_at_junction_condition() {
  if (!_internal_has_change_lane_at_junction_condition()) {
    clear_condition();
    set_has_change_lane_at_junction_condition();
    condition_.change_lane_at_junction_condition_ = CreateMaybeMessage< ::apollo::simulation::ChangeLaneAtJunctionCondition >(GetArena());
  }
  return condition_.change_lane_at_junction_condition_;
}
inline ::apollo::simulation::ChangeLaneAtJunctionCondition* Condition::mutable_change_lane_at_junction_condition() {
  // @@protoc_insertion_point(field_mutable:apollo.simulation.Condition.change_lane_at_junction_condition)
  return _internal_mutable_change_lane_at_junction_condition();
}

// .apollo.simulation.RoutingCondition routing_condition = 12;
inline bool Condition::_internal_has_routing_condition() const {
  return condition_case() == kRoutingCondition;
}
inline bool Condition::has_routing_condition() const {
  return _internal_has_routing_condition();
}
inline void Condition::set_has_routing_condition() {
  _oneof_case_[0] = kRoutingCondition;
}
inline void Condition::clear_routing_condition() {
  if (_internal_has_routing_condition()) {
    if (GetArena() == nullptr) {
      delete condition_.routing_condition_;
    }
    clear_has_condition();
  }
}
inline ::apollo::simulation::RoutingCondition* Condition::release_routing_condition() {
  // @@protoc_insertion_point(field_release:apollo.simulation.Condition.routing_condition)
  if (_internal_has_routing_condition()) {
    clear_has_condition();
      ::apollo::simulation::RoutingCondition* temp = condition_.routing_condition_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    condition_.routing_condition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::simulation::RoutingCondition& Condition::_internal_routing_condition() const {
  return _internal_has_routing_condition()
      ? *condition_.routing_condition_
      : reinterpret_cast< ::apollo::simulation::RoutingCondition&>(::apollo::simulation::_RoutingCondition_default_instance_);
}
inline const ::apollo::simulation::RoutingCondition& Condition::routing_condition() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.Condition.routing_condition)
  return _internal_routing_condition();
}
inline ::apollo::simulation::RoutingCondition* Condition::unsafe_arena_release_routing_condition() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.simulation.Condition.routing_condition)
  if (_internal_has_routing_condition()) {
    clear_has_condition();
    ::apollo::simulation::RoutingCondition* temp = condition_.routing_condition_;
    condition_.routing_condition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_routing_condition(::apollo::simulation::RoutingCondition* routing_condition) {
  clear_condition();
  if (routing_condition) {
    set_has_routing_condition();
    condition_.routing_condition_ = routing_condition;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.simulation.Condition.routing_condition)
}
inline ::apollo::simulation::RoutingCondition* Condition::_internal_mutable_routing_condition() {
  if (!_internal_has_routing_condition()) {
    clear_condition();
    set_has_routing_condition();
    condition_.routing_condition_ = CreateMaybeMessage< ::apollo::simulation::RoutingCondition >(GetArena());
  }
  return condition_.routing_condition_;
}
inline ::apollo::simulation::RoutingCondition* Condition::mutable_routing_condition() {
  // @@protoc_insertion_point(field_mutable:apollo.simulation.Condition.routing_condition)
  return _internal_mutable_routing_condition();
}

// .apollo.simulation.CrosswalkYieldCondition crosswalk_yield_condition = 13;
inline bool Condition::_internal_has_crosswalk_yield_condition() const {
  return condition_case() == kCrosswalkYieldCondition;
}
inline bool Condition::has_crosswalk_yield_condition() const {
  return _internal_has_crosswalk_yield_condition();
}
inline void Condition::set_has_crosswalk_yield_condition() {
  _oneof_case_[0] = kCrosswalkYieldCondition;
}
inline void Condition::clear_crosswalk_yield_condition() {
  if (_internal_has_crosswalk_yield_condition()) {
    if (GetArena() == nullptr) {
      delete condition_.crosswalk_yield_condition_;
    }
    clear_has_condition();
  }
}
inline ::apollo::simulation::CrosswalkYieldCondition* Condition::release_crosswalk_yield_condition() {
  // @@protoc_insertion_point(field_release:apollo.simulation.Condition.crosswalk_yield_condition)
  if (_internal_has_crosswalk_yield_condition()) {
    clear_has_condition();
      ::apollo::simulation::CrosswalkYieldCondition* temp = condition_.crosswalk_yield_condition_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    condition_.crosswalk_yield_condition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::simulation::CrosswalkYieldCondition& Condition::_internal_crosswalk_yield_condition() const {
  return _internal_has_crosswalk_yield_condition()
      ? *condition_.crosswalk_yield_condition_
      : reinterpret_cast< ::apollo::simulation::CrosswalkYieldCondition&>(::apollo::simulation::_CrosswalkYieldCondition_default_instance_);
}
inline const ::apollo::simulation::CrosswalkYieldCondition& Condition::crosswalk_yield_condition() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.Condition.crosswalk_yield_condition)
  return _internal_crosswalk_yield_condition();
}
inline ::apollo::simulation::CrosswalkYieldCondition* Condition::unsafe_arena_release_crosswalk_yield_condition() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.simulation.Condition.crosswalk_yield_condition)
  if (_internal_has_crosswalk_yield_condition()) {
    clear_has_condition();
    ::apollo::simulation::CrosswalkYieldCondition* temp = condition_.crosswalk_yield_condition_;
    condition_.crosswalk_yield_condition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_crosswalk_yield_condition(::apollo::simulation::CrosswalkYieldCondition* crosswalk_yield_condition) {
  clear_condition();
  if (crosswalk_yield_condition) {
    set_has_crosswalk_yield_condition();
    condition_.crosswalk_yield_condition_ = crosswalk_yield_condition;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.simulation.Condition.crosswalk_yield_condition)
}
inline ::apollo::simulation::CrosswalkYieldCondition* Condition::_internal_mutable_crosswalk_yield_condition() {
  if (!_internal_has_crosswalk_yield_condition()) {
    clear_condition();
    set_has_crosswalk_yield_condition();
    condition_.crosswalk_yield_condition_ = CreateMaybeMessage< ::apollo::simulation::CrosswalkYieldCondition >(GetArena());
  }
  return condition_.crosswalk_yield_condition_;
}
inline ::apollo::simulation::CrosswalkYieldCondition* Condition::mutable_crosswalk_yield_condition() {
  // @@protoc_insertion_point(field_mutable:apollo.simulation.Condition.crosswalk_yield_condition)
  return _internal_mutable_crosswalk_yield_condition();
}

// .apollo.simulation.AbnormalStopCondition abnormal_stop_condition = 14;
inline bool Condition::_internal_has_abnormal_stop_condition() const {
  return condition_case() == kAbnormalStopCondition;
}
inline bool Condition::has_abnormal_stop_condition() const {
  return _internal_has_abnormal_stop_condition();
}
inline void Condition::set_has_abnormal_stop_condition() {
  _oneof_case_[0] = kAbnormalStopCondition;
}
inline void Condition::clear_abnormal_stop_condition() {
  if (_internal_has_abnormal_stop_condition()) {
    if (GetArena() == nullptr) {
      delete condition_.abnormal_stop_condition_;
    }
    clear_has_condition();
  }
}
inline ::apollo::simulation::AbnormalStopCondition* Condition::release_abnormal_stop_condition() {
  // @@protoc_insertion_point(field_release:apollo.simulation.Condition.abnormal_stop_condition)
  if (_internal_has_abnormal_stop_condition()) {
    clear_has_condition();
      ::apollo::simulation::AbnormalStopCondition* temp = condition_.abnormal_stop_condition_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    condition_.abnormal_stop_condition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::simulation::AbnormalStopCondition& Condition::_internal_abnormal_stop_condition() const {
  return _internal_has_abnormal_stop_condition()
      ? *condition_.abnormal_stop_condition_
      : reinterpret_cast< ::apollo::simulation::AbnormalStopCondition&>(::apollo::simulation::_AbnormalStopCondition_default_instance_);
}
inline const ::apollo::simulation::AbnormalStopCondition& Condition::abnormal_stop_condition() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.Condition.abnormal_stop_condition)
  return _internal_abnormal_stop_condition();
}
inline ::apollo::simulation::AbnormalStopCondition* Condition::unsafe_arena_release_abnormal_stop_condition() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.simulation.Condition.abnormal_stop_condition)
  if (_internal_has_abnormal_stop_condition()) {
    clear_has_condition();
    ::apollo::simulation::AbnormalStopCondition* temp = condition_.abnormal_stop_condition_;
    condition_.abnormal_stop_condition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_abnormal_stop_condition(::apollo::simulation::AbnormalStopCondition* abnormal_stop_condition) {
  clear_condition();
  if (abnormal_stop_condition) {
    set_has_abnormal_stop_condition();
    condition_.abnormal_stop_condition_ = abnormal_stop_condition;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.simulation.Condition.abnormal_stop_condition)
}
inline ::apollo::simulation::AbnormalStopCondition* Condition::_internal_mutable_abnormal_stop_condition() {
  if (!_internal_has_abnormal_stop_condition()) {
    clear_condition();
    set_has_abnormal_stop_condition();
    condition_.abnormal_stop_condition_ = CreateMaybeMessage< ::apollo::simulation::AbnormalStopCondition >(GetArena());
  }
  return condition_.abnormal_stop_condition_;
}
inline ::apollo::simulation::AbnormalStopCondition* Condition::mutable_abnormal_stop_condition() {
  // @@protoc_insertion_point(field_mutable:apollo.simulation.Condition.abnormal_stop_condition)
  return _internal_mutable_abnormal_stop_condition();
}

// .apollo.simulation.BrakeTapCondition brake_tap_condition = 15;
inline bool Condition::_internal_has_brake_tap_condition() const {
  return condition_case() == kBrakeTapCondition;
}
inline bool Condition::has_brake_tap_condition() const {
  return _internal_has_brake_tap_condition();
}
inline void Condition::set_has_brake_tap_condition() {
  _oneof_case_[0] = kBrakeTapCondition;
}
inline void Condition::clear_brake_tap_condition() {
  if (_internal_has_brake_tap_condition()) {
    if (GetArena() == nullptr) {
      delete condition_.brake_tap_condition_;
    }
    clear_has_condition();
  }
}
inline ::apollo::simulation::BrakeTapCondition* Condition::release_brake_tap_condition() {
  // @@protoc_insertion_point(field_release:apollo.simulation.Condition.brake_tap_condition)
  if (_internal_has_brake_tap_condition()) {
    clear_has_condition();
      ::apollo::simulation::BrakeTapCondition* temp = condition_.brake_tap_condition_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    condition_.brake_tap_condition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::simulation::BrakeTapCondition& Condition::_internal_brake_tap_condition() const {
  return _internal_has_brake_tap_condition()
      ? *condition_.brake_tap_condition_
      : reinterpret_cast< ::apollo::simulation::BrakeTapCondition&>(::apollo::simulation::_BrakeTapCondition_default_instance_);
}
inline const ::apollo::simulation::BrakeTapCondition& Condition::brake_tap_condition() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.Condition.brake_tap_condition)
  return _internal_brake_tap_condition();
}
inline ::apollo::simulation::BrakeTapCondition* Condition::unsafe_arena_release_brake_tap_condition() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.simulation.Condition.brake_tap_condition)
  if (_internal_has_brake_tap_condition()) {
    clear_has_condition();
    ::apollo::simulation::BrakeTapCondition* temp = condition_.brake_tap_condition_;
    condition_.brake_tap_condition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_brake_tap_condition(::apollo::simulation::BrakeTapCondition* brake_tap_condition) {
  clear_condition();
  if (brake_tap_condition) {
    set_has_brake_tap_condition();
    condition_.brake_tap_condition_ = brake_tap_condition;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.simulation.Condition.brake_tap_condition)
}
inline ::apollo::simulation::BrakeTapCondition* Condition::_internal_mutable_brake_tap_condition() {
  if (!_internal_has_brake_tap_condition()) {
    clear_condition();
    set_has_brake_tap_condition();
    condition_.brake_tap_condition_ = CreateMaybeMessage< ::apollo::simulation::BrakeTapCondition >(GetArena());
  }
  return condition_.brake_tap_condition_;
}
inline ::apollo::simulation::BrakeTapCondition* Condition::mutable_brake_tap_condition() {
  // @@protoc_insertion_point(field_mutable:apollo.simulation.Condition.brake_tap_condition)
  return _internal_mutable_brake_tap_condition();
}

// .apollo.simulation.RunStopSignCondition run_stop_sign_condition = 16;
inline bool Condition::_internal_has_run_stop_sign_condition() const {
  return condition_case() == kRunStopSignCondition;
}
inline bool Condition::has_run_stop_sign_condition() const {
  return _internal_has_run_stop_sign_condition();
}
inline void Condition::set_has_run_stop_sign_condition() {
  _oneof_case_[0] = kRunStopSignCondition;
}
inline void Condition::clear_run_stop_sign_condition() {
  if (_internal_has_run_stop_sign_condition()) {
    if (GetArena() == nullptr) {
      delete condition_.run_stop_sign_condition_;
    }
    clear_has_condition();
  }
}
inline ::apollo::simulation::RunStopSignCondition* Condition::release_run_stop_sign_condition() {
  // @@protoc_insertion_point(field_release:apollo.simulation.Condition.run_stop_sign_condition)
  if (_internal_has_run_stop_sign_condition()) {
    clear_has_condition();
      ::apollo::simulation::RunStopSignCondition* temp = condition_.run_stop_sign_condition_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    condition_.run_stop_sign_condition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::simulation::RunStopSignCondition& Condition::_internal_run_stop_sign_condition() const {
  return _internal_has_run_stop_sign_condition()
      ? *condition_.run_stop_sign_condition_
      : reinterpret_cast< ::apollo::simulation::RunStopSignCondition&>(::apollo::simulation::_RunStopSignCondition_default_instance_);
}
inline const ::apollo::simulation::RunStopSignCondition& Condition::run_stop_sign_condition() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.Condition.run_stop_sign_condition)
  return _internal_run_stop_sign_condition();
}
inline ::apollo::simulation::RunStopSignCondition* Condition::unsafe_arena_release_run_stop_sign_condition() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.simulation.Condition.run_stop_sign_condition)
  if (_internal_has_run_stop_sign_condition()) {
    clear_has_condition();
    ::apollo::simulation::RunStopSignCondition* temp = condition_.run_stop_sign_condition_;
    condition_.run_stop_sign_condition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_run_stop_sign_condition(::apollo::simulation::RunStopSignCondition* run_stop_sign_condition) {
  clear_condition();
  if (run_stop_sign_condition) {
    set_has_run_stop_sign_condition();
    condition_.run_stop_sign_condition_ = run_stop_sign_condition;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.simulation.Condition.run_stop_sign_condition)
}
inline ::apollo::simulation::RunStopSignCondition* Condition::_internal_mutable_run_stop_sign_condition() {
  if (!_internal_has_run_stop_sign_condition()) {
    clear_condition();
    set_has_run_stop_sign_condition();
    condition_.run_stop_sign_condition_ = CreateMaybeMessage< ::apollo::simulation::RunStopSignCondition >(GetArena());
  }
  return condition_.run_stop_sign_condition_;
}
inline ::apollo::simulation::RunStopSignCondition* Condition::mutable_run_stop_sign_condition() {
  // @@protoc_insertion_point(field_mutable:apollo.simulation.Condition.run_stop_sign_condition)
  return _internal_mutable_run_stop_sign_condition();
}

// .apollo.simulation.CheckpointCondition checkpoint_condition = 17;
inline bool Condition::_internal_has_checkpoint_condition() const {
  return condition_case() == kCheckpointCondition;
}
inline bool Condition::has_checkpoint_condition() const {
  return _internal_has_checkpoint_condition();
}
inline void Condition::set_has_checkpoint_condition() {
  _oneof_case_[0] = kCheckpointCondition;
}
inline void Condition::clear_checkpoint_condition() {
  if (_internal_has_checkpoint_condition()) {
    if (GetArena() == nullptr) {
      delete condition_.checkpoint_condition_;
    }
    clear_has_condition();
  }
}
inline ::apollo::simulation::CheckpointCondition* Condition::release_checkpoint_condition() {
  // @@protoc_insertion_point(field_release:apollo.simulation.Condition.checkpoint_condition)
  if (_internal_has_checkpoint_condition()) {
    clear_has_condition();
      ::apollo::simulation::CheckpointCondition* temp = condition_.checkpoint_condition_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    condition_.checkpoint_condition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::simulation::CheckpointCondition& Condition::_internal_checkpoint_condition() const {
  return _internal_has_checkpoint_condition()
      ? *condition_.checkpoint_condition_
      : reinterpret_cast< ::apollo::simulation::CheckpointCondition&>(::apollo::simulation::_CheckpointCondition_default_instance_);
}
inline const ::apollo::simulation::CheckpointCondition& Condition::checkpoint_condition() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.Condition.checkpoint_condition)
  return _internal_checkpoint_condition();
}
inline ::apollo::simulation::CheckpointCondition* Condition::unsafe_arena_release_checkpoint_condition() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.simulation.Condition.checkpoint_condition)
  if (_internal_has_checkpoint_condition()) {
    clear_has_condition();
    ::apollo::simulation::CheckpointCondition* temp = condition_.checkpoint_condition_;
    condition_.checkpoint_condition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_checkpoint_condition(::apollo::simulation::CheckpointCondition* checkpoint_condition) {
  clear_condition();
  if (checkpoint_condition) {
    set_has_checkpoint_condition();
    condition_.checkpoint_condition_ = checkpoint_condition;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.simulation.Condition.checkpoint_condition)
}
inline ::apollo::simulation::CheckpointCondition* Condition::_internal_mutable_checkpoint_condition() {
  if (!_internal_has_checkpoint_condition()) {
    clear_condition();
    set_has_checkpoint_condition();
    condition_.checkpoint_condition_ = CreateMaybeMessage< ::apollo::simulation::CheckpointCondition >(GetArena());
  }
  return condition_.checkpoint_condition_;
}
inline ::apollo::simulation::CheckpointCondition* Condition::mutable_checkpoint_condition() {
  // @@protoc_insertion_point(field_mutable:apollo.simulation.Condition.checkpoint_condition)
  return _internal_mutable_checkpoint_condition();
}

// .apollo.simulation.DistToEndCondition dist_to_end_condition = 18;
inline bool Condition::_internal_has_dist_to_end_condition() const {
  return condition_case() == kDistToEndCondition;
}
inline bool Condition::has_dist_to_end_condition() const {
  return _internal_has_dist_to_end_condition();
}
inline void Condition::set_has_dist_to_end_condition() {
  _oneof_case_[0] = kDistToEndCondition;
}
inline void Condition::clear_dist_to_end_condition() {
  if (_internal_has_dist_to_end_condition()) {
    if (GetArena() == nullptr) {
      delete condition_.dist_to_end_condition_;
    }
    clear_has_condition();
  }
}
inline ::apollo::simulation::DistToEndCondition* Condition::release_dist_to_end_condition() {
  // @@protoc_insertion_point(field_release:apollo.simulation.Condition.dist_to_end_condition)
  if (_internal_has_dist_to_end_condition()) {
    clear_has_condition();
      ::apollo::simulation::DistToEndCondition* temp = condition_.dist_to_end_condition_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    condition_.dist_to_end_condition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::simulation::DistToEndCondition& Condition::_internal_dist_to_end_condition() const {
  return _internal_has_dist_to_end_condition()
      ? *condition_.dist_to_end_condition_
      : reinterpret_cast< ::apollo::simulation::DistToEndCondition&>(::apollo::simulation::_DistToEndCondition_default_instance_);
}
inline const ::apollo::simulation::DistToEndCondition& Condition::dist_to_end_condition() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.Condition.dist_to_end_condition)
  return _internal_dist_to_end_condition();
}
inline ::apollo::simulation::DistToEndCondition* Condition::unsafe_arena_release_dist_to_end_condition() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.simulation.Condition.dist_to_end_condition)
  if (_internal_has_dist_to_end_condition()) {
    clear_has_condition();
    ::apollo::simulation::DistToEndCondition* temp = condition_.dist_to_end_condition_;
    condition_.dist_to_end_condition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_dist_to_end_condition(::apollo::simulation::DistToEndCondition* dist_to_end_condition) {
  clear_condition();
  if (dist_to_end_condition) {
    set_has_dist_to_end_condition();
    condition_.dist_to_end_condition_ = dist_to_end_condition;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.simulation.Condition.dist_to_end_condition)
}
inline ::apollo::simulation::DistToEndCondition* Condition::_internal_mutable_dist_to_end_condition() {
  if (!_internal_has_dist_to_end_condition()) {
    clear_condition();
    set_has_dist_to_end_condition();
    condition_.dist_to_end_condition_ = CreateMaybeMessage< ::apollo::simulation::DistToEndCondition >(GetArena());
  }
  return condition_.dist_to_end_condition_;
}
inline ::apollo::simulation::DistToEndCondition* Condition::mutable_dist_to_end_condition() {
  // @@protoc_insertion_point(field_mutable:apollo.simulation.Condition.dist_to_end_condition)
  return _internal_mutable_dist_to_end_condition();
}

// .apollo.simulation.DistToLaneCenterCondition dist_to_lane_center_condition = 19;
inline bool Condition::_internal_has_dist_to_lane_center_condition() const {
  return condition_case() == kDistToLaneCenterCondition;
}
inline bool Condition::has_dist_to_lane_center_condition() const {
  return _internal_has_dist_to_lane_center_condition();
}
inline void Condition::set_has_dist_to_lane_center_condition() {
  _oneof_case_[0] = kDistToLaneCenterCondition;
}
inline void Condition::clear_dist_to_lane_center_condition() {
  if (_internal_has_dist_to_lane_center_condition()) {
    if (GetArena() == nullptr) {
      delete condition_.dist_to_lane_center_condition_;
    }
    clear_has_condition();
  }
}
inline ::apollo::simulation::DistToLaneCenterCondition* Condition::release_dist_to_lane_center_condition() {
  // @@protoc_insertion_point(field_release:apollo.simulation.Condition.dist_to_lane_center_condition)
  if (_internal_has_dist_to_lane_center_condition()) {
    clear_has_condition();
      ::apollo::simulation::DistToLaneCenterCondition* temp = condition_.dist_to_lane_center_condition_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    condition_.dist_to_lane_center_condition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::simulation::DistToLaneCenterCondition& Condition::_internal_dist_to_lane_center_condition() const {
  return _internal_has_dist_to_lane_center_condition()
      ? *condition_.dist_to_lane_center_condition_
      : reinterpret_cast< ::apollo::simulation::DistToLaneCenterCondition&>(::apollo::simulation::_DistToLaneCenterCondition_default_instance_);
}
inline const ::apollo::simulation::DistToLaneCenterCondition& Condition::dist_to_lane_center_condition() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.Condition.dist_to_lane_center_condition)
  return _internal_dist_to_lane_center_condition();
}
inline ::apollo::simulation::DistToLaneCenterCondition* Condition::unsafe_arena_release_dist_to_lane_center_condition() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.simulation.Condition.dist_to_lane_center_condition)
  if (_internal_has_dist_to_lane_center_condition()) {
    clear_has_condition();
    ::apollo::simulation::DistToLaneCenterCondition* temp = condition_.dist_to_lane_center_condition_;
    condition_.dist_to_lane_center_condition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_dist_to_lane_center_condition(::apollo::simulation::DistToLaneCenterCondition* dist_to_lane_center_condition) {
  clear_condition();
  if (dist_to_lane_center_condition) {
    set_has_dist_to_lane_center_condition();
    condition_.dist_to_lane_center_condition_ = dist_to_lane_center_condition;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.simulation.Condition.dist_to_lane_center_condition)
}
inline ::apollo::simulation::DistToLaneCenterCondition* Condition::_internal_mutable_dist_to_lane_center_condition() {
  if (!_internal_has_dist_to_lane_center_condition()) {
    clear_condition();
    set_has_dist_to_lane_center_condition();
    condition_.dist_to_lane_center_condition_ = CreateMaybeMessage< ::apollo::simulation::DistToLaneCenterCondition >(GetArena());
  }
  return condition_.dist_to_lane_center_condition_;
}
inline ::apollo::simulation::DistToLaneCenterCondition* Condition::mutable_dist_to_lane_center_condition() {
  // @@protoc_insertion_point(field_mutable:apollo.simulation.Condition.dist_to_lane_center_condition)
  return _internal_mutable_dist_to_lane_center_condition();
}

// .apollo.simulation.CrosswalkStopCondition crosswalk_stop_condition = 20;
inline bool Condition::_internal_has_crosswalk_stop_condition() const {
  return condition_case() == kCrosswalkStopCondition;
}
inline bool Condition::has_crosswalk_stop_condition() const {
  return _internal_has_crosswalk_stop_condition();
}
inline void Condition::set_has_crosswalk_stop_condition() {
  _oneof_case_[0] = kCrosswalkStopCondition;
}
inline void Condition::clear_crosswalk_stop_condition() {
  if (_internal_has_crosswalk_stop_condition()) {
    if (GetArena() == nullptr) {
      delete condition_.crosswalk_stop_condition_;
    }
    clear_has_condition();
  }
}
inline ::apollo::simulation::CrosswalkStopCondition* Condition::release_crosswalk_stop_condition() {
  // @@protoc_insertion_point(field_release:apollo.simulation.Condition.crosswalk_stop_condition)
  if (_internal_has_crosswalk_stop_condition()) {
    clear_has_condition();
      ::apollo::simulation::CrosswalkStopCondition* temp = condition_.crosswalk_stop_condition_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    condition_.crosswalk_stop_condition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::simulation::CrosswalkStopCondition& Condition::_internal_crosswalk_stop_condition() const {
  return _internal_has_crosswalk_stop_condition()
      ? *condition_.crosswalk_stop_condition_
      : reinterpret_cast< ::apollo::simulation::CrosswalkStopCondition&>(::apollo::simulation::_CrosswalkStopCondition_default_instance_);
}
inline const ::apollo::simulation::CrosswalkStopCondition& Condition::crosswalk_stop_condition() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.Condition.crosswalk_stop_condition)
  return _internal_crosswalk_stop_condition();
}
inline ::apollo::simulation::CrosswalkStopCondition* Condition::unsafe_arena_release_crosswalk_stop_condition() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.simulation.Condition.crosswalk_stop_condition)
  if (_internal_has_crosswalk_stop_condition()) {
    clear_has_condition();
    ::apollo::simulation::CrosswalkStopCondition* temp = condition_.crosswalk_stop_condition_;
    condition_.crosswalk_stop_condition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_crosswalk_stop_condition(::apollo::simulation::CrosswalkStopCondition* crosswalk_stop_condition) {
  clear_condition();
  if (crosswalk_stop_condition) {
    set_has_crosswalk_stop_condition();
    condition_.crosswalk_stop_condition_ = crosswalk_stop_condition;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.simulation.Condition.crosswalk_stop_condition)
}
inline ::apollo::simulation::CrosswalkStopCondition* Condition::_internal_mutable_crosswalk_stop_condition() {
  if (!_internal_has_crosswalk_stop_condition()) {
    clear_condition();
    set_has_crosswalk_stop_condition();
    condition_.crosswalk_stop_condition_ = CreateMaybeMessage< ::apollo::simulation::CrosswalkStopCondition >(GetArena());
  }
  return condition_.crosswalk_stop_condition_;
}
inline ::apollo::simulation::CrosswalkStopCondition* Condition::mutable_crosswalk_stop_condition() {
  // @@protoc_insertion_point(field_mutable:apollo.simulation.Condition.crosswalk_stop_condition)
  return _internal_mutable_crosswalk_stop_condition();
}

// .apollo.simulation.RedLightStopCondition red_light_stop_condition = 21;
inline bool Condition::_internal_has_red_light_stop_condition() const {
  return condition_case() == kRedLightStopCondition;
}
inline bool Condition::has_red_light_stop_condition() const {
  return _internal_has_red_light_stop_condition();
}
inline void Condition::set_has_red_light_stop_condition() {
  _oneof_case_[0] = kRedLightStopCondition;
}
inline void Condition::clear_red_light_stop_condition() {
  if (_internal_has_red_light_stop_condition()) {
    if (GetArena() == nullptr) {
      delete condition_.red_light_stop_condition_;
    }
    clear_has_condition();
  }
}
inline ::apollo::simulation::RedLightStopCondition* Condition::release_red_light_stop_condition() {
  // @@protoc_insertion_point(field_release:apollo.simulation.Condition.red_light_stop_condition)
  if (_internal_has_red_light_stop_condition()) {
    clear_has_condition();
      ::apollo::simulation::RedLightStopCondition* temp = condition_.red_light_stop_condition_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    condition_.red_light_stop_condition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::simulation::RedLightStopCondition& Condition::_internal_red_light_stop_condition() const {
  return _internal_has_red_light_stop_condition()
      ? *condition_.red_light_stop_condition_
      : reinterpret_cast< ::apollo::simulation::RedLightStopCondition&>(::apollo::simulation::_RedLightStopCondition_default_instance_);
}
inline const ::apollo::simulation::RedLightStopCondition& Condition::red_light_stop_condition() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.Condition.red_light_stop_condition)
  return _internal_red_light_stop_condition();
}
inline ::apollo::simulation::RedLightStopCondition* Condition::unsafe_arena_release_red_light_stop_condition() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.simulation.Condition.red_light_stop_condition)
  if (_internal_has_red_light_stop_condition()) {
    clear_has_condition();
    ::apollo::simulation::RedLightStopCondition* temp = condition_.red_light_stop_condition_;
    condition_.red_light_stop_condition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_red_light_stop_condition(::apollo::simulation::RedLightStopCondition* red_light_stop_condition) {
  clear_condition();
  if (red_light_stop_condition) {
    set_has_red_light_stop_condition();
    condition_.red_light_stop_condition_ = red_light_stop_condition;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.simulation.Condition.red_light_stop_condition)
}
inline ::apollo::simulation::RedLightStopCondition* Condition::_internal_mutable_red_light_stop_condition() {
  if (!_internal_has_red_light_stop_condition()) {
    clear_condition();
    set_has_red_light_stop_condition();
    condition_.red_light_stop_condition_ = CreateMaybeMessage< ::apollo::simulation::RedLightStopCondition >(GetArena());
  }
  return condition_.red_light_stop_condition_;
}
inline ::apollo::simulation::RedLightStopCondition* Condition::mutable_red_light_stop_condition() {
  // @@protoc_insertion_point(field_mutable:apollo.simulation.Condition.red_light_stop_condition)
  return _internal_mutable_red_light_stop_condition();
}

// .apollo.simulation.SpeedbumpLimitCondition speedbump_limit_condition = 22;
inline bool Condition::_internal_has_speedbump_limit_condition() const {
  return condition_case() == kSpeedbumpLimitCondition;
}
inline bool Condition::has_speedbump_limit_condition() const {
  return _internal_has_speedbump_limit_condition();
}
inline void Condition::set_has_speedbump_limit_condition() {
  _oneof_case_[0] = kSpeedbumpLimitCondition;
}
inline void Condition::clear_speedbump_limit_condition() {
  if (_internal_has_speedbump_limit_condition()) {
    if (GetArena() == nullptr) {
      delete condition_.speedbump_limit_condition_;
    }
    clear_has_condition();
  }
}
inline ::apollo::simulation::SpeedbumpLimitCondition* Condition::release_speedbump_limit_condition() {
  // @@protoc_insertion_point(field_release:apollo.simulation.Condition.speedbump_limit_condition)
  if (_internal_has_speedbump_limit_condition()) {
    clear_has_condition();
      ::apollo::simulation::SpeedbumpLimitCondition* temp = condition_.speedbump_limit_condition_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    condition_.speedbump_limit_condition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::simulation::SpeedbumpLimitCondition& Condition::_internal_speedbump_limit_condition() const {
  return _internal_has_speedbump_limit_condition()
      ? *condition_.speedbump_limit_condition_
      : reinterpret_cast< ::apollo::simulation::SpeedbumpLimitCondition&>(::apollo::simulation::_SpeedbumpLimitCondition_default_instance_);
}
inline const ::apollo::simulation::SpeedbumpLimitCondition& Condition::speedbump_limit_condition() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.Condition.speedbump_limit_condition)
  return _internal_speedbump_limit_condition();
}
inline ::apollo::simulation::SpeedbumpLimitCondition* Condition::unsafe_arena_release_speedbump_limit_condition() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.simulation.Condition.speedbump_limit_condition)
  if (_internal_has_speedbump_limit_condition()) {
    clear_has_condition();
    ::apollo::simulation::SpeedbumpLimitCondition* temp = condition_.speedbump_limit_condition_;
    condition_.speedbump_limit_condition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_speedbump_limit_condition(::apollo::simulation::SpeedbumpLimitCondition* speedbump_limit_condition) {
  clear_condition();
  if (speedbump_limit_condition) {
    set_has_speedbump_limit_condition();
    condition_.speedbump_limit_condition_ = speedbump_limit_condition;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.simulation.Condition.speedbump_limit_condition)
}
inline ::apollo::simulation::SpeedbumpLimitCondition* Condition::_internal_mutable_speedbump_limit_condition() {
  if (!_internal_has_speedbump_limit_condition()) {
    clear_condition();
    set_has_speedbump_limit_condition();
    condition_.speedbump_limit_condition_ = CreateMaybeMessage< ::apollo::simulation::SpeedbumpLimitCondition >(GetArena());
  }
  return condition_.speedbump_limit_condition_;
}
inline ::apollo::simulation::SpeedbumpLimitCondition* Condition::mutable_speedbump_limit_condition() {
  // @@protoc_insertion_point(field_mutable:apollo.simulation.Condition.speedbump_limit_condition)
  return _internal_mutable_speedbump_limit_condition();
}

// .apollo.simulation.WorkingZoneAvoidLimitCondition working_zone_avoid_limit_condition = 23;
inline bool Condition::_internal_has_working_zone_avoid_limit_condition() const {
  return condition_case() == kWorkingZoneAvoidLimitCondition;
}
inline bool Condition::has_working_zone_avoid_limit_condition() const {
  return _internal_has_working_zone_avoid_limit_condition();
}
inline void Condition::set_has_working_zone_avoid_limit_condition() {
  _oneof_case_[0] = kWorkingZoneAvoidLimitCondition;
}
inline void Condition::clear_working_zone_avoid_limit_condition() {
  if (_internal_has_working_zone_avoid_limit_condition()) {
    if (GetArena() == nullptr) {
      delete condition_.working_zone_avoid_limit_condition_;
    }
    clear_has_condition();
  }
}
inline ::apollo::simulation::WorkingZoneAvoidLimitCondition* Condition::release_working_zone_avoid_limit_condition() {
  // @@protoc_insertion_point(field_release:apollo.simulation.Condition.working_zone_avoid_limit_condition)
  if (_internal_has_working_zone_avoid_limit_condition()) {
    clear_has_condition();
      ::apollo::simulation::WorkingZoneAvoidLimitCondition* temp = condition_.working_zone_avoid_limit_condition_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    condition_.working_zone_avoid_limit_condition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::simulation::WorkingZoneAvoidLimitCondition& Condition::_internal_working_zone_avoid_limit_condition() const {
  return _internal_has_working_zone_avoid_limit_condition()
      ? *condition_.working_zone_avoid_limit_condition_
      : reinterpret_cast< ::apollo::simulation::WorkingZoneAvoidLimitCondition&>(::apollo::simulation::_WorkingZoneAvoidLimitCondition_default_instance_);
}
inline const ::apollo::simulation::WorkingZoneAvoidLimitCondition& Condition::working_zone_avoid_limit_condition() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.Condition.working_zone_avoid_limit_condition)
  return _internal_working_zone_avoid_limit_condition();
}
inline ::apollo::simulation::WorkingZoneAvoidLimitCondition* Condition::unsafe_arena_release_working_zone_avoid_limit_condition() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.simulation.Condition.working_zone_avoid_limit_condition)
  if (_internal_has_working_zone_avoid_limit_condition()) {
    clear_has_condition();
    ::apollo::simulation::WorkingZoneAvoidLimitCondition* temp = condition_.working_zone_avoid_limit_condition_;
    condition_.working_zone_avoid_limit_condition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_working_zone_avoid_limit_condition(::apollo::simulation::WorkingZoneAvoidLimitCondition* working_zone_avoid_limit_condition) {
  clear_condition();
  if (working_zone_avoid_limit_condition) {
    set_has_working_zone_avoid_limit_condition();
    condition_.working_zone_avoid_limit_condition_ = working_zone_avoid_limit_condition;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.simulation.Condition.working_zone_avoid_limit_condition)
}
inline ::apollo::simulation::WorkingZoneAvoidLimitCondition* Condition::_internal_mutable_working_zone_avoid_limit_condition() {
  if (!_internal_has_working_zone_avoid_limit_condition()) {
    clear_condition();
    set_has_working_zone_avoid_limit_condition();
    condition_.working_zone_avoid_limit_condition_ = CreateMaybeMessage< ::apollo::simulation::WorkingZoneAvoidLimitCondition >(GetArena());
  }
  return condition_.working_zone_avoid_limit_condition_;
}
inline ::apollo::simulation::WorkingZoneAvoidLimitCondition* Condition::mutable_working_zone_avoid_limit_condition() {
  // @@protoc_insertion_point(field_mutable:apollo.simulation.Condition.working_zone_avoid_limit_condition)
  return _internal_mutable_working_zone_avoid_limit_condition();
}

// .apollo.simulation.LimitedTimeParkingCondition limited_time_parking_condition = 24;
inline bool Condition::_internal_has_limited_time_parking_condition() const {
  return condition_case() == kLimitedTimeParkingCondition;
}
inline bool Condition::has_limited_time_parking_condition() const {
  return _internal_has_limited_time_parking_condition();
}
inline void Condition::set_has_limited_time_parking_condition() {
  _oneof_case_[0] = kLimitedTimeParkingCondition;
}
inline void Condition::clear_limited_time_parking_condition() {
  if (_internal_has_limited_time_parking_condition()) {
    if (GetArena() == nullptr) {
      delete condition_.limited_time_parking_condition_;
    }
    clear_has_condition();
  }
}
inline ::apollo::simulation::LimitedTimeParkingCondition* Condition::release_limited_time_parking_condition() {
  // @@protoc_insertion_point(field_release:apollo.simulation.Condition.limited_time_parking_condition)
  if (_internal_has_limited_time_parking_condition()) {
    clear_has_condition();
      ::apollo::simulation::LimitedTimeParkingCondition* temp = condition_.limited_time_parking_condition_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    condition_.limited_time_parking_condition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::simulation::LimitedTimeParkingCondition& Condition::_internal_limited_time_parking_condition() const {
  return _internal_has_limited_time_parking_condition()
      ? *condition_.limited_time_parking_condition_
      : reinterpret_cast< ::apollo::simulation::LimitedTimeParkingCondition&>(::apollo::simulation::_LimitedTimeParkingCondition_default_instance_);
}
inline const ::apollo::simulation::LimitedTimeParkingCondition& Condition::limited_time_parking_condition() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.Condition.limited_time_parking_condition)
  return _internal_limited_time_parking_condition();
}
inline ::apollo::simulation::LimitedTimeParkingCondition* Condition::unsafe_arena_release_limited_time_parking_condition() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.simulation.Condition.limited_time_parking_condition)
  if (_internal_has_limited_time_parking_condition()) {
    clear_has_condition();
    ::apollo::simulation::LimitedTimeParkingCondition* temp = condition_.limited_time_parking_condition_;
    condition_.limited_time_parking_condition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_limited_time_parking_condition(::apollo::simulation::LimitedTimeParkingCondition* limited_time_parking_condition) {
  clear_condition();
  if (limited_time_parking_condition) {
    set_has_limited_time_parking_condition();
    condition_.limited_time_parking_condition_ = limited_time_parking_condition;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.simulation.Condition.limited_time_parking_condition)
}
inline ::apollo::simulation::LimitedTimeParkingCondition* Condition::_internal_mutable_limited_time_parking_condition() {
  if (!_internal_has_limited_time_parking_condition()) {
    clear_condition();
    set_has_limited_time_parking_condition();
    condition_.limited_time_parking_condition_ = CreateMaybeMessage< ::apollo::simulation::LimitedTimeParkingCondition >(GetArena());
  }
  return condition_.limited_time_parking_condition_;
}
inline ::apollo::simulation::LimitedTimeParkingCondition* Condition::mutable_limited_time_parking_condition() {
  // @@protoc_insertion_point(field_mutable:apollo.simulation.Condition.limited_time_parking_condition)
  return _internal_mutable_limited_time_parking_condition();
}

// .apollo.simulation.FollowAndBypassCondition follow_and_bypass_condition = 25;
inline bool Condition::_internal_has_follow_and_bypass_condition() const {
  return condition_case() == kFollowAndBypassCondition;
}
inline bool Condition::has_follow_and_bypass_condition() const {
  return _internal_has_follow_and_bypass_condition();
}
inline void Condition::set_has_follow_and_bypass_condition() {
  _oneof_case_[0] = kFollowAndBypassCondition;
}
inline void Condition::clear_follow_and_bypass_condition() {
  if (_internal_has_follow_and_bypass_condition()) {
    if (GetArena() == nullptr) {
      delete condition_.follow_and_bypass_condition_;
    }
    clear_has_condition();
  }
}
inline ::apollo::simulation::FollowAndBypassCondition* Condition::release_follow_and_bypass_condition() {
  // @@protoc_insertion_point(field_release:apollo.simulation.Condition.follow_and_bypass_condition)
  if (_internal_has_follow_and_bypass_condition()) {
    clear_has_condition();
      ::apollo::simulation::FollowAndBypassCondition* temp = condition_.follow_and_bypass_condition_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    condition_.follow_and_bypass_condition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::simulation::FollowAndBypassCondition& Condition::_internal_follow_and_bypass_condition() const {
  return _internal_has_follow_and_bypass_condition()
      ? *condition_.follow_and_bypass_condition_
      : reinterpret_cast< ::apollo::simulation::FollowAndBypassCondition&>(::apollo::simulation::_FollowAndBypassCondition_default_instance_);
}
inline const ::apollo::simulation::FollowAndBypassCondition& Condition::follow_and_bypass_condition() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.Condition.follow_and_bypass_condition)
  return _internal_follow_and_bypass_condition();
}
inline ::apollo::simulation::FollowAndBypassCondition* Condition::unsafe_arena_release_follow_and_bypass_condition() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.simulation.Condition.follow_and_bypass_condition)
  if (_internal_has_follow_and_bypass_condition()) {
    clear_has_condition();
    ::apollo::simulation::FollowAndBypassCondition* temp = condition_.follow_and_bypass_condition_;
    condition_.follow_and_bypass_condition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_follow_and_bypass_condition(::apollo::simulation::FollowAndBypassCondition* follow_and_bypass_condition) {
  clear_condition();
  if (follow_and_bypass_condition) {
    set_has_follow_and_bypass_condition();
    condition_.follow_and_bypass_condition_ = follow_and_bypass_condition;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.simulation.Condition.follow_and_bypass_condition)
}
inline ::apollo::simulation::FollowAndBypassCondition* Condition::_internal_mutable_follow_and_bypass_condition() {
  if (!_internal_has_follow_and_bypass_condition()) {
    clear_condition();
    set_has_follow_and_bypass_condition();
    condition_.follow_and_bypass_condition_ = CreateMaybeMessage< ::apollo::simulation::FollowAndBypassCondition >(GetArena());
  }
  return condition_.follow_and_bypass_condition_;
}
inline ::apollo::simulation::FollowAndBypassCondition* Condition::mutable_follow_and_bypass_condition() {
  // @@protoc_insertion_point(field_mutable:apollo.simulation.Condition.follow_and_bypass_condition)
  return _internal_mutable_follow_and_bypass_condition();
}

// .apollo.simulation.ObstacleBypassCondition obstacle_bypass_condition = 26;
inline bool Condition::_internal_has_obstacle_bypass_condition() const {
  return condition_case() == kObstacleBypassCondition;
}
inline bool Condition::has_obstacle_bypass_condition() const {
  return _internal_has_obstacle_bypass_condition();
}
inline void Condition::set_has_obstacle_bypass_condition() {
  _oneof_case_[0] = kObstacleBypassCondition;
}
inline void Condition::clear_obstacle_bypass_condition() {
  if (_internal_has_obstacle_bypass_condition()) {
    if (GetArena() == nullptr) {
      delete condition_.obstacle_bypass_condition_;
    }
    clear_has_condition();
  }
}
inline ::apollo::simulation::ObstacleBypassCondition* Condition::release_obstacle_bypass_condition() {
  // @@protoc_insertion_point(field_release:apollo.simulation.Condition.obstacle_bypass_condition)
  if (_internal_has_obstacle_bypass_condition()) {
    clear_has_condition();
      ::apollo::simulation::ObstacleBypassCondition* temp = condition_.obstacle_bypass_condition_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    condition_.obstacle_bypass_condition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::simulation::ObstacleBypassCondition& Condition::_internal_obstacle_bypass_condition() const {
  return _internal_has_obstacle_bypass_condition()
      ? *condition_.obstacle_bypass_condition_
      : reinterpret_cast< ::apollo::simulation::ObstacleBypassCondition&>(::apollo::simulation::_ObstacleBypassCondition_default_instance_);
}
inline const ::apollo::simulation::ObstacleBypassCondition& Condition::obstacle_bypass_condition() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.Condition.obstacle_bypass_condition)
  return _internal_obstacle_bypass_condition();
}
inline ::apollo::simulation::ObstacleBypassCondition* Condition::unsafe_arena_release_obstacle_bypass_condition() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.simulation.Condition.obstacle_bypass_condition)
  if (_internal_has_obstacle_bypass_condition()) {
    clear_has_condition();
    ::apollo::simulation::ObstacleBypassCondition* temp = condition_.obstacle_bypass_condition_;
    condition_.obstacle_bypass_condition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_obstacle_bypass_condition(::apollo::simulation::ObstacleBypassCondition* obstacle_bypass_condition) {
  clear_condition();
  if (obstacle_bypass_condition) {
    set_has_obstacle_bypass_condition();
    condition_.obstacle_bypass_condition_ = obstacle_bypass_condition;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.simulation.Condition.obstacle_bypass_condition)
}
inline ::apollo::simulation::ObstacleBypassCondition* Condition::_internal_mutable_obstacle_bypass_condition() {
  if (!_internal_has_obstacle_bypass_condition()) {
    clear_condition();
    set_has_obstacle_bypass_condition();
    condition_.obstacle_bypass_condition_ = CreateMaybeMessage< ::apollo::simulation::ObstacleBypassCondition >(GetArena());
  }
  return condition_.obstacle_bypass_condition_;
}
inline ::apollo::simulation::ObstacleBypassCondition* Condition::mutable_obstacle_bypass_condition() {
  // @@protoc_insertion_point(field_mutable:apollo.simulation.Condition.obstacle_bypass_condition)
  return _internal_mutable_obstacle_bypass_condition();
}

// .apollo.simulation.CentripetalAccelerationCondition centripetal_acceleration_condition = 27;
inline bool Condition::_internal_has_centripetal_acceleration_condition() const {
  return condition_case() == kCentripetalAccelerationCondition;
}
inline bool Condition::has_centripetal_acceleration_condition() const {
  return _internal_has_centripetal_acceleration_condition();
}
inline void Condition::set_has_centripetal_acceleration_condition() {
  _oneof_case_[0] = kCentripetalAccelerationCondition;
}
inline void Condition::clear_centripetal_acceleration_condition() {
  if (_internal_has_centripetal_acceleration_condition()) {
    if (GetArena() == nullptr) {
      delete condition_.centripetal_acceleration_condition_;
    }
    clear_has_condition();
  }
}
inline ::apollo::simulation::CentripetalAccelerationCondition* Condition::release_centripetal_acceleration_condition() {
  // @@protoc_insertion_point(field_release:apollo.simulation.Condition.centripetal_acceleration_condition)
  if (_internal_has_centripetal_acceleration_condition()) {
    clear_has_condition();
      ::apollo::simulation::CentripetalAccelerationCondition* temp = condition_.centripetal_acceleration_condition_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    condition_.centripetal_acceleration_condition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::simulation::CentripetalAccelerationCondition& Condition::_internal_centripetal_acceleration_condition() const {
  return _internal_has_centripetal_acceleration_condition()
      ? *condition_.centripetal_acceleration_condition_
      : reinterpret_cast< ::apollo::simulation::CentripetalAccelerationCondition&>(::apollo::simulation::_CentripetalAccelerationCondition_default_instance_);
}
inline const ::apollo::simulation::CentripetalAccelerationCondition& Condition::centripetal_acceleration_condition() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.Condition.centripetal_acceleration_condition)
  return _internal_centripetal_acceleration_condition();
}
inline ::apollo::simulation::CentripetalAccelerationCondition* Condition::unsafe_arena_release_centripetal_acceleration_condition() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.simulation.Condition.centripetal_acceleration_condition)
  if (_internal_has_centripetal_acceleration_condition()) {
    clear_has_condition();
    ::apollo::simulation::CentripetalAccelerationCondition* temp = condition_.centripetal_acceleration_condition_;
    condition_.centripetal_acceleration_condition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_centripetal_acceleration_condition(::apollo::simulation::CentripetalAccelerationCondition* centripetal_acceleration_condition) {
  clear_condition();
  if (centripetal_acceleration_condition) {
    set_has_centripetal_acceleration_condition();
    condition_.centripetal_acceleration_condition_ = centripetal_acceleration_condition;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.simulation.Condition.centripetal_acceleration_condition)
}
inline ::apollo::simulation::CentripetalAccelerationCondition* Condition::_internal_mutable_centripetal_acceleration_condition() {
  if (!_internal_has_centripetal_acceleration_condition()) {
    clear_condition();
    set_has_centripetal_acceleration_condition();
    condition_.centripetal_acceleration_condition_ = CreateMaybeMessage< ::apollo::simulation::CentripetalAccelerationCondition >(GetArena());
  }
  return condition_.centripetal_acceleration_condition_;
}
inline ::apollo::simulation::CentripetalAccelerationCondition* Condition::mutable_centripetal_acceleration_condition() {
  // @@protoc_insertion_point(field_mutable:apollo.simulation.Condition.centripetal_acceleration_condition)
  return _internal_mutable_centripetal_acceleration_condition();
}

// .apollo.simulation.TimeLimitCondition time_limit_condition = 28;
inline bool Condition::_internal_has_time_limit_condition() const {
  return condition_case() == kTimeLimitCondition;
}
inline bool Condition::has_time_limit_condition() const {
  return _internal_has_time_limit_condition();
}
inline void Condition::set_has_time_limit_condition() {
  _oneof_case_[0] = kTimeLimitCondition;
}
inline void Condition::clear_time_limit_condition() {
  if (_internal_has_time_limit_condition()) {
    if (GetArena() == nullptr) {
      delete condition_.time_limit_condition_;
    }
    clear_has_condition();
  }
}
inline ::apollo::simulation::TimeLimitCondition* Condition::release_time_limit_condition() {
  // @@protoc_insertion_point(field_release:apollo.simulation.Condition.time_limit_condition)
  if (_internal_has_time_limit_condition()) {
    clear_has_condition();
      ::apollo::simulation::TimeLimitCondition* temp = condition_.time_limit_condition_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    condition_.time_limit_condition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::simulation::TimeLimitCondition& Condition::_internal_time_limit_condition() const {
  return _internal_has_time_limit_condition()
      ? *condition_.time_limit_condition_
      : reinterpret_cast< ::apollo::simulation::TimeLimitCondition&>(::apollo::simulation::_TimeLimitCondition_default_instance_);
}
inline const ::apollo::simulation::TimeLimitCondition& Condition::time_limit_condition() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.Condition.time_limit_condition)
  return _internal_time_limit_condition();
}
inline ::apollo::simulation::TimeLimitCondition* Condition::unsafe_arena_release_time_limit_condition() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.simulation.Condition.time_limit_condition)
  if (_internal_has_time_limit_condition()) {
    clear_has_condition();
    ::apollo::simulation::TimeLimitCondition* temp = condition_.time_limit_condition_;
    condition_.time_limit_condition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_time_limit_condition(::apollo::simulation::TimeLimitCondition* time_limit_condition) {
  clear_condition();
  if (time_limit_condition) {
    set_has_time_limit_condition();
    condition_.time_limit_condition_ = time_limit_condition;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.simulation.Condition.time_limit_condition)
}
inline ::apollo::simulation::TimeLimitCondition* Condition::_internal_mutable_time_limit_condition() {
  if (!_internal_has_time_limit_condition()) {
    clear_condition();
    set_has_time_limit_condition();
    condition_.time_limit_condition_ = CreateMaybeMessage< ::apollo::simulation::TimeLimitCondition >(GetArena());
  }
  return condition_.time_limit_condition_;
}
inline ::apollo::simulation::TimeLimitCondition* Condition::mutable_time_limit_condition() {
  // @@protoc_insertion_point(field_mutable:apollo.simulation.Condition.time_limit_condition)
  return _internal_mutable_time_limit_condition();
}

// .apollo.simulation.AntiCheatingCondition anti_cheating_condition = 29;
inline bool Condition::_internal_has_anti_cheating_condition() const {
  return condition_case() == kAntiCheatingCondition;
}
inline bool Condition::has_anti_cheating_condition() const {
  return _internal_has_anti_cheating_condition();
}
inline void Condition::set_has_anti_cheating_condition() {
  _oneof_case_[0] = kAntiCheatingCondition;
}
inline void Condition::clear_anti_cheating_condition() {
  if (_internal_has_anti_cheating_condition()) {
    if (GetArena() == nullptr) {
      delete condition_.anti_cheating_condition_;
    }
    clear_has_condition();
  }
}
inline ::apollo::simulation::AntiCheatingCondition* Condition::release_anti_cheating_condition() {
  // @@protoc_insertion_point(field_release:apollo.simulation.Condition.anti_cheating_condition)
  if (_internal_has_anti_cheating_condition()) {
    clear_has_condition();
      ::apollo::simulation::AntiCheatingCondition* temp = condition_.anti_cheating_condition_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    condition_.anti_cheating_condition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::simulation::AntiCheatingCondition& Condition::_internal_anti_cheating_condition() const {
  return _internal_has_anti_cheating_condition()
      ? *condition_.anti_cheating_condition_
      : reinterpret_cast< ::apollo::simulation::AntiCheatingCondition&>(::apollo::simulation::_AntiCheatingCondition_default_instance_);
}
inline const ::apollo::simulation::AntiCheatingCondition& Condition::anti_cheating_condition() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.Condition.anti_cheating_condition)
  return _internal_anti_cheating_condition();
}
inline ::apollo::simulation::AntiCheatingCondition* Condition::unsafe_arena_release_anti_cheating_condition() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.simulation.Condition.anti_cheating_condition)
  if (_internal_has_anti_cheating_condition()) {
    clear_has_condition();
    ::apollo::simulation::AntiCheatingCondition* temp = condition_.anti_cheating_condition_;
    condition_.anti_cheating_condition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_anti_cheating_condition(::apollo::simulation::AntiCheatingCondition* anti_cheating_condition) {
  clear_condition();
  if (anti_cheating_condition) {
    set_has_anti_cheating_condition();
    condition_.anti_cheating_condition_ = anti_cheating_condition;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.simulation.Condition.anti_cheating_condition)
}
inline ::apollo::simulation::AntiCheatingCondition* Condition::_internal_mutable_anti_cheating_condition() {
  if (!_internal_has_anti_cheating_condition()) {
    clear_condition();
    set_has_anti_cheating_condition();
    condition_.anti_cheating_condition_ = CreateMaybeMessage< ::apollo::simulation::AntiCheatingCondition >(GetArena());
  }
  return condition_.anti_cheating_condition_;
}
inline ::apollo::simulation::AntiCheatingCondition* Condition::mutable_anti_cheating_condition() {
  // @@protoc_insertion_point(field_mutable:apollo.simulation.Condition.anti_cheating_condition)
  return _internal_mutable_anti_cheating_condition();
}

// .apollo.simulation.KeyPointCondition key_point_condition = 30;
inline bool Condition::_internal_has_key_point_condition() const {
  return condition_case() == kKeyPointCondition;
}
inline bool Condition::has_key_point_condition() const {
  return _internal_has_key_point_condition();
}
inline void Condition::set_has_key_point_condition() {
  _oneof_case_[0] = kKeyPointCondition;
}
inline void Condition::clear_key_point_condition() {
  if (_internal_has_key_point_condition()) {
    if (GetArena() == nullptr) {
      delete condition_.key_point_condition_;
    }
    clear_has_condition();
  }
}
inline ::apollo::simulation::KeyPointCondition* Condition::release_key_point_condition() {
  // @@protoc_insertion_point(field_release:apollo.simulation.Condition.key_point_condition)
  if (_internal_has_key_point_condition()) {
    clear_has_condition();
      ::apollo::simulation::KeyPointCondition* temp = condition_.key_point_condition_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    condition_.key_point_condition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::simulation::KeyPointCondition& Condition::_internal_key_point_condition() const {
  return _internal_has_key_point_condition()
      ? *condition_.key_point_condition_
      : reinterpret_cast< ::apollo::simulation::KeyPointCondition&>(::apollo::simulation::_KeyPointCondition_default_instance_);
}
inline const ::apollo::simulation::KeyPointCondition& Condition::key_point_condition() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.Condition.key_point_condition)
  return _internal_key_point_condition();
}
inline ::apollo::simulation::KeyPointCondition* Condition::unsafe_arena_release_key_point_condition() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.simulation.Condition.key_point_condition)
  if (_internal_has_key_point_condition()) {
    clear_has_condition();
    ::apollo::simulation::KeyPointCondition* temp = condition_.key_point_condition_;
    condition_.key_point_condition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_key_point_condition(::apollo::simulation::KeyPointCondition* key_point_condition) {
  clear_condition();
  if (key_point_condition) {
    set_has_key_point_condition();
    condition_.key_point_condition_ = key_point_condition;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.simulation.Condition.key_point_condition)
}
inline ::apollo::simulation::KeyPointCondition* Condition::_internal_mutable_key_point_condition() {
  if (!_internal_has_key_point_condition()) {
    clear_condition();
    set_has_key_point_condition();
    condition_.key_point_condition_ = CreateMaybeMessage< ::apollo::simulation::KeyPointCondition >(GetArena());
  }
  return condition_.key_point_condition_;
}
inline ::apollo::simulation::KeyPointCondition* Condition::mutable_key_point_condition() {
  // @@protoc_insertion_point(field_mutable:apollo.simulation.Condition.key_point_condition)
  return _internal_mutable_key_point_condition();
}

// optional .apollo.simulation.GradePlanning grade_planning = 100;
inline bool Condition::_internal_has_grade_planning() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || grade_planning_ != nullptr);
  return value;
}
inline bool Condition::has_grade_planning() const {
  return _internal_has_grade_planning();
}
inline void Condition::clear_grade_planning() {
  if (grade_planning_ != nullptr) grade_planning_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::apollo::simulation::GradePlanning& Condition::_internal_grade_planning() const {
  const ::apollo::simulation::GradePlanning* p = grade_planning_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::simulation::GradePlanning&>(
      ::apollo::simulation::_GradePlanning_default_instance_);
}
inline const ::apollo::simulation::GradePlanning& Condition::grade_planning() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.Condition.grade_planning)
  return _internal_grade_planning();
}
inline void Condition::unsafe_arena_set_allocated_grade_planning(
    ::apollo::simulation::GradePlanning* grade_planning) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(grade_planning_);
  }
  grade_planning_ = grade_planning;
  if (grade_planning) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.simulation.Condition.grade_planning)
}
inline ::apollo::simulation::GradePlanning* Condition::release_grade_planning() {
  _has_bits_[0] &= ~0x00000001u;
  ::apollo::simulation::GradePlanning* temp = grade_planning_;
  grade_planning_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::apollo::simulation::GradePlanning* Condition::unsafe_arena_release_grade_planning() {
  // @@protoc_insertion_point(field_release:apollo.simulation.Condition.grade_planning)
  _has_bits_[0] &= ~0x00000001u;
  ::apollo::simulation::GradePlanning* temp = grade_planning_;
  grade_planning_ = nullptr;
  return temp;
}
inline ::apollo::simulation::GradePlanning* Condition::_internal_mutable_grade_planning() {
  _has_bits_[0] |= 0x00000001u;
  if (grade_planning_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::simulation::GradePlanning>(GetArena());
    grade_planning_ = p;
  }
  return grade_planning_;
}
inline ::apollo::simulation::GradePlanning* Condition::mutable_grade_planning() {
  // @@protoc_insertion_point(field_mutable:apollo.simulation.Condition.grade_planning)
  return _internal_mutable_grade_planning();
}
inline void Condition::set_allocated_grade_planning(::apollo::simulation::GradePlanning* grade_planning) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete grade_planning_;
  }
  if (grade_planning) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(grade_planning);
    if (message_arena != submessage_arena) {
      grade_planning = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, grade_planning, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  grade_planning_ = grade_planning;
  // @@protoc_insertion_point(field_set_allocated:apollo.simulation.Condition.grade_planning)
}

inline bool Condition::has_condition() const {
  return condition_case() != CONDITION_NOT_SET;
}
inline void Condition::clear_has_condition() {
  _oneof_case_[0] = CONDITION_NOT_SET;
}
inline Condition::ConditionCase Condition::condition_case() const {
  return Condition::ConditionCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// GradePlanning

// optional sint32 duration = 1 [default = 0];
inline bool GradePlanning::_internal_has_duration() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GradePlanning::has_duration() const {
  return _internal_has_duration();
}
inline void GradePlanning::clear_duration() {
  duration_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GradePlanning::_internal_duration() const {
  return duration_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GradePlanning::duration() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.GradePlanning.duration)
  return _internal_duration();
}
inline void GradePlanning::_internal_set_duration(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  duration_ = value;
}
inline void GradePlanning::set_duration(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_duration(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.GradePlanning.duration)
}

// optional bool update_obstacles = 2 [default = false];
inline bool GradePlanning::_internal_has_update_obstacles() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GradePlanning::has_update_obstacles() const {
  return _internal_has_update_obstacles();
}
inline void GradePlanning::clear_update_obstacles() {
  update_obstacles_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool GradePlanning::_internal_update_obstacles() const {
  return update_obstacles_;
}
inline bool GradePlanning::update_obstacles() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.GradePlanning.update_obstacles)
  return _internal_update_obstacles();
}
inline void GradePlanning::_internal_set_update_obstacles(bool value) {
  _has_bits_[0] |= 0x00000002u;
  update_obstacles_ = value;
}
inline void GradePlanning::set_update_obstacles(bool value) {
  _internal_set_update_obstacles(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.GradePlanning.update_obstacles)
}

// optional bool use_planning_as_history = 3 [default = false];
inline bool GradePlanning::_internal_has_use_planning_as_history() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GradePlanning::has_use_planning_as_history() const {
  return _internal_has_use_planning_as_history();
}
inline void GradePlanning::clear_use_planning_as_history() {
  use_planning_as_history_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool GradePlanning::_internal_use_planning_as_history() const {
  return use_planning_as_history_;
}
inline bool GradePlanning::use_planning_as_history() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.GradePlanning.use_planning_as_history)
  return _internal_use_planning_as_history();
}
inline void GradePlanning::_internal_set_use_planning_as_history(bool value) {
  _has_bits_[0] |= 0x00000004u;
  use_planning_as_history_ = value;
}
inline void GradePlanning::set_use_planning_as_history(bool value) {
  _internal_set_use_planning_as_history(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.GradePlanning.use_planning_as_history)
}

// -------------------------------------------------------------------

// LogicalCondition

// optional .apollo.simulation.LogicalCondition.OperatorType operator_type = 1;
inline bool LogicalCondition::_internal_has_operator_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LogicalCondition::has_operator_type() const {
  return _internal_has_operator_type();
}
inline void LogicalCondition::clear_operator_type() {
  operator_type_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::apollo::simulation::LogicalCondition_OperatorType LogicalCondition::_internal_operator_type() const {
  return static_cast< ::apollo::simulation::LogicalCondition_OperatorType >(operator_type_);
}
inline ::apollo::simulation::LogicalCondition_OperatorType LogicalCondition::operator_type() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.LogicalCondition.operator_type)
  return _internal_operator_type();
}
inline void LogicalCondition::_internal_set_operator_type(::apollo::simulation::LogicalCondition_OperatorType value) {
  assert(::apollo::simulation::LogicalCondition_OperatorType_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  operator_type_ = value;
}
inline void LogicalCondition::set_operator_type(::apollo::simulation::LogicalCondition_OperatorType value) {
  _internal_set_operator_type(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.LogicalCondition.operator_type)
}

// repeated .apollo.simulation.Condition sub_condition = 2;
inline int LogicalCondition::_internal_sub_condition_size() const {
  return sub_condition_.size();
}
inline int LogicalCondition::sub_condition_size() const {
  return _internal_sub_condition_size();
}
inline void LogicalCondition::clear_sub_condition() {
  sub_condition_.Clear();
}
inline ::apollo::simulation::Condition* LogicalCondition::mutable_sub_condition(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.simulation.LogicalCondition.sub_condition)
  return sub_condition_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::simulation::Condition >*
LogicalCondition::mutable_sub_condition() {
  // @@protoc_insertion_point(field_mutable_list:apollo.simulation.LogicalCondition.sub_condition)
  return &sub_condition_;
}
inline const ::apollo::simulation::Condition& LogicalCondition::_internal_sub_condition(int index) const {
  return sub_condition_.Get(index);
}
inline const ::apollo::simulation::Condition& LogicalCondition::sub_condition(int index) const {
  // @@protoc_insertion_point(field_get:apollo.simulation.LogicalCondition.sub_condition)
  return _internal_sub_condition(index);
}
inline ::apollo::simulation::Condition* LogicalCondition::_internal_add_sub_condition() {
  return sub_condition_.Add();
}
inline ::apollo::simulation::Condition* LogicalCondition::add_sub_condition() {
  // @@protoc_insertion_point(field_add:apollo.simulation.LogicalCondition.sub_condition)
  return _internal_add_sub_condition();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::simulation::Condition >&
LogicalCondition::sub_condition() const {
  // @@protoc_insertion_point(field_list:apollo.simulation.LogicalCondition.sub_condition)
  return sub_condition_;
}

// -------------------------------------------------------------------

// SpeedCondition

// optional string name = 1 [default = "speed"];
inline bool SpeedCondition::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SpeedCondition::has_name() const {
  return _internal_has_name();
}
inline void SpeedCondition::clear_name() {
  name_.ClearToDefault(::apollo::simulation::SpeedCondition::_i_give_permission_to_break_this_code_default_name_, GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SpeedCondition::name() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.SpeedCondition.name)
  if (name_.IsDefault(nullptr)) return _i_give_permission_to_break_this_code_default_name_.get();
  return _internal_name();
}
inline void SpeedCondition::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.SpeedCondition.name)
}
inline std::string* SpeedCondition::mutable_name() {
  // @@protoc_insertion_point(field_mutable:apollo.simulation.SpeedCondition.name)
  return _internal_mutable_name();
}
inline const std::string& SpeedCondition::_internal_name() const {
  return name_.Get();
}
inline void SpeedCondition::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, value, GetArena());
}
inline void SpeedCondition::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:apollo.simulation.SpeedCondition.name)
}
inline void SpeedCondition::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:apollo.simulation.SpeedCondition.name)
}
inline void SpeedCondition::set_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:apollo.simulation.SpeedCondition.name)
}
inline std::string* SpeedCondition::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(::apollo::simulation::SpeedCondition::_i_give_permission_to_break_this_code_default_name_, GetArena());
}
inline std::string* SpeedCondition::release_name() {
  // @@protoc_insertion_point(field_release:apollo.simulation.SpeedCondition.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(nullptr, GetArena());
}
inline void SpeedCondition::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(nullptr, name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:apollo.simulation.SpeedCondition.name)
}

// optional double min_speed = 2 [default = -0.5];
inline bool SpeedCondition::_internal_has_min_speed() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SpeedCondition::has_min_speed() const {
  return _internal_has_min_speed();
}
inline void SpeedCondition::clear_min_speed() {
  min_speed_ = -0.5;
  _has_bits_[0] &= ~0x00000004u;
}
inline double SpeedCondition::_internal_min_speed() const {
  return min_speed_;
}
inline double SpeedCondition::min_speed() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.SpeedCondition.min_speed)
  return _internal_min_speed();
}
inline void SpeedCondition::_internal_set_min_speed(double value) {
  _has_bits_[0] |= 0x00000004u;
  min_speed_ = value;
}
inline void SpeedCondition::set_min_speed(double value) {
  _internal_set_min_speed(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.SpeedCondition.min_speed)
}

// optional double max_speed = 3 [default = 1000];
inline bool SpeedCondition::_internal_has_max_speed() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SpeedCondition::has_max_speed() const {
  return _internal_has_max_speed();
}
inline void SpeedCondition::clear_max_speed() {
  max_speed_ = 1000;
  _has_bits_[0] &= ~0x00000008u;
}
inline double SpeedCondition::_internal_max_speed() const {
  return max_speed_;
}
inline double SpeedCondition::max_speed() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.SpeedCondition.max_speed)
  return _internal_max_speed();
}
inline void SpeedCondition::_internal_set_max_speed(double value) {
  _has_bits_[0] |= 0x00000008u;
  max_speed_ = value;
}
inline void SpeedCondition::set_max_speed(double value) {
  _internal_set_max_speed(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.SpeedCondition.max_speed)
}

// optional bool use_score = 4 [default = false];
inline bool SpeedCondition::_internal_has_use_score() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SpeedCondition::has_use_score() const {
  return _internal_has_use_score();
}
inline void SpeedCondition::clear_use_score() {
  use_score_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool SpeedCondition::_internal_use_score() const {
  return use_score_;
}
inline bool SpeedCondition::use_score() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.SpeedCondition.use_score)
  return _internal_use_score();
}
inline void SpeedCondition::_internal_set_use_score(bool value) {
  _has_bits_[0] |= 0x00000002u;
  use_score_ = value;
}
inline void SpeedCondition::set_use_score(bool value) {
  _internal_set_use_score(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.SpeedCondition.use_score)
}

// optional double single_deduction = 5 [default = 0.5];
inline bool SpeedCondition::_internal_has_single_deduction() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool SpeedCondition::has_single_deduction() const {
  return _internal_has_single_deduction();
}
inline void SpeedCondition::clear_single_deduction() {
  single_deduction_ = 0.5;
  _has_bits_[0] &= ~0x00000010u;
}
inline double SpeedCondition::_internal_single_deduction() const {
  return single_deduction_;
}
inline double SpeedCondition::single_deduction() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.SpeedCondition.single_deduction)
  return _internal_single_deduction();
}
inline void SpeedCondition::_internal_set_single_deduction(double value) {
  _has_bits_[0] |= 0x00000010u;
  single_deduction_ = value;
}
inline void SpeedCondition::set_single_deduction(double value) {
  _internal_set_single_deduction(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.SpeedCondition.single_deduction)
}

// -------------------------------------------------------------------

// CentripetalAccelerationCondition

// optional string name = 1 [default = "centripetal_acceleration"];
inline bool CentripetalAccelerationCondition::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CentripetalAccelerationCondition::has_name() const {
  return _internal_has_name();
}
inline void CentripetalAccelerationCondition::clear_name() {
  name_.ClearToDefault(::apollo::simulation::CentripetalAccelerationCondition::_i_give_permission_to_break_this_code_default_name_, GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CentripetalAccelerationCondition::name() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.CentripetalAccelerationCondition.name)
  if (name_.IsDefault(nullptr)) return _i_give_permission_to_break_this_code_default_name_.get();
  return _internal_name();
}
inline void CentripetalAccelerationCondition::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.CentripetalAccelerationCondition.name)
}
inline std::string* CentripetalAccelerationCondition::mutable_name() {
  // @@protoc_insertion_point(field_mutable:apollo.simulation.CentripetalAccelerationCondition.name)
  return _internal_mutable_name();
}
inline const std::string& CentripetalAccelerationCondition::_internal_name() const {
  return name_.Get();
}
inline void CentripetalAccelerationCondition::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, value, GetArena());
}
inline void CentripetalAccelerationCondition::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:apollo.simulation.CentripetalAccelerationCondition.name)
}
inline void CentripetalAccelerationCondition::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:apollo.simulation.CentripetalAccelerationCondition.name)
}
inline void CentripetalAccelerationCondition::set_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:apollo.simulation.CentripetalAccelerationCondition.name)
}
inline std::string* CentripetalAccelerationCondition::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(::apollo::simulation::CentripetalAccelerationCondition::_i_give_permission_to_break_this_code_default_name_, GetArena());
}
inline std::string* CentripetalAccelerationCondition::release_name() {
  // @@protoc_insertion_point(field_release:apollo.simulation.CentripetalAccelerationCondition.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(nullptr, GetArena());
}
inline void CentripetalAccelerationCondition::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(nullptr, name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:apollo.simulation.CentripetalAccelerationCondition.name)
}

// optional double max_centripetal_acceleration = 2 [default = 2];
inline bool CentripetalAccelerationCondition::_internal_has_max_centripetal_acceleration() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CentripetalAccelerationCondition::has_max_centripetal_acceleration() const {
  return _internal_has_max_centripetal_acceleration();
}
inline void CentripetalAccelerationCondition::clear_max_centripetal_acceleration() {
  max_centripetal_acceleration_ = 2;
  _has_bits_[0] &= ~0x00000004u;
}
inline double CentripetalAccelerationCondition::_internal_max_centripetal_acceleration() const {
  return max_centripetal_acceleration_;
}
inline double CentripetalAccelerationCondition::max_centripetal_acceleration() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.CentripetalAccelerationCondition.max_centripetal_acceleration)
  return _internal_max_centripetal_acceleration();
}
inline void CentripetalAccelerationCondition::_internal_set_max_centripetal_acceleration(double value) {
  _has_bits_[0] |= 0x00000004u;
  max_centripetal_acceleration_ = value;
}
inline void CentripetalAccelerationCondition::set_max_centripetal_acceleration(double value) {
  _internal_set_max_centripetal_acceleration(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.CentripetalAccelerationCondition.max_centripetal_acceleration)
}

// optional bool use_score = 3 [default = false];
inline bool CentripetalAccelerationCondition::_internal_has_use_score() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CentripetalAccelerationCondition::has_use_score() const {
  return _internal_has_use_score();
}
inline void CentripetalAccelerationCondition::clear_use_score() {
  use_score_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool CentripetalAccelerationCondition::_internal_use_score() const {
  return use_score_;
}
inline bool CentripetalAccelerationCondition::use_score() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.CentripetalAccelerationCondition.use_score)
  return _internal_use_score();
}
inline void CentripetalAccelerationCondition::_internal_set_use_score(bool value) {
  _has_bits_[0] |= 0x00000002u;
  use_score_ = value;
}
inline void CentripetalAccelerationCondition::set_use_score(bool value) {
  _internal_set_use_score(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.CentripetalAccelerationCondition.use_score)
}

// optional double single_deduction = 4 [default = 0.5];
inline bool CentripetalAccelerationCondition::_internal_has_single_deduction() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CentripetalAccelerationCondition::has_single_deduction() const {
  return _internal_has_single_deduction();
}
inline void CentripetalAccelerationCondition::clear_single_deduction() {
  single_deduction_ = 0.5;
  _has_bits_[0] &= ~0x00000008u;
}
inline double CentripetalAccelerationCondition::_internal_single_deduction() const {
  return single_deduction_;
}
inline double CentripetalAccelerationCondition::single_deduction() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.CentripetalAccelerationCondition.single_deduction)
  return _internal_single_deduction();
}
inline void CentripetalAccelerationCondition::_internal_set_single_deduction(double value) {
  _has_bits_[0] |= 0x00000008u;
  single_deduction_ = value;
}
inline void CentripetalAccelerationCondition::set_single_deduction(double value) {
  _internal_set_single_deduction(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.CentripetalAccelerationCondition.single_deduction)
}

// -------------------------------------------------------------------

// AccelerationCondition

// optional string name = 1 [default = "acceleration"];
inline bool AccelerationCondition::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AccelerationCondition::has_name() const {
  return _internal_has_name();
}
inline void AccelerationCondition::clear_name() {
  name_.ClearToDefault(::apollo::simulation::AccelerationCondition::_i_give_permission_to_break_this_code_default_name_, GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AccelerationCondition::name() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.AccelerationCondition.name)
  if (name_.IsDefault(nullptr)) return _i_give_permission_to_break_this_code_default_name_.get();
  return _internal_name();
}
inline void AccelerationCondition::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.AccelerationCondition.name)
}
inline std::string* AccelerationCondition::mutable_name() {
  // @@protoc_insertion_point(field_mutable:apollo.simulation.AccelerationCondition.name)
  return _internal_mutable_name();
}
inline const std::string& AccelerationCondition::_internal_name() const {
  return name_.Get();
}
inline void AccelerationCondition::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, value, GetArena());
}
inline void AccelerationCondition::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:apollo.simulation.AccelerationCondition.name)
}
inline void AccelerationCondition::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:apollo.simulation.AccelerationCondition.name)
}
inline void AccelerationCondition::set_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:apollo.simulation.AccelerationCondition.name)
}
inline std::string* AccelerationCondition::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(::apollo::simulation::AccelerationCondition::_i_give_permission_to_break_this_code_default_name_, GetArena());
}
inline std::string* AccelerationCondition::release_name() {
  // @@protoc_insertion_point(field_release:apollo.simulation.AccelerationCondition.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(nullptr, GetArena());
}
inline void AccelerationCondition::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(nullptr, name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:apollo.simulation.AccelerationCondition.name)
}

// optional double min_acceleration = 2 [default = -1000];
inline bool AccelerationCondition::_internal_has_min_acceleration() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool AccelerationCondition::has_min_acceleration() const {
  return _internal_has_min_acceleration();
}
inline void AccelerationCondition::clear_min_acceleration() {
  min_acceleration_ = -1000;
  _has_bits_[0] &= ~0x00000004u;
}
inline double AccelerationCondition::_internal_min_acceleration() const {
  return min_acceleration_;
}
inline double AccelerationCondition::min_acceleration() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.AccelerationCondition.min_acceleration)
  return _internal_min_acceleration();
}
inline void AccelerationCondition::_internal_set_min_acceleration(double value) {
  _has_bits_[0] |= 0x00000004u;
  min_acceleration_ = value;
}
inline void AccelerationCondition::set_min_acceleration(double value) {
  _internal_set_min_acceleration(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.AccelerationCondition.min_acceleration)
}

// optional double max_acceleration = 3 [default = 1000];
inline bool AccelerationCondition::_internal_has_max_acceleration() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool AccelerationCondition::has_max_acceleration() const {
  return _internal_has_max_acceleration();
}
inline void AccelerationCondition::clear_max_acceleration() {
  max_acceleration_ = 1000;
  _has_bits_[0] &= ~0x00000008u;
}
inline double AccelerationCondition::_internal_max_acceleration() const {
  return max_acceleration_;
}
inline double AccelerationCondition::max_acceleration() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.AccelerationCondition.max_acceleration)
  return _internal_max_acceleration();
}
inline void AccelerationCondition::_internal_set_max_acceleration(double value) {
  _has_bits_[0] |= 0x00000008u;
  max_acceleration_ = value;
}
inline void AccelerationCondition::set_max_acceleration(double value) {
  _internal_set_max_acceleration(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.AccelerationCondition.max_acceleration)
}

// optional bool use_score = 4 [default = false];
inline bool AccelerationCondition::_internal_has_use_score() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AccelerationCondition::has_use_score() const {
  return _internal_has_use_score();
}
inline void AccelerationCondition::clear_use_score() {
  use_score_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool AccelerationCondition::_internal_use_score() const {
  return use_score_;
}
inline bool AccelerationCondition::use_score() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.AccelerationCondition.use_score)
  return _internal_use_score();
}
inline void AccelerationCondition::_internal_set_use_score(bool value) {
  _has_bits_[0] |= 0x00000002u;
  use_score_ = value;
}
inline void AccelerationCondition::set_use_score(bool value) {
  _internal_set_use_score(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.AccelerationCondition.use_score)
}

// optional double single_deduction = 5 [default = 0.5];
inline bool AccelerationCondition::_internal_has_single_deduction() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool AccelerationCondition::has_single_deduction() const {
  return _internal_has_single_deduction();
}
inline void AccelerationCondition::clear_single_deduction() {
  single_deduction_ = 0.5;
  _has_bits_[0] &= ~0x00000010u;
}
inline double AccelerationCondition::_internal_single_deduction() const {
  return single_deduction_;
}
inline double AccelerationCondition::single_deduction() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.AccelerationCondition.single_deduction)
  return _internal_single_deduction();
}
inline void AccelerationCondition::_internal_set_single_deduction(double value) {
  _has_bits_[0] |= 0x00000010u;
  single_deduction_ = value;
}
inline void AccelerationCondition::set_single_deduction(double value) {
  _internal_set_single_deduction(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.AccelerationCondition.single_deduction)
}

// -------------------------------------------------------------------

// JerkCondition

// optional string name = 1 [default = "jerk"];
inline bool JerkCondition::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool JerkCondition::has_name() const {
  return _internal_has_name();
}
inline void JerkCondition::clear_name() {
  name_.ClearToDefault(::apollo::simulation::JerkCondition::_i_give_permission_to_break_this_code_default_name_, GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& JerkCondition::name() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.JerkCondition.name)
  if (name_.IsDefault(nullptr)) return _i_give_permission_to_break_this_code_default_name_.get();
  return _internal_name();
}
inline void JerkCondition::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.JerkCondition.name)
}
inline std::string* JerkCondition::mutable_name() {
  // @@protoc_insertion_point(field_mutable:apollo.simulation.JerkCondition.name)
  return _internal_mutable_name();
}
inline const std::string& JerkCondition::_internal_name() const {
  return name_.Get();
}
inline void JerkCondition::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, value, GetArena());
}
inline void JerkCondition::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:apollo.simulation.JerkCondition.name)
}
inline void JerkCondition::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:apollo.simulation.JerkCondition.name)
}
inline void JerkCondition::set_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:apollo.simulation.JerkCondition.name)
}
inline std::string* JerkCondition::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(::apollo::simulation::JerkCondition::_i_give_permission_to_break_this_code_default_name_, GetArena());
}
inline std::string* JerkCondition::release_name() {
  // @@protoc_insertion_point(field_release:apollo.simulation.JerkCondition.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(nullptr, GetArena());
}
inline void JerkCondition::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(nullptr, name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:apollo.simulation.JerkCondition.name)
}

// optional double min_jerk = 2 [default = -1000];
inline bool JerkCondition::_internal_has_min_jerk() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool JerkCondition::has_min_jerk() const {
  return _internal_has_min_jerk();
}
inline void JerkCondition::clear_min_jerk() {
  min_jerk_ = -1000;
  _has_bits_[0] &= ~0x00000002u;
}
inline double JerkCondition::_internal_min_jerk() const {
  return min_jerk_;
}
inline double JerkCondition::min_jerk() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.JerkCondition.min_jerk)
  return _internal_min_jerk();
}
inline void JerkCondition::_internal_set_min_jerk(double value) {
  _has_bits_[0] |= 0x00000002u;
  min_jerk_ = value;
}
inline void JerkCondition::set_min_jerk(double value) {
  _internal_set_min_jerk(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.JerkCondition.min_jerk)
}

// optional double max_jerk = 3 [default = 1000];
inline bool JerkCondition::_internal_has_max_jerk() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool JerkCondition::has_max_jerk() const {
  return _internal_has_max_jerk();
}
inline void JerkCondition::clear_max_jerk() {
  max_jerk_ = 1000;
  _has_bits_[0] &= ~0x00000004u;
}
inline double JerkCondition::_internal_max_jerk() const {
  return max_jerk_;
}
inline double JerkCondition::max_jerk() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.JerkCondition.max_jerk)
  return _internal_max_jerk();
}
inline void JerkCondition::_internal_set_max_jerk(double value) {
  _has_bits_[0] |= 0x00000004u;
  max_jerk_ = value;
}
inline void JerkCondition::set_max_jerk(double value) {
  _internal_set_max_jerk(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.JerkCondition.max_jerk)
}

// -------------------------------------------------------------------

// SpinCondition

// optional string name = 1 [default = "spin"];
inline bool SpinCondition::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SpinCondition::has_name() const {
  return _internal_has_name();
}
inline void SpinCondition::clear_name() {
  name_.ClearToDefault(::apollo::simulation::SpinCondition::_i_give_permission_to_break_this_code_default_name_, GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SpinCondition::name() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.SpinCondition.name)
  if (name_.IsDefault(nullptr)) return _i_give_permission_to_break_this_code_default_name_.get();
  return _internal_name();
}
inline void SpinCondition::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.SpinCondition.name)
}
inline std::string* SpinCondition::mutable_name() {
  // @@protoc_insertion_point(field_mutable:apollo.simulation.SpinCondition.name)
  return _internal_mutable_name();
}
inline const std::string& SpinCondition::_internal_name() const {
  return name_.Get();
}
inline void SpinCondition::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, value, GetArena());
}
inline void SpinCondition::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:apollo.simulation.SpinCondition.name)
}
inline void SpinCondition::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:apollo.simulation.SpinCondition.name)
}
inline void SpinCondition::set_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:apollo.simulation.SpinCondition.name)
}
inline std::string* SpinCondition::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(::apollo::simulation::SpinCondition::_i_give_permission_to_break_this_code_default_name_, GetArena());
}
inline std::string* SpinCondition::release_name() {
  // @@protoc_insertion_point(field_release:apollo.simulation.SpinCondition.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(nullptr, GetArena());
}
inline void SpinCondition::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(nullptr, name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:apollo.simulation.SpinCondition.name)
}

// optional double min_spin = 2 [default = -1000];
inline bool SpinCondition::_internal_has_min_spin() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SpinCondition::has_min_spin() const {
  return _internal_has_min_spin();
}
inline void SpinCondition::clear_min_spin() {
  min_spin_ = -1000;
  _has_bits_[0] &= ~0x00000002u;
}
inline double SpinCondition::_internal_min_spin() const {
  return min_spin_;
}
inline double SpinCondition::min_spin() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.SpinCondition.min_spin)
  return _internal_min_spin();
}
inline void SpinCondition::_internal_set_min_spin(double value) {
  _has_bits_[0] |= 0x00000002u;
  min_spin_ = value;
}
inline void SpinCondition::set_min_spin(double value) {
  _internal_set_min_spin(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.SpinCondition.min_spin)
}

// optional double max_spin = 3 [default = 1000];
inline bool SpinCondition::_internal_has_max_spin() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SpinCondition::has_max_spin() const {
  return _internal_has_max_spin();
}
inline void SpinCondition::clear_max_spin() {
  max_spin_ = 1000;
  _has_bits_[0] &= ~0x00000004u;
}
inline double SpinCondition::_internal_max_spin() const {
  return max_spin_;
}
inline double SpinCondition::max_spin() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.SpinCondition.max_spin)
  return _internal_max_spin();
}
inline void SpinCondition::_internal_set_max_spin(double value) {
  _has_bits_[0] |= 0x00000004u;
  max_spin_ = value;
}
inline void SpinCondition::set_max_spin(double value) {
  _internal_set_max_spin(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.SpinCondition.max_spin)
}

// -------------------------------------------------------------------

// ObjectOverlapCondition

// optional string source_object_ids = 1;
inline bool ObjectOverlapCondition::_internal_has_source_object_ids() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ObjectOverlapCondition::has_source_object_ids() const {
  return _internal_has_source_object_ids();
}
inline void ObjectOverlapCondition::clear_source_object_ids() {
  source_object_ids_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ObjectOverlapCondition::source_object_ids() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.ObjectOverlapCondition.source_object_ids)
  return _internal_source_object_ids();
}
inline void ObjectOverlapCondition::set_source_object_ids(const std::string& value) {
  _internal_set_source_object_ids(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.ObjectOverlapCondition.source_object_ids)
}
inline std::string* ObjectOverlapCondition::mutable_source_object_ids() {
  // @@protoc_insertion_point(field_mutable:apollo.simulation.ObjectOverlapCondition.source_object_ids)
  return _internal_mutable_source_object_ids();
}
inline const std::string& ObjectOverlapCondition::_internal_source_object_ids() const {
  return source_object_ids_.Get();
}
inline void ObjectOverlapCondition::_internal_set_source_object_ids(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  source_object_ids_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ObjectOverlapCondition::set_source_object_ids(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  source_object_ids_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:apollo.simulation.ObjectOverlapCondition.source_object_ids)
}
inline void ObjectOverlapCondition::set_source_object_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  source_object_ids_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:apollo.simulation.ObjectOverlapCondition.source_object_ids)
}
inline void ObjectOverlapCondition::set_source_object_ids(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  source_object_ids_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:apollo.simulation.ObjectOverlapCondition.source_object_ids)
}
inline std::string* ObjectOverlapCondition::_internal_mutable_source_object_ids() {
  _has_bits_[0] |= 0x00000001u;
  return source_object_ids_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ObjectOverlapCondition::release_source_object_ids() {
  // @@protoc_insertion_point(field_release:apollo.simulation.ObjectOverlapCondition.source_object_ids)
  if (!_internal_has_source_object_ids()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return source_object_ids_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ObjectOverlapCondition::set_allocated_source_object_ids(std::string* source_object_ids) {
  if (source_object_ids != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  source_object_ids_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), source_object_ids,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:apollo.simulation.ObjectOverlapCondition.source_object_ids)
}

// optional string target_object_ids = 2;
inline bool ObjectOverlapCondition::_internal_has_target_object_ids() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ObjectOverlapCondition::has_target_object_ids() const {
  return _internal_has_target_object_ids();
}
inline void ObjectOverlapCondition::clear_target_object_ids() {
  target_object_ids_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ObjectOverlapCondition::target_object_ids() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.ObjectOverlapCondition.target_object_ids)
  return _internal_target_object_ids();
}
inline void ObjectOverlapCondition::set_target_object_ids(const std::string& value) {
  _internal_set_target_object_ids(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.ObjectOverlapCondition.target_object_ids)
}
inline std::string* ObjectOverlapCondition::mutable_target_object_ids() {
  // @@protoc_insertion_point(field_mutable:apollo.simulation.ObjectOverlapCondition.target_object_ids)
  return _internal_mutable_target_object_ids();
}
inline const std::string& ObjectOverlapCondition::_internal_target_object_ids() const {
  return target_object_ids_.Get();
}
inline void ObjectOverlapCondition::_internal_set_target_object_ids(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  target_object_ids_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ObjectOverlapCondition::set_target_object_ids(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  target_object_ids_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:apollo.simulation.ObjectOverlapCondition.target_object_ids)
}
inline void ObjectOverlapCondition::set_target_object_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  target_object_ids_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:apollo.simulation.ObjectOverlapCondition.target_object_ids)
}
inline void ObjectOverlapCondition::set_target_object_ids(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  target_object_ids_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:apollo.simulation.ObjectOverlapCondition.target_object_ids)
}
inline std::string* ObjectOverlapCondition::_internal_mutable_target_object_ids() {
  _has_bits_[0] |= 0x00000002u;
  return target_object_ids_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ObjectOverlapCondition::release_target_object_ids() {
  // @@protoc_insertion_point(field_release:apollo.simulation.ObjectOverlapCondition.target_object_ids)
  if (!_internal_has_target_object_ids()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return target_object_ids_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ObjectOverlapCondition::set_allocated_target_object_ids(std::string* target_object_ids) {
  if (target_object_ids != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  target_object_ids_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), target_object_ids,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:apollo.simulation.ObjectOverlapCondition.target_object_ids)
}

// optional double distance = 3;
inline bool ObjectOverlapCondition::_internal_has_distance() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ObjectOverlapCondition::has_distance() const {
  return _internal_has_distance();
}
inline void ObjectOverlapCondition::clear_distance() {
  distance_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double ObjectOverlapCondition::_internal_distance() const {
  return distance_;
}
inline double ObjectOverlapCondition::distance() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.ObjectOverlapCondition.distance)
  return _internal_distance();
}
inline void ObjectOverlapCondition::_internal_set_distance(double value) {
  _has_bits_[0] |= 0x00000004u;
  distance_ = value;
}
inline void ObjectOverlapCondition::set_distance(double value) {
  _internal_set_distance(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.ObjectOverlapCondition.distance)
}

// optional .apollo.simulation.ObjectOverlapCondition.DirectionType direction = 4 [default = EXCLUDE_BACK];
inline bool ObjectOverlapCondition::_internal_has_direction() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ObjectOverlapCondition::has_direction() const {
  return _internal_has_direction();
}
inline void ObjectOverlapCondition::clear_direction() {
  direction_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::apollo::simulation::ObjectOverlapCondition_DirectionType ObjectOverlapCondition::_internal_direction() const {
  return static_cast< ::apollo::simulation::ObjectOverlapCondition_DirectionType >(direction_);
}
inline ::apollo::simulation::ObjectOverlapCondition_DirectionType ObjectOverlapCondition::direction() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.ObjectOverlapCondition.direction)
  return _internal_direction();
}
inline void ObjectOverlapCondition::_internal_set_direction(::apollo::simulation::ObjectOverlapCondition_DirectionType value) {
  assert(::apollo::simulation::ObjectOverlapCondition_DirectionType_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  direction_ = value;
}
inline void ObjectOverlapCondition::set_direction(::apollo::simulation::ObjectOverlapCondition_DirectionType value) {
  _internal_set_direction(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.ObjectOverlapCondition.direction)
}

// repeated string ignore_object_ids = 5;
inline int ObjectOverlapCondition::_internal_ignore_object_ids_size() const {
  return ignore_object_ids_.size();
}
inline int ObjectOverlapCondition::ignore_object_ids_size() const {
  return _internal_ignore_object_ids_size();
}
inline void ObjectOverlapCondition::clear_ignore_object_ids() {
  ignore_object_ids_.Clear();
}
inline std::string* ObjectOverlapCondition::add_ignore_object_ids() {
  // @@protoc_insertion_point(field_add_mutable:apollo.simulation.ObjectOverlapCondition.ignore_object_ids)
  return _internal_add_ignore_object_ids();
}
inline const std::string& ObjectOverlapCondition::_internal_ignore_object_ids(int index) const {
  return ignore_object_ids_.Get(index);
}
inline const std::string& ObjectOverlapCondition::ignore_object_ids(int index) const {
  // @@protoc_insertion_point(field_get:apollo.simulation.ObjectOverlapCondition.ignore_object_ids)
  return _internal_ignore_object_ids(index);
}
inline std::string* ObjectOverlapCondition::mutable_ignore_object_ids(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.simulation.ObjectOverlapCondition.ignore_object_ids)
  return ignore_object_ids_.Mutable(index);
}
inline void ObjectOverlapCondition::set_ignore_object_ids(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:apollo.simulation.ObjectOverlapCondition.ignore_object_ids)
  ignore_object_ids_.Mutable(index)->assign(value);
}
inline void ObjectOverlapCondition::set_ignore_object_ids(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:apollo.simulation.ObjectOverlapCondition.ignore_object_ids)
  ignore_object_ids_.Mutable(index)->assign(std::move(value));
}
inline void ObjectOverlapCondition::set_ignore_object_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  ignore_object_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:apollo.simulation.ObjectOverlapCondition.ignore_object_ids)
}
inline void ObjectOverlapCondition::set_ignore_object_ids(int index, const char* value, size_t size) {
  ignore_object_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:apollo.simulation.ObjectOverlapCondition.ignore_object_ids)
}
inline std::string* ObjectOverlapCondition::_internal_add_ignore_object_ids() {
  return ignore_object_ids_.Add();
}
inline void ObjectOverlapCondition::add_ignore_object_ids(const std::string& value) {
  ignore_object_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:apollo.simulation.ObjectOverlapCondition.ignore_object_ids)
}
inline void ObjectOverlapCondition::add_ignore_object_ids(std::string&& value) {
  ignore_object_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:apollo.simulation.ObjectOverlapCondition.ignore_object_ids)
}
inline void ObjectOverlapCondition::add_ignore_object_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  ignore_object_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:apollo.simulation.ObjectOverlapCondition.ignore_object_ids)
}
inline void ObjectOverlapCondition::add_ignore_object_ids(const char* value, size_t size) {
  ignore_object_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:apollo.simulation.ObjectOverlapCondition.ignore_object_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ObjectOverlapCondition::ignore_object_ids() const {
  // @@protoc_insertion_point(field_list:apollo.simulation.ObjectOverlapCondition.ignore_object_ids)
  return ignore_object_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ObjectOverlapCondition::mutable_ignore_object_ids() {
  // @@protoc_insertion_point(field_mutable_list:apollo.simulation.ObjectOverlapCondition.ignore_object_ids)
  return &ignore_object_ids_;
}

// optional bool use_score = 6 [default = false];
inline bool ObjectOverlapCondition::_internal_has_use_score() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ObjectOverlapCondition::has_use_score() const {
  return _internal_has_use_score();
}
inline void ObjectOverlapCondition::clear_use_score() {
  use_score_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool ObjectOverlapCondition::_internal_use_score() const {
  return use_score_;
}
inline bool ObjectOverlapCondition::use_score() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.ObjectOverlapCondition.use_score)
  return _internal_use_score();
}
inline void ObjectOverlapCondition::_internal_set_use_score(bool value) {
  _has_bits_[0] |= 0x00000010u;
  use_score_ = value;
}
inline void ObjectOverlapCondition::set_use_score(bool value) {
  _internal_set_use_score(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.ObjectOverlapCondition.use_score)
}

// -------------------------------------------------------------------

// RegionOverlapCondition

// optional string object_ids = 1;
inline bool RegionOverlapCondition::_internal_has_object_ids() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RegionOverlapCondition::has_object_ids() const {
  return _internal_has_object_ids();
}
inline void RegionOverlapCondition::clear_object_ids() {
  object_ids_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RegionOverlapCondition::object_ids() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.RegionOverlapCondition.object_ids)
  return _internal_object_ids();
}
inline void RegionOverlapCondition::set_object_ids(const std::string& value) {
  _internal_set_object_ids(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.RegionOverlapCondition.object_ids)
}
inline std::string* RegionOverlapCondition::mutable_object_ids() {
  // @@protoc_insertion_point(field_mutable:apollo.simulation.RegionOverlapCondition.object_ids)
  return _internal_mutable_object_ids();
}
inline const std::string& RegionOverlapCondition::_internal_object_ids() const {
  return object_ids_.Get();
}
inline void RegionOverlapCondition::_internal_set_object_ids(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  object_ids_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void RegionOverlapCondition::set_object_ids(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  object_ids_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:apollo.simulation.RegionOverlapCondition.object_ids)
}
inline void RegionOverlapCondition::set_object_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  object_ids_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:apollo.simulation.RegionOverlapCondition.object_ids)
}
inline void RegionOverlapCondition::set_object_ids(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  object_ids_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:apollo.simulation.RegionOverlapCondition.object_ids)
}
inline std::string* RegionOverlapCondition::_internal_mutable_object_ids() {
  _has_bits_[0] |= 0x00000001u;
  return object_ids_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* RegionOverlapCondition::release_object_ids() {
  // @@protoc_insertion_point(field_release:apollo.simulation.RegionOverlapCondition.object_ids)
  if (!_internal_has_object_ids()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return object_ids_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RegionOverlapCondition::set_allocated_object_ids(std::string* object_ids) {
  if (object_ids != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  object_ids_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), object_ids,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:apollo.simulation.RegionOverlapCondition.object_ids)
}

// repeated double region_corner_xy = 2 [packed = true];
inline int RegionOverlapCondition::_internal_region_corner_xy_size() const {
  return region_corner_xy_.size();
}
inline int RegionOverlapCondition::region_corner_xy_size() const {
  return _internal_region_corner_xy_size();
}
inline void RegionOverlapCondition::clear_region_corner_xy() {
  region_corner_xy_.Clear();
}
inline double RegionOverlapCondition::_internal_region_corner_xy(int index) const {
  return region_corner_xy_.Get(index);
}
inline double RegionOverlapCondition::region_corner_xy(int index) const {
  // @@protoc_insertion_point(field_get:apollo.simulation.RegionOverlapCondition.region_corner_xy)
  return _internal_region_corner_xy(index);
}
inline void RegionOverlapCondition::set_region_corner_xy(int index, double value) {
  region_corner_xy_.Set(index, value);
  // @@protoc_insertion_point(field_set:apollo.simulation.RegionOverlapCondition.region_corner_xy)
}
inline void RegionOverlapCondition::_internal_add_region_corner_xy(double value) {
  region_corner_xy_.Add(value);
}
inline void RegionOverlapCondition::add_region_corner_xy(double value) {
  _internal_add_region_corner_xy(value);
  // @@protoc_insertion_point(field_add:apollo.simulation.RegionOverlapCondition.region_corner_xy)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
RegionOverlapCondition::_internal_region_corner_xy() const {
  return region_corner_xy_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
RegionOverlapCondition::region_corner_xy() const {
  // @@protoc_insertion_point(field_list:apollo.simulation.RegionOverlapCondition.region_corner_xy)
  return _internal_region_corner_xy();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
RegionOverlapCondition::_internal_mutable_region_corner_xy() {
  return &region_corner_xy_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
RegionOverlapCondition::mutable_region_corner_xy() {
  // @@protoc_insertion_point(field_mutable_list:apollo.simulation.RegionOverlapCondition.region_corner_xy)
  return _internal_mutable_region_corner_xy();
}

// optional bool require_fully_contain = 3;
inline bool RegionOverlapCondition::_internal_has_require_fully_contain() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RegionOverlapCondition::has_require_fully_contain() const {
  return _internal_has_require_fully_contain();
}
inline void RegionOverlapCondition::clear_require_fully_contain() {
  require_fully_contain_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool RegionOverlapCondition::_internal_require_fully_contain() const {
  return require_fully_contain_;
}
inline bool RegionOverlapCondition::require_fully_contain() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.RegionOverlapCondition.require_fully_contain)
  return _internal_require_fully_contain();
}
inline void RegionOverlapCondition::_internal_set_require_fully_contain(bool value) {
  _has_bits_[0] |= 0x00000004u;
  require_fully_contain_ = value;
}
inline void RegionOverlapCondition::set_require_fully_contain(bool value) {
  _internal_set_require_fully_contain(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.RegionOverlapCondition.require_fully_contain)
}

// optional double heading = 4;
inline bool RegionOverlapCondition::_internal_has_heading() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RegionOverlapCondition::has_heading() const {
  return _internal_has_heading();
}
inline void RegionOverlapCondition::clear_heading() {
  heading_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double RegionOverlapCondition::_internal_heading() const {
  return heading_;
}
inline double RegionOverlapCondition::heading() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.RegionOverlapCondition.heading)
  return _internal_heading();
}
inline void RegionOverlapCondition::_internal_set_heading(double value) {
  _has_bits_[0] |= 0x00000002u;
  heading_ = value;
}
inline void RegionOverlapCondition::set_heading(double value) {
  _internal_set_heading(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.RegionOverlapCondition.heading)
}

// optional bool use_score = 5 [default = false];
inline bool RegionOverlapCondition::_internal_has_use_score() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool RegionOverlapCondition::has_use_score() const {
  return _internal_has_use_score();
}
inline void RegionOverlapCondition::clear_use_score() {
  use_score_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool RegionOverlapCondition::_internal_use_score() const {
  return use_score_;
}
inline bool RegionOverlapCondition::use_score() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.RegionOverlapCondition.use_score)
  return _internal_use_score();
}
inline void RegionOverlapCondition::_internal_set_use_score(bool value) {
  _has_bits_[0] |= 0x00000008u;
  use_score_ = value;
}
inline void RegionOverlapCondition::set_use_score(bool value) {
  _internal_set_use_score(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.RegionOverlapCondition.use_score)
}

// -------------------------------------------------------------------

// RegionOverlapLWCondition

// optional string object_ids = 1;
inline bool RegionOverlapLWCondition::_internal_has_object_ids() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RegionOverlapLWCondition::has_object_ids() const {
  return _internal_has_object_ids();
}
inline void RegionOverlapLWCondition::clear_object_ids() {
  object_ids_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RegionOverlapLWCondition::object_ids() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.RegionOverlapLWCondition.object_ids)
  return _internal_object_ids();
}
inline void RegionOverlapLWCondition::set_object_ids(const std::string& value) {
  _internal_set_object_ids(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.RegionOverlapLWCondition.object_ids)
}
inline std::string* RegionOverlapLWCondition::mutable_object_ids() {
  // @@protoc_insertion_point(field_mutable:apollo.simulation.RegionOverlapLWCondition.object_ids)
  return _internal_mutable_object_ids();
}
inline const std::string& RegionOverlapLWCondition::_internal_object_ids() const {
  return object_ids_.Get();
}
inline void RegionOverlapLWCondition::_internal_set_object_ids(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  object_ids_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void RegionOverlapLWCondition::set_object_ids(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  object_ids_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:apollo.simulation.RegionOverlapLWCondition.object_ids)
}
inline void RegionOverlapLWCondition::set_object_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  object_ids_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:apollo.simulation.RegionOverlapLWCondition.object_ids)
}
inline void RegionOverlapLWCondition::set_object_ids(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  object_ids_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:apollo.simulation.RegionOverlapLWCondition.object_ids)
}
inline std::string* RegionOverlapLWCondition::_internal_mutable_object_ids() {
  _has_bits_[0] |= 0x00000001u;
  return object_ids_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* RegionOverlapLWCondition::release_object_ids() {
  // @@protoc_insertion_point(field_release:apollo.simulation.RegionOverlapLWCondition.object_ids)
  if (!_internal_has_object_ids()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return object_ids_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RegionOverlapLWCondition::set_allocated_object_ids(std::string* object_ids) {
  if (object_ids != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  object_ids_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), object_ids,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:apollo.simulation.RegionOverlapLWCondition.object_ids)
}

// optional double x = 2;
inline bool RegionOverlapLWCondition::_internal_has_x() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RegionOverlapLWCondition::has_x() const {
  return _internal_has_x();
}
inline void RegionOverlapLWCondition::clear_x() {
  x_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double RegionOverlapLWCondition::_internal_x() const {
  return x_;
}
inline double RegionOverlapLWCondition::x() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.RegionOverlapLWCondition.x)
  return _internal_x();
}
inline void RegionOverlapLWCondition::_internal_set_x(double value) {
  _has_bits_[0] |= 0x00000002u;
  x_ = value;
}
inline void RegionOverlapLWCondition::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.RegionOverlapLWCondition.x)
}

// optional double y = 3;
inline bool RegionOverlapLWCondition::_internal_has_y() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RegionOverlapLWCondition::has_y() const {
  return _internal_has_y();
}
inline void RegionOverlapLWCondition::clear_y() {
  y_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double RegionOverlapLWCondition::_internal_y() const {
  return y_;
}
inline double RegionOverlapLWCondition::y() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.RegionOverlapLWCondition.y)
  return _internal_y();
}
inline void RegionOverlapLWCondition::_internal_set_y(double value) {
  _has_bits_[0] |= 0x00000004u;
  y_ = value;
}
inline void RegionOverlapLWCondition::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.RegionOverlapLWCondition.y)
}

// optional double length = 4;
inline bool RegionOverlapLWCondition::_internal_has_length() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool RegionOverlapLWCondition::has_length() const {
  return _internal_has_length();
}
inline void RegionOverlapLWCondition::clear_length() {
  length_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline double RegionOverlapLWCondition::_internal_length() const {
  return length_;
}
inline double RegionOverlapLWCondition::length() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.RegionOverlapLWCondition.length)
  return _internal_length();
}
inline void RegionOverlapLWCondition::_internal_set_length(double value) {
  _has_bits_[0] |= 0x00000008u;
  length_ = value;
}
inline void RegionOverlapLWCondition::set_length(double value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.RegionOverlapLWCondition.length)
}

// optional double width = 5;
inline bool RegionOverlapLWCondition::_internal_has_width() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool RegionOverlapLWCondition::has_width() const {
  return _internal_has_width();
}
inline void RegionOverlapLWCondition::clear_width() {
  width_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline double RegionOverlapLWCondition::_internal_width() const {
  return width_;
}
inline double RegionOverlapLWCondition::width() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.RegionOverlapLWCondition.width)
  return _internal_width();
}
inline void RegionOverlapLWCondition::_internal_set_width(double value) {
  _has_bits_[0] |= 0x00000010u;
  width_ = value;
}
inline void RegionOverlapLWCondition::set_width(double value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.RegionOverlapLWCondition.width)
}

// optional bool require_fully_contain = 6;
inline bool RegionOverlapLWCondition::_internal_has_require_fully_contain() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool RegionOverlapLWCondition::has_require_fully_contain() const {
  return _internal_has_require_fully_contain();
}
inline void RegionOverlapLWCondition::clear_require_fully_contain() {
  require_fully_contain_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool RegionOverlapLWCondition::_internal_require_fully_contain() const {
  return require_fully_contain_;
}
inline bool RegionOverlapLWCondition::require_fully_contain() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.RegionOverlapLWCondition.require_fully_contain)
  return _internal_require_fully_contain();
}
inline void RegionOverlapLWCondition::_internal_set_require_fully_contain(bool value) {
  _has_bits_[0] |= 0x00000020u;
  require_fully_contain_ = value;
}
inline void RegionOverlapLWCondition::set_require_fully_contain(bool value) {
  _internal_set_require_fully_contain(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.RegionOverlapLWCondition.require_fully_contain)
}

// optional bool use_score = 7 [default = false];
inline bool RegionOverlapLWCondition::_internal_has_use_score() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool RegionOverlapLWCondition::has_use_score() const {
  return _internal_has_use_score();
}
inline void RegionOverlapLWCondition::clear_use_score() {
  use_score_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool RegionOverlapLWCondition::_internal_use_score() const {
  return use_score_;
}
inline bool RegionOverlapLWCondition::use_score() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.RegionOverlapLWCondition.use_score)
  return _internal_use_score();
}
inline void RegionOverlapLWCondition::_internal_set_use_score(bool value) {
  _has_bits_[0] |= 0x00000040u;
  use_score_ = value;
}
inline void RegionOverlapLWCondition::set_use_score(bool value) {
  _internal_set_use_score(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.RegionOverlapLWCondition.use_score)
}

// -------------------------------------------------------------------

// OnRoadCondition

// optional bool use_road_boundary = 1 [default = false];
inline bool OnRoadCondition::_internal_has_use_road_boundary() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool OnRoadCondition::has_use_road_boundary() const {
  return _internal_has_use_road_boundary();
}
inline void OnRoadCondition::clear_use_road_boundary() {
  use_road_boundary_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool OnRoadCondition::_internal_use_road_boundary() const {
  return use_road_boundary_;
}
inline bool OnRoadCondition::use_road_boundary() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.OnRoadCondition.use_road_boundary)
  return _internal_use_road_boundary();
}
inline void OnRoadCondition::_internal_set_use_road_boundary(bool value) {
  _has_bits_[0] |= 0x00000001u;
  use_road_boundary_ = value;
}
inline void OnRoadCondition::set_use_road_boundary(bool value) {
  _internal_set_use_road_boundary(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.OnRoadCondition.use_road_boundary)
}

// optional bool use_score = 2 [default = false];
inline bool OnRoadCondition::_internal_has_use_score() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool OnRoadCondition::has_use_score() const {
  return _internal_has_use_score();
}
inline void OnRoadCondition::clear_use_score() {
  use_score_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool OnRoadCondition::_internal_use_score() const {
  return use_score_;
}
inline bool OnRoadCondition::use_score() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.OnRoadCondition.use_score)
  return _internal_use_score();
}
inline void OnRoadCondition::_internal_set_use_score(bool value) {
  _has_bits_[0] |= 0x00000002u;
  use_score_ = value;
}
inline void OnRoadCondition::set_use_score(bool value) {
  _internal_set_use_score(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.OnRoadCondition.use_score)
}

// -------------------------------------------------------------------

// RunRedLightCondition

// optional bool use_score = 1 [default = false];
inline bool RunRedLightCondition::_internal_has_use_score() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RunRedLightCondition::has_use_score() const {
  return _internal_has_use_score();
}
inline void RunRedLightCondition::clear_use_score() {
  use_score_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool RunRedLightCondition::_internal_use_score() const {
  return use_score_;
}
inline bool RunRedLightCondition::use_score() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.RunRedLightCondition.use_score)
  return _internal_use_score();
}
inline void RunRedLightCondition::_internal_set_use_score(bool value) {
  _has_bits_[0] |= 0x00000001u;
  use_score_ = value;
}
inline void RunRedLightCondition::set_use_score(bool value) {
  _internal_set_use_score(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.RunRedLightCondition.use_score)
}

// -------------------------------------------------------------------

// RedLightStopCondition

// optional double min_distance = 1 [default = 2];
inline bool RedLightStopCondition::_internal_has_min_distance() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RedLightStopCondition::has_min_distance() const {
  return _internal_has_min_distance();
}
inline void RedLightStopCondition::clear_min_distance() {
  min_distance_ = 2;
  _has_bits_[0] &= ~0x00000002u;
}
inline double RedLightStopCondition::_internal_min_distance() const {
  return min_distance_;
}
inline double RedLightStopCondition::min_distance() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.RedLightStopCondition.min_distance)
  return _internal_min_distance();
}
inline void RedLightStopCondition::_internal_set_min_distance(double value) {
  _has_bits_[0] |= 0x00000002u;
  min_distance_ = value;
}
inline void RedLightStopCondition::set_min_distance(double value) {
  _internal_set_min_distance(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.RedLightStopCondition.min_distance)
}

// optional double max_distance = 2 [default = 2.2];
inline bool RedLightStopCondition::_internal_has_max_distance() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RedLightStopCondition::has_max_distance() const {
  return _internal_has_max_distance();
}
inline void RedLightStopCondition::clear_max_distance() {
  max_distance_ = 2.2;
  _has_bits_[0] &= ~0x00000004u;
}
inline double RedLightStopCondition::_internal_max_distance() const {
  return max_distance_;
}
inline double RedLightStopCondition::max_distance() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.RedLightStopCondition.max_distance)
  return _internal_max_distance();
}
inline void RedLightStopCondition::_internal_set_max_distance(double value) {
  _has_bits_[0] |= 0x00000004u;
  max_distance_ = value;
}
inline void RedLightStopCondition::set_max_distance(double value) {
  _internal_set_max_distance(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.RedLightStopCondition.max_distance)
}

// optional bool use_score = 3 [default = false];
inline bool RedLightStopCondition::_internal_has_use_score() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RedLightStopCondition::has_use_score() const {
  return _internal_has_use_score();
}
inline void RedLightStopCondition::clear_use_score() {
  use_score_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool RedLightStopCondition::_internal_use_score() const {
  return use_score_;
}
inline bool RedLightStopCondition::use_score() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.RedLightStopCondition.use_score)
  return _internal_use_score();
}
inline void RedLightStopCondition::_internal_set_use_score(bool value) {
  _has_bits_[0] |= 0x00000001u;
  use_score_ = value;
}
inline void RedLightStopCondition::set_use_score(bool value) {
  _internal_set_use_score(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.RedLightStopCondition.use_score)
}

// optional double single_deduction = 4 [default = 5];
inline bool RedLightStopCondition::_internal_has_single_deduction() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool RedLightStopCondition::has_single_deduction() const {
  return _internal_has_single_deduction();
}
inline void RedLightStopCondition::clear_single_deduction() {
  single_deduction_ = 5;
  _has_bits_[0] &= ~0x00000008u;
}
inline double RedLightStopCondition::_internal_single_deduction() const {
  return single_deduction_;
}
inline double RedLightStopCondition::single_deduction() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.RedLightStopCondition.single_deduction)
  return _internal_single_deduction();
}
inline void RedLightStopCondition::_internal_set_single_deduction(double value) {
  _has_bits_[0] |= 0x00000008u;
  single_deduction_ = value;
}
inline void RedLightStopCondition::set_single_deduction(double value) {
  _internal_set_single_deduction(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.RedLightStopCondition.single_deduction)
}

// -------------------------------------------------------------------

// ChangeLaneAtJunctionCondition

// -------------------------------------------------------------------

// RoutingCondition

// -------------------------------------------------------------------

// CrosswalkYieldCondition

// -------------------------------------------------------------------

// CrosswalkStopCondition

// optional double min_distance = 1 [default = 2.2];
inline bool CrosswalkStopCondition::_internal_has_min_distance() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CrosswalkStopCondition::has_min_distance() const {
  return _internal_has_min_distance();
}
inline void CrosswalkStopCondition::clear_min_distance() {
  min_distance_ = 2.2;
  _has_bits_[0] &= ~0x00000002u;
}
inline double CrosswalkStopCondition::_internal_min_distance() const {
  return min_distance_;
}
inline double CrosswalkStopCondition::min_distance() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.CrosswalkStopCondition.min_distance)
  return _internal_min_distance();
}
inline void CrosswalkStopCondition::_internal_set_min_distance(double value) {
  _has_bits_[0] |= 0x00000002u;
  min_distance_ = value;
}
inline void CrosswalkStopCondition::set_min_distance(double value) {
  _internal_set_min_distance(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.CrosswalkStopCondition.min_distance)
}

// optional double max_distance = 2 [default = 2.7];
inline bool CrosswalkStopCondition::_internal_has_max_distance() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CrosswalkStopCondition::has_max_distance() const {
  return _internal_has_max_distance();
}
inline void CrosswalkStopCondition::clear_max_distance() {
  max_distance_ = 2.7;
  _has_bits_[0] &= ~0x00000004u;
}
inline double CrosswalkStopCondition::_internal_max_distance() const {
  return max_distance_;
}
inline double CrosswalkStopCondition::max_distance() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.CrosswalkStopCondition.max_distance)
  return _internal_max_distance();
}
inline void CrosswalkStopCondition::_internal_set_max_distance(double value) {
  _has_bits_[0] |= 0x00000004u;
  max_distance_ = value;
}
inline void CrosswalkStopCondition::set_max_distance(double value) {
  _internal_set_max_distance(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.CrosswalkStopCondition.max_distance)
}

// optional bool use_score = 3 [default = false];
inline bool CrosswalkStopCondition::_internal_has_use_score() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CrosswalkStopCondition::has_use_score() const {
  return _internal_has_use_score();
}
inline void CrosswalkStopCondition::clear_use_score() {
  use_score_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool CrosswalkStopCondition::_internal_use_score() const {
  return use_score_;
}
inline bool CrosswalkStopCondition::use_score() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.CrosswalkStopCondition.use_score)
  return _internal_use_score();
}
inline void CrosswalkStopCondition::_internal_set_use_score(bool value) {
  _has_bits_[0] |= 0x00000001u;
  use_score_ = value;
}
inline void CrosswalkStopCondition::set_use_score(bool value) {
  _internal_set_use_score(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.CrosswalkStopCondition.use_score)
}

// optional double single_deduction = 4 [default = 5];
inline bool CrosswalkStopCondition::_internal_has_single_deduction() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CrosswalkStopCondition::has_single_deduction() const {
  return _internal_has_single_deduction();
}
inline void CrosswalkStopCondition::clear_single_deduction() {
  single_deduction_ = 5;
  _has_bits_[0] &= ~0x00000008u;
}
inline double CrosswalkStopCondition::_internal_single_deduction() const {
  return single_deduction_;
}
inline double CrosswalkStopCondition::single_deduction() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.CrosswalkStopCondition.single_deduction)
  return _internal_single_deduction();
}
inline void CrosswalkStopCondition::_internal_set_single_deduction(double value) {
  _has_bits_[0] |= 0x00000008u;
  single_deduction_ = value;
}
inline void CrosswalkStopCondition::set_single_deduction(double value) {
  _internal_set_single_deduction(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.CrosswalkStopCondition.single_deduction)
}

// -------------------------------------------------------------------

// AbnormalStopCondition

// optional double duration = 1 [default = 5];
inline bool AbnormalStopCondition::_internal_has_duration() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool AbnormalStopCondition::has_duration() const {
  return _internal_has_duration();
}
inline void AbnormalStopCondition::clear_duration() {
  duration_ = 5;
  _has_bits_[0] &= ~0x00000004u;
}
inline double AbnormalStopCondition::_internal_duration() const {
  return duration_;
}
inline double AbnormalStopCondition::duration() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.AbnormalStopCondition.duration)
  return _internal_duration();
}
inline void AbnormalStopCondition::_internal_set_duration(double value) {
  _has_bits_[0] |= 0x00000004u;
  duration_ = value;
}
inline void AbnormalStopCondition::set_duration(double value) {
  _internal_set_duration(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.AbnormalStopCondition.duration)
}

// optional double distance = 2 [default = 10];
inline bool AbnormalStopCondition::_internal_has_distance() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool AbnormalStopCondition::has_distance() const {
  return _internal_has_distance();
}
inline void AbnormalStopCondition::clear_distance() {
  distance_ = 10;
  _has_bits_[0] &= ~0x00000008u;
}
inline double AbnormalStopCondition::_internal_distance() const {
  return distance_;
}
inline double AbnormalStopCondition::distance() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.AbnormalStopCondition.distance)
  return _internal_distance();
}
inline void AbnormalStopCondition::_internal_set_distance(double value) {
  _has_bits_[0] |= 0x00000008u;
  distance_ = value;
}
inline void AbnormalStopCondition::set_distance(double value) {
  _internal_set_distance(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.AbnormalStopCondition.distance)
}

// optional double x = 3;
inline bool AbnormalStopCondition::_internal_has_x() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AbnormalStopCondition::has_x() const {
  return _internal_has_x();
}
inline void AbnormalStopCondition::clear_x() {
  x_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double AbnormalStopCondition::_internal_x() const {
  return x_;
}
inline double AbnormalStopCondition::x() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.AbnormalStopCondition.x)
  return _internal_x();
}
inline void AbnormalStopCondition::_internal_set_x(double value) {
  _has_bits_[0] |= 0x00000001u;
  x_ = value;
}
inline void AbnormalStopCondition::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.AbnormalStopCondition.x)
}

// optional double y = 4;
inline bool AbnormalStopCondition::_internal_has_y() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AbnormalStopCondition::has_y() const {
  return _internal_has_y();
}
inline void AbnormalStopCondition::clear_y() {
  y_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double AbnormalStopCondition::_internal_y() const {
  return y_;
}
inline double AbnormalStopCondition::y() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.AbnormalStopCondition.y)
  return _internal_y();
}
inline void AbnormalStopCondition::_internal_set_y(double value) {
  _has_bits_[0] |= 0x00000002u;
  y_ = value;
}
inline void AbnormalStopCondition::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.AbnormalStopCondition.y)
}

// -------------------------------------------------------------------

// BrakeTapCondition

// optional double min_duration = 1 [default = 1];
inline bool BrakeTapCondition::_internal_has_min_duration() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BrakeTapCondition::has_min_duration() const {
  return _internal_has_min_duration();
}
inline void BrakeTapCondition::clear_min_duration() {
  min_duration_ = 1;
  _has_bits_[0] &= ~0x00000001u;
}
inline double BrakeTapCondition::_internal_min_duration() const {
  return min_duration_;
}
inline double BrakeTapCondition::min_duration() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.BrakeTapCondition.min_duration)
  return _internal_min_duration();
}
inline void BrakeTapCondition::_internal_set_min_duration(double value) {
  _has_bits_[0] |= 0x00000001u;
  min_duration_ = value;
}
inline void BrakeTapCondition::set_min_duration(double value) {
  _internal_set_min_duration(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.BrakeTapCondition.min_duration)
}

// optional double max_duration = 2 [default = 4];
inline bool BrakeTapCondition::_internal_has_max_duration() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BrakeTapCondition::has_max_duration() const {
  return _internal_has_max_duration();
}
inline void BrakeTapCondition::clear_max_duration() {
  max_duration_ = 4;
  _has_bits_[0] &= ~0x00000002u;
}
inline double BrakeTapCondition::_internal_max_duration() const {
  return max_duration_;
}
inline double BrakeTapCondition::max_duration() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.BrakeTapCondition.max_duration)
  return _internal_max_duration();
}
inline void BrakeTapCondition::_internal_set_max_duration(double value) {
  _has_bits_[0] |= 0x00000002u;
  max_duration_ = value;
}
inline void BrakeTapCondition::set_max_duration(double value) {
  _internal_set_max_duration(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.BrakeTapCondition.max_duration)
}

// -------------------------------------------------------------------

// RunStopSignCondition

// optional double distance = 1 [default = 2];
inline bool RunStopSignCondition::_internal_has_distance() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RunStopSignCondition::has_distance() const {
  return _internal_has_distance();
}
inline void RunStopSignCondition::clear_distance() {
  distance_ = 2;
  _has_bits_[0] &= ~0x00000001u;
}
inline double RunStopSignCondition::_internal_distance() const {
  return distance_;
}
inline double RunStopSignCondition::distance() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.RunStopSignCondition.distance)
  return _internal_distance();
}
inline void RunStopSignCondition::_internal_set_distance(double value) {
  _has_bits_[0] |= 0x00000001u;
  distance_ = value;
}
inline void RunStopSignCondition::set_distance(double value) {
  _internal_set_distance(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.RunStopSignCondition.distance)
}

// -------------------------------------------------------------------

// CheckpointCondition

// repeated .apollo.simulation.Condition checkpoint = 1;
inline int CheckpointCondition::_internal_checkpoint_size() const {
  return checkpoint_.size();
}
inline int CheckpointCondition::checkpoint_size() const {
  return _internal_checkpoint_size();
}
inline void CheckpointCondition::clear_checkpoint() {
  checkpoint_.Clear();
}
inline ::apollo::simulation::Condition* CheckpointCondition::mutable_checkpoint(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.simulation.CheckpointCondition.checkpoint)
  return checkpoint_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::simulation::Condition >*
CheckpointCondition::mutable_checkpoint() {
  // @@protoc_insertion_point(field_mutable_list:apollo.simulation.CheckpointCondition.checkpoint)
  return &checkpoint_;
}
inline const ::apollo::simulation::Condition& CheckpointCondition::_internal_checkpoint(int index) const {
  return checkpoint_.Get(index);
}
inline const ::apollo::simulation::Condition& CheckpointCondition::checkpoint(int index) const {
  // @@protoc_insertion_point(field_get:apollo.simulation.CheckpointCondition.checkpoint)
  return _internal_checkpoint(index);
}
inline ::apollo::simulation::Condition* CheckpointCondition::_internal_add_checkpoint() {
  return checkpoint_.Add();
}
inline ::apollo::simulation::Condition* CheckpointCondition::add_checkpoint() {
  // @@protoc_insertion_point(field_add:apollo.simulation.CheckpointCondition.checkpoint)
  return _internal_add_checkpoint();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::simulation::Condition >&
CheckpointCondition::checkpoint() const {
  // @@protoc_insertion_point(field_list:apollo.simulation.CheckpointCondition.checkpoint)
  return checkpoint_;
}

// -------------------------------------------------------------------

// DistToEndCondition

// -------------------------------------------------------------------

// DistToLaneCenterCondition

// -------------------------------------------------------------------

// TimeLimitCondition

// optional double timeout = 1;
inline bool TimeLimitCondition::_internal_has_timeout() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TimeLimitCondition::has_timeout() const {
  return _internal_has_timeout();
}
inline void TimeLimitCondition::clear_timeout() {
  timeout_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double TimeLimitCondition::_internal_timeout() const {
  return timeout_;
}
inline double TimeLimitCondition::timeout() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.TimeLimitCondition.timeout)
  return _internal_timeout();
}
inline void TimeLimitCondition::_internal_set_timeout(double value) {
  _has_bits_[0] |= 0x00000001u;
  timeout_ = value;
}
inline void TimeLimitCondition::set_timeout(double value) {
  _internal_set_timeout(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.TimeLimitCondition.timeout)
}

// optional bool use_score = 2 [default = false];
inline bool TimeLimitCondition::_internal_has_use_score() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TimeLimitCondition::has_use_score() const {
  return _internal_has_use_score();
}
inline void TimeLimitCondition::clear_use_score() {
  use_score_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool TimeLimitCondition::_internal_use_score() const {
  return use_score_;
}
inline bool TimeLimitCondition::use_score() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.TimeLimitCondition.use_score)
  return _internal_use_score();
}
inline void TimeLimitCondition::_internal_set_use_score(bool value) {
  _has_bits_[0] |= 0x00000002u;
  use_score_ = value;
}
inline void TimeLimitCondition::set_use_score(bool value) {
  _internal_set_use_score(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.TimeLimitCondition.use_score)
}

// -------------------------------------------------------------------

// SpeedbumpLimitCondition

// optional double speedbump_half_width = 1 [default = 0.2];
inline bool SpeedbumpLimitCondition::_internal_has_speedbump_half_width() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SpeedbumpLimitCondition::has_speedbump_half_width() const {
  return _internal_has_speedbump_half_width();
}
inline void SpeedbumpLimitCondition::clear_speedbump_half_width() {
  speedbump_half_width_ = 0.2;
  _has_bits_[0] &= ~0x00000002u;
}
inline double SpeedbumpLimitCondition::_internal_speedbump_half_width() const {
  return speedbump_half_width_;
}
inline double SpeedbumpLimitCondition::speedbump_half_width() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.SpeedbumpLimitCondition.speedbump_half_width)
  return _internal_speedbump_half_width();
}
inline void SpeedbumpLimitCondition::_internal_set_speedbump_half_width(double value) {
  _has_bits_[0] |= 0x00000002u;
  speedbump_half_width_ = value;
}
inline void SpeedbumpLimitCondition::set_speedbump_half_width(double value) {
  _internal_set_speedbump_half_width(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.SpeedbumpLimitCondition.speedbump_half_width)
}

// optional double max_speed = 2 [default = 3];
inline bool SpeedbumpLimitCondition::_internal_has_max_speed() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SpeedbumpLimitCondition::has_max_speed() const {
  return _internal_has_max_speed();
}
inline void SpeedbumpLimitCondition::clear_max_speed() {
  max_speed_ = 3;
  _has_bits_[0] &= ~0x00000004u;
}
inline double SpeedbumpLimitCondition::_internal_max_speed() const {
  return max_speed_;
}
inline double SpeedbumpLimitCondition::max_speed() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.SpeedbumpLimitCondition.max_speed)
  return _internal_max_speed();
}
inline void SpeedbumpLimitCondition::_internal_set_max_speed(double value) {
  _has_bits_[0] |= 0x00000004u;
  max_speed_ = value;
}
inline void SpeedbumpLimitCondition::set_max_speed(double value) {
  _internal_set_max_speed(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.SpeedbumpLimitCondition.max_speed)
}

// optional double deduction_speed_unit = 3 [default = 1];
inline bool SpeedbumpLimitCondition::_internal_has_deduction_speed_unit() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SpeedbumpLimitCondition::has_deduction_speed_unit() const {
  return _internal_has_deduction_speed_unit();
}
inline void SpeedbumpLimitCondition::clear_deduction_speed_unit() {
  deduction_speed_unit_ = 1;
  _has_bits_[0] &= ~0x00000008u;
}
inline double SpeedbumpLimitCondition::_internal_deduction_speed_unit() const {
  return deduction_speed_unit_;
}
inline double SpeedbumpLimitCondition::deduction_speed_unit() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.SpeedbumpLimitCondition.deduction_speed_unit)
  return _internal_deduction_speed_unit();
}
inline void SpeedbumpLimitCondition::_internal_set_deduction_speed_unit(double value) {
  _has_bits_[0] |= 0x00000008u;
  deduction_speed_unit_ = value;
}
inline void SpeedbumpLimitCondition::set_deduction_speed_unit(double value) {
  _internal_set_deduction_speed_unit(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.SpeedbumpLimitCondition.deduction_speed_unit)
}

// optional bool use_score = 4 [default = false];
inline bool SpeedbumpLimitCondition::_internal_has_use_score() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SpeedbumpLimitCondition::has_use_score() const {
  return _internal_has_use_score();
}
inline void SpeedbumpLimitCondition::clear_use_score() {
  use_score_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool SpeedbumpLimitCondition::_internal_use_score() const {
  return use_score_;
}
inline bool SpeedbumpLimitCondition::use_score() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.SpeedbumpLimitCondition.use_score)
  return _internal_use_score();
}
inline void SpeedbumpLimitCondition::_internal_set_use_score(bool value) {
  _has_bits_[0] |= 0x00000001u;
  use_score_ = value;
}
inline void SpeedbumpLimitCondition::set_use_score(bool value) {
  _internal_set_use_score(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.SpeedbumpLimitCondition.use_score)
}

// optional double single_deduction = 5 [default = 5];
inline bool SpeedbumpLimitCondition::_internal_has_single_deduction() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool SpeedbumpLimitCondition::has_single_deduction() const {
  return _internal_has_single_deduction();
}
inline void SpeedbumpLimitCondition::clear_single_deduction() {
  single_deduction_ = 5;
  _has_bits_[0] &= ~0x00000010u;
}
inline double SpeedbumpLimitCondition::_internal_single_deduction() const {
  return single_deduction_;
}
inline double SpeedbumpLimitCondition::single_deduction() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.SpeedbumpLimitCondition.single_deduction)
  return _internal_single_deduction();
}
inline void SpeedbumpLimitCondition::_internal_set_single_deduction(double value) {
  _has_bits_[0] |= 0x00000010u;
  single_deduction_ = value;
}
inline void SpeedbumpLimitCondition::set_single_deduction(double value) {
  _internal_set_single_deduction(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.SpeedbumpLimitCondition.single_deduction)
}

// -------------------------------------------------------------------

// WorkingZoneAvoidLimitCondition

// repeated .apollo.hdmap.Polygon working_zone = 1;
inline int WorkingZoneAvoidLimitCondition::_internal_working_zone_size() const {
  return working_zone_.size();
}
inline int WorkingZoneAvoidLimitCondition::working_zone_size() const {
  return _internal_working_zone_size();
}
inline ::apollo::hdmap::Polygon* WorkingZoneAvoidLimitCondition::mutable_working_zone(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.simulation.WorkingZoneAvoidLimitCondition.working_zone)
  return working_zone_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::hdmap::Polygon >*
WorkingZoneAvoidLimitCondition::mutable_working_zone() {
  // @@protoc_insertion_point(field_mutable_list:apollo.simulation.WorkingZoneAvoidLimitCondition.working_zone)
  return &working_zone_;
}
inline const ::apollo::hdmap::Polygon& WorkingZoneAvoidLimitCondition::_internal_working_zone(int index) const {
  return working_zone_.Get(index);
}
inline const ::apollo::hdmap::Polygon& WorkingZoneAvoidLimitCondition::working_zone(int index) const {
  // @@protoc_insertion_point(field_get:apollo.simulation.WorkingZoneAvoidLimitCondition.working_zone)
  return _internal_working_zone(index);
}
inline ::apollo::hdmap::Polygon* WorkingZoneAvoidLimitCondition::_internal_add_working_zone() {
  return working_zone_.Add();
}
inline ::apollo::hdmap::Polygon* WorkingZoneAvoidLimitCondition::add_working_zone() {
  // @@protoc_insertion_point(field_add:apollo.simulation.WorkingZoneAvoidLimitCondition.working_zone)
  return _internal_add_working_zone();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::hdmap::Polygon >&
WorkingZoneAvoidLimitCondition::working_zone() const {
  // @@protoc_insertion_point(field_list:apollo.simulation.WorkingZoneAvoidLimitCondition.working_zone)
  return working_zone_;
}

// optional double max_speed = 2 [default = 8.33];
inline bool WorkingZoneAvoidLimitCondition::_internal_has_max_speed() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool WorkingZoneAvoidLimitCondition::has_max_speed() const {
  return _internal_has_max_speed();
}
inline void WorkingZoneAvoidLimitCondition::clear_max_speed() {
  max_speed_ = 8.33;
  _has_bits_[0] &= ~0x00000004u;
}
inline double WorkingZoneAvoidLimitCondition::_internal_max_speed() const {
  return max_speed_;
}
inline double WorkingZoneAvoidLimitCondition::max_speed() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.WorkingZoneAvoidLimitCondition.max_speed)
  return _internal_max_speed();
}
inline void WorkingZoneAvoidLimitCondition::_internal_set_max_speed(double value) {
  _has_bits_[0] |= 0x00000004u;
  max_speed_ = value;
}
inline void WorkingZoneAvoidLimitCondition::set_max_speed(double value) {
  _internal_set_max_speed(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.WorkingZoneAvoidLimitCondition.max_speed)
}

// optional .apollo.hdmap.Polygon whole_area = 3;
inline bool WorkingZoneAvoidLimitCondition::_internal_has_whole_area() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || whole_area_ != nullptr);
  return value;
}
inline bool WorkingZoneAvoidLimitCondition::has_whole_area() const {
  return _internal_has_whole_area();
}
inline const ::apollo::hdmap::Polygon& WorkingZoneAvoidLimitCondition::_internal_whole_area() const {
  const ::apollo::hdmap::Polygon* p = whole_area_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::hdmap::Polygon&>(
      ::apollo::hdmap::_Polygon_default_instance_);
}
inline const ::apollo::hdmap::Polygon& WorkingZoneAvoidLimitCondition::whole_area() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.WorkingZoneAvoidLimitCondition.whole_area)
  return _internal_whole_area();
}
inline void WorkingZoneAvoidLimitCondition::unsafe_arena_set_allocated_whole_area(
    ::apollo::hdmap::Polygon* whole_area) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(whole_area_);
  }
  whole_area_ = whole_area;
  if (whole_area) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.simulation.WorkingZoneAvoidLimitCondition.whole_area)
}
inline ::apollo::hdmap::Polygon* WorkingZoneAvoidLimitCondition::release_whole_area() {
  _has_bits_[0] &= ~0x00000001u;
  ::apollo::hdmap::Polygon* temp = whole_area_;
  whole_area_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::apollo::hdmap::Polygon* WorkingZoneAvoidLimitCondition::unsafe_arena_release_whole_area() {
  // @@protoc_insertion_point(field_release:apollo.simulation.WorkingZoneAvoidLimitCondition.whole_area)
  _has_bits_[0] &= ~0x00000001u;
  ::apollo::hdmap::Polygon* temp = whole_area_;
  whole_area_ = nullptr;
  return temp;
}
inline ::apollo::hdmap::Polygon* WorkingZoneAvoidLimitCondition::_internal_mutable_whole_area() {
  _has_bits_[0] |= 0x00000001u;
  if (whole_area_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::hdmap::Polygon>(GetArena());
    whole_area_ = p;
  }
  return whole_area_;
}
inline ::apollo::hdmap::Polygon* WorkingZoneAvoidLimitCondition::mutable_whole_area() {
  // @@protoc_insertion_point(field_mutable:apollo.simulation.WorkingZoneAvoidLimitCondition.whole_area)
  return _internal_mutable_whole_area();
}
inline void WorkingZoneAvoidLimitCondition::set_allocated_whole_area(::apollo::hdmap::Polygon* whole_area) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(whole_area_);
  }
  if (whole_area) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(whole_area)->GetArena();
    if (message_arena != submessage_arena) {
      whole_area = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, whole_area, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  whole_area_ = whole_area;
  // @@protoc_insertion_point(field_set_allocated:apollo.simulation.WorkingZoneAvoidLimitCondition.whole_area)
}

// optional bool use_score = 4 [default = false];
inline bool WorkingZoneAvoidLimitCondition::_internal_has_use_score() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool WorkingZoneAvoidLimitCondition::has_use_score() const {
  return _internal_has_use_score();
}
inline void WorkingZoneAvoidLimitCondition::clear_use_score() {
  use_score_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool WorkingZoneAvoidLimitCondition::_internal_use_score() const {
  return use_score_;
}
inline bool WorkingZoneAvoidLimitCondition::use_score() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.WorkingZoneAvoidLimitCondition.use_score)
  return _internal_use_score();
}
inline void WorkingZoneAvoidLimitCondition::_internal_set_use_score(bool value) {
  _has_bits_[0] |= 0x00000002u;
  use_score_ = value;
}
inline void WorkingZoneAvoidLimitCondition::set_use_score(bool value) {
  _internal_set_use_score(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.WorkingZoneAvoidLimitCondition.use_score)
}

// optional double single_deduction = 5 [default = 3];
inline bool WorkingZoneAvoidLimitCondition::_internal_has_single_deduction() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool WorkingZoneAvoidLimitCondition::has_single_deduction() const {
  return _internal_has_single_deduction();
}
inline void WorkingZoneAvoidLimitCondition::clear_single_deduction() {
  single_deduction_ = 3;
  _has_bits_[0] &= ~0x00000008u;
}
inline double WorkingZoneAvoidLimitCondition::_internal_single_deduction() const {
  return single_deduction_;
}
inline double WorkingZoneAvoidLimitCondition::single_deduction() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.WorkingZoneAvoidLimitCondition.single_deduction)
  return _internal_single_deduction();
}
inline void WorkingZoneAvoidLimitCondition::_internal_set_single_deduction(double value) {
  _has_bits_[0] |= 0x00000008u;
  single_deduction_ = value;
}
inline void WorkingZoneAvoidLimitCondition::set_single_deduction(double value) {
  _internal_set_single_deduction(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.WorkingZoneAvoidLimitCondition.single_deduction)
}

// -------------------------------------------------------------------

// LimitedTimeParkingCondition

// optional .apollo.hdmap.Polygon parking_lot = 1;
inline bool LimitedTimeParkingCondition::_internal_has_parking_lot() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || parking_lot_ != nullptr);
  return value;
}
inline bool LimitedTimeParkingCondition::has_parking_lot() const {
  return _internal_has_parking_lot();
}
inline const ::apollo::hdmap::Polygon& LimitedTimeParkingCondition::_internal_parking_lot() const {
  const ::apollo::hdmap::Polygon* p = parking_lot_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::hdmap::Polygon&>(
      ::apollo::hdmap::_Polygon_default_instance_);
}
inline const ::apollo::hdmap::Polygon& LimitedTimeParkingCondition::parking_lot() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.LimitedTimeParkingCondition.parking_lot)
  return _internal_parking_lot();
}
inline void LimitedTimeParkingCondition::unsafe_arena_set_allocated_parking_lot(
    ::apollo::hdmap::Polygon* parking_lot) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(parking_lot_);
  }
  parking_lot_ = parking_lot;
  if (parking_lot) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.simulation.LimitedTimeParkingCondition.parking_lot)
}
inline ::apollo::hdmap::Polygon* LimitedTimeParkingCondition::release_parking_lot() {
  _has_bits_[0] &= ~0x00000001u;
  ::apollo::hdmap::Polygon* temp = parking_lot_;
  parking_lot_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::apollo::hdmap::Polygon* LimitedTimeParkingCondition::unsafe_arena_release_parking_lot() {
  // @@protoc_insertion_point(field_release:apollo.simulation.LimitedTimeParkingCondition.parking_lot)
  _has_bits_[0] &= ~0x00000001u;
  ::apollo::hdmap::Polygon* temp = parking_lot_;
  parking_lot_ = nullptr;
  return temp;
}
inline ::apollo::hdmap::Polygon* LimitedTimeParkingCondition::_internal_mutable_parking_lot() {
  _has_bits_[0] |= 0x00000001u;
  if (parking_lot_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::hdmap::Polygon>(GetArena());
    parking_lot_ = p;
  }
  return parking_lot_;
}
inline ::apollo::hdmap::Polygon* LimitedTimeParkingCondition::mutable_parking_lot() {
  // @@protoc_insertion_point(field_mutable:apollo.simulation.LimitedTimeParkingCondition.parking_lot)
  return _internal_mutable_parking_lot();
}
inline void LimitedTimeParkingCondition::set_allocated_parking_lot(::apollo::hdmap::Polygon* parking_lot) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(parking_lot_);
  }
  if (parking_lot) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(parking_lot)->GetArena();
    if (message_arena != submessage_arena) {
      parking_lot = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, parking_lot, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  parking_lot_ = parking_lot;
  // @@protoc_insertion_point(field_set_allocated:apollo.simulation.LimitedTimeParkingCondition.parking_lot)
}

// optional bool use_score = 2 [default = false];
inline bool LimitedTimeParkingCondition::_internal_has_use_score() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LimitedTimeParkingCondition::has_use_score() const {
  return _internal_has_use_score();
}
inline void LimitedTimeParkingCondition::clear_use_score() {
  use_score_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool LimitedTimeParkingCondition::_internal_use_score() const {
  return use_score_;
}
inline bool LimitedTimeParkingCondition::use_score() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.LimitedTimeParkingCondition.use_score)
  return _internal_use_score();
}
inline void LimitedTimeParkingCondition::_internal_set_use_score(bool value) {
  _has_bits_[0] |= 0x00000002u;
  use_score_ = value;
}
inline void LimitedTimeParkingCondition::set_use_score(bool value) {
  _internal_set_use_score(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.LimitedTimeParkingCondition.use_score)
}

// optional double single_deduction = 3 [default = 5];
inline bool LimitedTimeParkingCondition::_internal_has_single_deduction() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LimitedTimeParkingCondition::has_single_deduction() const {
  return _internal_has_single_deduction();
}
inline void LimitedTimeParkingCondition::clear_single_deduction() {
  single_deduction_ = 5;
  _has_bits_[0] &= ~0x00000004u;
}
inline double LimitedTimeParkingCondition::_internal_single_deduction() const {
  return single_deduction_;
}
inline double LimitedTimeParkingCondition::single_deduction() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.LimitedTimeParkingCondition.single_deduction)
  return _internal_single_deduction();
}
inline void LimitedTimeParkingCondition::_internal_set_single_deduction(double value) {
  _has_bits_[0] |= 0x00000004u;
  single_deduction_ = value;
}
inline void LimitedTimeParkingCondition::set_single_deduction(double value) {
  _internal_set_single_deduction(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.LimitedTimeParkingCondition.single_deduction)
}

// -------------------------------------------------------------------

// FollowAndBypassCondition

// optional .apollo.hdmap.Polygon test_range = 1;
inline bool FollowAndBypassCondition::_internal_has_test_range() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || test_range_ != nullptr);
  return value;
}
inline bool FollowAndBypassCondition::has_test_range() const {
  return _internal_has_test_range();
}
inline const ::apollo::hdmap::Polygon& FollowAndBypassCondition::_internal_test_range() const {
  const ::apollo::hdmap::Polygon* p = test_range_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::hdmap::Polygon&>(
      ::apollo::hdmap::_Polygon_default_instance_);
}
inline const ::apollo::hdmap::Polygon& FollowAndBypassCondition::test_range() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.FollowAndBypassCondition.test_range)
  return _internal_test_range();
}
inline void FollowAndBypassCondition::unsafe_arena_set_allocated_test_range(
    ::apollo::hdmap::Polygon* test_range) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(test_range_);
  }
  test_range_ = test_range;
  if (test_range) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.simulation.FollowAndBypassCondition.test_range)
}
inline ::apollo::hdmap::Polygon* FollowAndBypassCondition::release_test_range() {
  _has_bits_[0] &= ~0x00000002u;
  ::apollo::hdmap::Polygon* temp = test_range_;
  test_range_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::apollo::hdmap::Polygon* FollowAndBypassCondition::unsafe_arena_release_test_range() {
  // @@protoc_insertion_point(field_release:apollo.simulation.FollowAndBypassCondition.test_range)
  _has_bits_[0] &= ~0x00000002u;
  ::apollo::hdmap::Polygon* temp = test_range_;
  test_range_ = nullptr;
  return temp;
}
inline ::apollo::hdmap::Polygon* FollowAndBypassCondition::_internal_mutable_test_range() {
  _has_bits_[0] |= 0x00000002u;
  if (test_range_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::hdmap::Polygon>(GetArena());
    test_range_ = p;
  }
  return test_range_;
}
inline ::apollo::hdmap::Polygon* FollowAndBypassCondition::mutable_test_range() {
  // @@protoc_insertion_point(field_mutable:apollo.simulation.FollowAndBypassCondition.test_range)
  return _internal_mutable_test_range();
}
inline void FollowAndBypassCondition::set_allocated_test_range(::apollo::hdmap::Polygon* test_range) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(test_range_);
  }
  if (test_range) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(test_range)->GetArena();
    if (message_arena != submessage_arena) {
      test_range = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, test_range, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  test_range_ = test_range;
  // @@protoc_insertion_point(field_set_allocated:apollo.simulation.FollowAndBypassCondition.test_range)
}

// optional double divide_speed = 2 [default = 3];
inline bool FollowAndBypassCondition::_internal_has_divide_speed() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool FollowAndBypassCondition::has_divide_speed() const {
  return _internal_has_divide_speed();
}
inline void FollowAndBypassCondition::clear_divide_speed() {
  divide_speed_ = 3;
  _has_bits_[0] &= ~0x00000010u;
}
inline double FollowAndBypassCondition::_internal_divide_speed() const {
  return divide_speed_;
}
inline double FollowAndBypassCondition::divide_speed() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.FollowAndBypassCondition.divide_speed)
  return _internal_divide_speed();
}
inline void FollowAndBypassCondition::_internal_set_divide_speed(double value) {
  _has_bits_[0] |= 0x00000010u;
  divide_speed_ = value;
}
inline void FollowAndBypassCondition::set_divide_speed(double value) {
  _internal_set_divide_speed(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.FollowAndBypassCondition.divide_speed)
}

// optional string obstacle_id = 3;
inline bool FollowAndBypassCondition::_internal_has_obstacle_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FollowAndBypassCondition::has_obstacle_id() const {
  return _internal_has_obstacle_id();
}
inline void FollowAndBypassCondition::clear_obstacle_id() {
  obstacle_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FollowAndBypassCondition::obstacle_id() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.FollowAndBypassCondition.obstacle_id)
  return _internal_obstacle_id();
}
inline void FollowAndBypassCondition::set_obstacle_id(const std::string& value) {
  _internal_set_obstacle_id(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.FollowAndBypassCondition.obstacle_id)
}
inline std::string* FollowAndBypassCondition::mutable_obstacle_id() {
  // @@protoc_insertion_point(field_mutable:apollo.simulation.FollowAndBypassCondition.obstacle_id)
  return _internal_mutable_obstacle_id();
}
inline const std::string& FollowAndBypassCondition::_internal_obstacle_id() const {
  return obstacle_id_.Get();
}
inline void FollowAndBypassCondition::_internal_set_obstacle_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  obstacle_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void FollowAndBypassCondition::set_obstacle_id(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  obstacle_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:apollo.simulation.FollowAndBypassCondition.obstacle_id)
}
inline void FollowAndBypassCondition::set_obstacle_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  obstacle_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:apollo.simulation.FollowAndBypassCondition.obstacle_id)
}
inline void FollowAndBypassCondition::set_obstacle_id(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  obstacle_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:apollo.simulation.FollowAndBypassCondition.obstacle_id)
}
inline std::string* FollowAndBypassCondition::_internal_mutable_obstacle_id() {
  _has_bits_[0] |= 0x00000001u;
  return obstacle_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* FollowAndBypassCondition::release_obstacle_id() {
  // @@protoc_insertion_point(field_release:apollo.simulation.FollowAndBypassCondition.obstacle_id)
  if (!_internal_has_obstacle_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return obstacle_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void FollowAndBypassCondition::set_allocated_obstacle_id(std::string* obstacle_id) {
  if (obstacle_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  obstacle_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), obstacle_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:apollo.simulation.FollowAndBypassCondition.obstacle_id)
}

// optional .apollo.hdmap.LineSegment end_line = 4;
inline bool FollowAndBypassCondition::_internal_has_end_line() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || end_line_ != nullptr);
  return value;
}
inline bool FollowAndBypassCondition::has_end_line() const {
  return _internal_has_end_line();
}
inline const ::apollo::hdmap::LineSegment& FollowAndBypassCondition::_internal_end_line() const {
  const ::apollo::hdmap::LineSegment* p = end_line_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::hdmap::LineSegment&>(
      ::apollo::hdmap::_LineSegment_default_instance_);
}
inline const ::apollo::hdmap::LineSegment& FollowAndBypassCondition::end_line() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.FollowAndBypassCondition.end_line)
  return _internal_end_line();
}
inline void FollowAndBypassCondition::unsafe_arena_set_allocated_end_line(
    ::apollo::hdmap::LineSegment* end_line) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_line_);
  }
  end_line_ = end_line;
  if (end_line) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.simulation.FollowAndBypassCondition.end_line)
}
inline ::apollo::hdmap::LineSegment* FollowAndBypassCondition::release_end_line() {
  _has_bits_[0] &= ~0x00000004u;
  ::apollo::hdmap::LineSegment* temp = end_line_;
  end_line_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::apollo::hdmap::LineSegment* FollowAndBypassCondition::unsafe_arena_release_end_line() {
  // @@protoc_insertion_point(field_release:apollo.simulation.FollowAndBypassCondition.end_line)
  _has_bits_[0] &= ~0x00000004u;
  ::apollo::hdmap::LineSegment* temp = end_line_;
  end_line_ = nullptr;
  return temp;
}
inline ::apollo::hdmap::LineSegment* FollowAndBypassCondition::_internal_mutable_end_line() {
  _has_bits_[0] |= 0x00000004u;
  if (end_line_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::hdmap::LineSegment>(GetArena());
    end_line_ = p;
  }
  return end_line_;
}
inline ::apollo::hdmap::LineSegment* FollowAndBypassCondition::mutable_end_line() {
  // @@protoc_insertion_point(field_mutable:apollo.simulation.FollowAndBypassCondition.end_line)
  return _internal_mutable_end_line();
}
inline void FollowAndBypassCondition::set_allocated_end_line(::apollo::hdmap::LineSegment* end_line) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_line_);
  }
  if (end_line) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_line)->GetArena();
    if (message_arena != submessage_arena) {
      end_line = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end_line, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  end_line_ = end_line;
  // @@protoc_insertion_point(field_set_allocated:apollo.simulation.FollowAndBypassCondition.end_line)
}

// optional bool use_score = 5 [default = false];
inline bool FollowAndBypassCondition::_internal_has_use_score() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool FollowAndBypassCondition::has_use_score() const {
  return _internal_has_use_score();
}
inline void FollowAndBypassCondition::clear_use_score() {
  use_score_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool FollowAndBypassCondition::_internal_use_score() const {
  return use_score_;
}
inline bool FollowAndBypassCondition::use_score() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.FollowAndBypassCondition.use_score)
  return _internal_use_score();
}
inline void FollowAndBypassCondition::_internal_set_use_score(bool value) {
  _has_bits_[0] |= 0x00000008u;
  use_score_ = value;
}
inline void FollowAndBypassCondition::set_use_score(bool value) {
  _internal_set_use_score(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.FollowAndBypassCondition.use_score)
}

// -------------------------------------------------------------------

// ObstacleBypassCondition

// optional .apollo.hdmap.Polygon test_range = 1;
inline bool ObstacleBypassCondition::_internal_has_test_range() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || test_range_ != nullptr);
  return value;
}
inline bool ObstacleBypassCondition::has_test_range() const {
  return _internal_has_test_range();
}
inline const ::apollo::hdmap::Polygon& ObstacleBypassCondition::_internal_test_range() const {
  const ::apollo::hdmap::Polygon* p = test_range_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::hdmap::Polygon&>(
      ::apollo::hdmap::_Polygon_default_instance_);
}
inline const ::apollo::hdmap::Polygon& ObstacleBypassCondition::test_range() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.ObstacleBypassCondition.test_range)
  return _internal_test_range();
}
inline void ObstacleBypassCondition::unsafe_arena_set_allocated_test_range(
    ::apollo::hdmap::Polygon* test_range) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(test_range_);
  }
  test_range_ = test_range;
  if (test_range) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.simulation.ObstacleBypassCondition.test_range)
}
inline ::apollo::hdmap::Polygon* ObstacleBypassCondition::release_test_range() {
  _has_bits_[0] &= ~0x00000002u;
  ::apollo::hdmap::Polygon* temp = test_range_;
  test_range_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::apollo::hdmap::Polygon* ObstacleBypassCondition::unsafe_arena_release_test_range() {
  // @@protoc_insertion_point(field_release:apollo.simulation.ObstacleBypassCondition.test_range)
  _has_bits_[0] &= ~0x00000002u;
  ::apollo::hdmap::Polygon* temp = test_range_;
  test_range_ = nullptr;
  return temp;
}
inline ::apollo::hdmap::Polygon* ObstacleBypassCondition::_internal_mutable_test_range() {
  _has_bits_[0] |= 0x00000002u;
  if (test_range_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::hdmap::Polygon>(GetArena());
    test_range_ = p;
  }
  return test_range_;
}
inline ::apollo::hdmap::Polygon* ObstacleBypassCondition::mutable_test_range() {
  // @@protoc_insertion_point(field_mutable:apollo.simulation.ObstacleBypassCondition.test_range)
  return _internal_mutable_test_range();
}
inline void ObstacleBypassCondition::set_allocated_test_range(::apollo::hdmap::Polygon* test_range) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(test_range_);
  }
  if (test_range) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(test_range)->GetArena();
    if (message_arena != submessage_arena) {
      test_range = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, test_range, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  test_range_ = test_range;
  // @@protoc_insertion_point(field_set_allocated:apollo.simulation.ObstacleBypassCondition.test_range)
}

// optional string obstacle_id = 2;
inline bool ObstacleBypassCondition::_internal_has_obstacle_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ObstacleBypassCondition::has_obstacle_id() const {
  return _internal_has_obstacle_id();
}
inline void ObstacleBypassCondition::clear_obstacle_id() {
  obstacle_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ObstacleBypassCondition::obstacle_id() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.ObstacleBypassCondition.obstacle_id)
  return _internal_obstacle_id();
}
inline void ObstacleBypassCondition::set_obstacle_id(const std::string& value) {
  _internal_set_obstacle_id(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.ObstacleBypassCondition.obstacle_id)
}
inline std::string* ObstacleBypassCondition::mutable_obstacle_id() {
  // @@protoc_insertion_point(field_mutable:apollo.simulation.ObstacleBypassCondition.obstacle_id)
  return _internal_mutable_obstacle_id();
}
inline const std::string& ObstacleBypassCondition::_internal_obstacle_id() const {
  return obstacle_id_.Get();
}
inline void ObstacleBypassCondition::_internal_set_obstacle_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  obstacle_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ObstacleBypassCondition::set_obstacle_id(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  obstacle_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:apollo.simulation.ObstacleBypassCondition.obstacle_id)
}
inline void ObstacleBypassCondition::set_obstacle_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  obstacle_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:apollo.simulation.ObstacleBypassCondition.obstacle_id)
}
inline void ObstacleBypassCondition::set_obstacle_id(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  obstacle_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:apollo.simulation.ObstacleBypassCondition.obstacle_id)
}
inline std::string* ObstacleBypassCondition::_internal_mutable_obstacle_id() {
  _has_bits_[0] |= 0x00000001u;
  return obstacle_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ObstacleBypassCondition::release_obstacle_id() {
  // @@protoc_insertion_point(field_release:apollo.simulation.ObstacleBypassCondition.obstacle_id)
  if (!_internal_has_obstacle_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return obstacle_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ObstacleBypassCondition::set_allocated_obstacle_id(std::string* obstacle_id) {
  if (obstacle_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  obstacle_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), obstacle_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:apollo.simulation.ObstacleBypassCondition.obstacle_id)
}

// optional double min_lateral_distance = 3 [default = 1];
inline bool ObstacleBypassCondition::_internal_has_min_lateral_distance() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ObstacleBypassCondition::has_min_lateral_distance() const {
  return _internal_has_min_lateral_distance();
}
inline void ObstacleBypassCondition::clear_min_lateral_distance() {
  min_lateral_distance_ = 1;
  _has_bits_[0] &= ~0x00000008u;
}
inline double ObstacleBypassCondition::_internal_min_lateral_distance() const {
  return min_lateral_distance_;
}
inline double ObstacleBypassCondition::min_lateral_distance() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.ObstacleBypassCondition.min_lateral_distance)
  return _internal_min_lateral_distance();
}
inline void ObstacleBypassCondition::_internal_set_min_lateral_distance(double value) {
  _has_bits_[0] |= 0x00000008u;
  min_lateral_distance_ = value;
}
inline void ObstacleBypassCondition::set_min_lateral_distance(double value) {
  _internal_set_min_lateral_distance(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.ObstacleBypassCondition.min_lateral_distance)
}

// optional double max_speed = 4 [default = 5];
inline bool ObstacleBypassCondition::_internal_has_max_speed() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ObstacleBypassCondition::has_max_speed() const {
  return _internal_has_max_speed();
}
inline void ObstacleBypassCondition::clear_max_speed() {
  max_speed_ = 5;
  _has_bits_[0] &= ~0x00000010u;
}
inline double ObstacleBypassCondition::_internal_max_speed() const {
  return max_speed_;
}
inline double ObstacleBypassCondition::max_speed() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.ObstacleBypassCondition.max_speed)
  return _internal_max_speed();
}
inline void ObstacleBypassCondition::_internal_set_max_speed(double value) {
  _has_bits_[0] |= 0x00000010u;
  max_speed_ = value;
}
inline void ObstacleBypassCondition::set_max_speed(double value) {
  _internal_set_max_speed(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.ObstacleBypassCondition.max_speed)
}

// optional bool use_score = 5 [default = false];
inline bool ObstacleBypassCondition::_internal_has_use_score() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ObstacleBypassCondition::has_use_score() const {
  return _internal_has_use_score();
}
inline void ObstacleBypassCondition::clear_use_score() {
  use_score_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool ObstacleBypassCondition::_internal_use_score() const {
  return use_score_;
}
inline bool ObstacleBypassCondition::use_score() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.ObstacleBypassCondition.use_score)
  return _internal_use_score();
}
inline void ObstacleBypassCondition::_internal_set_use_score(bool value) {
  _has_bits_[0] |= 0x00000004u;
  use_score_ = value;
}
inline void ObstacleBypassCondition::set_use_score(bool value) {
  _internal_set_use_score(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.ObstacleBypassCondition.use_score)
}

// optional double single_deduction = 6 [default = 5];
inline bool ObstacleBypassCondition::_internal_has_single_deduction() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ObstacleBypassCondition::has_single_deduction() const {
  return _internal_has_single_deduction();
}
inline void ObstacleBypassCondition::clear_single_deduction() {
  single_deduction_ = 5;
  _has_bits_[0] &= ~0x00000020u;
}
inline double ObstacleBypassCondition::_internal_single_deduction() const {
  return single_deduction_;
}
inline double ObstacleBypassCondition::single_deduction() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.ObstacleBypassCondition.single_deduction)
  return _internal_single_deduction();
}
inline void ObstacleBypassCondition::_internal_set_single_deduction(double value) {
  _has_bits_[0] |= 0x00000020u;
  single_deduction_ = value;
}
inline void ObstacleBypassCondition::set_single_deduction(double value) {
  _internal_set_single_deduction(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.ObstacleBypassCondition.single_deduction)
}

// -------------------------------------------------------------------

// AntiCheatingCondition

// optional bool use_score = 1 [default = false];
inline bool AntiCheatingCondition::_internal_has_use_score() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AntiCheatingCondition::has_use_score() const {
  return _internal_has_use_score();
}
inline void AntiCheatingCondition::clear_use_score() {
  use_score_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool AntiCheatingCondition::_internal_use_score() const {
  return use_score_;
}
inline bool AntiCheatingCondition::use_score() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.AntiCheatingCondition.use_score)
  return _internal_use_score();
}
inline void AntiCheatingCondition::_internal_set_use_score(bool value) {
  _has_bits_[0] |= 0x00000001u;
  use_score_ = value;
}
inline void AntiCheatingCondition::set_use_score(bool value) {
  _internal_set_use_score(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.AntiCheatingCondition.use_score)
}

// -------------------------------------------------------------------

// KeyPoint

// optional double x = 1;
inline bool KeyPoint::_internal_has_x() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool KeyPoint::has_x() const {
  return _internal_has_x();
}
inline void KeyPoint::clear_x() {
  x_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double KeyPoint::_internal_x() const {
  return x_;
}
inline double KeyPoint::x() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.KeyPoint.x)
  return _internal_x();
}
inline void KeyPoint::_internal_set_x(double value) {
  _has_bits_[0] |= 0x00000001u;
  x_ = value;
}
inline void KeyPoint::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.KeyPoint.x)
}

// optional double y = 2;
inline bool KeyPoint::_internal_has_y() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool KeyPoint::has_y() const {
  return _internal_has_y();
}
inline void KeyPoint::clear_y() {
  y_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double KeyPoint::_internal_y() const {
  return y_;
}
inline double KeyPoint::y() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.KeyPoint.y)
  return _internal_y();
}
inline void KeyPoint::_internal_set_y(double value) {
  _has_bits_[0] |= 0x00000002u;
  y_ = value;
}
inline void KeyPoint::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.KeyPoint.y)
}

// optional double z = 3 [default = 0];
inline bool KeyPoint::_internal_has_z() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool KeyPoint::has_z() const {
  return _internal_has_z();
}
inline void KeyPoint::clear_z() {
  z_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double KeyPoint::_internal_z() const {
  return z_;
}
inline double KeyPoint::z() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.KeyPoint.z)
  return _internal_z();
}
inline void KeyPoint::_internal_set_z(double value) {
  _has_bits_[0] |= 0x00000004u;
  z_ = value;
}
inline void KeyPoint::set_z(double value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.KeyPoint.z)
}

// optional double radius = 4 [default = 2];
inline bool KeyPoint::_internal_has_radius() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool KeyPoint::has_radius() const {
  return _internal_has_radius();
}
inline void KeyPoint::clear_radius() {
  radius_ = 2;
  _has_bits_[0] &= ~0x00000008u;
}
inline double KeyPoint::_internal_radius() const {
  return radius_;
}
inline double KeyPoint::radius() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.KeyPoint.radius)
  return _internal_radius();
}
inline void KeyPoint::_internal_set_radius(double value) {
  _has_bits_[0] |= 0x00000008u;
  radius_ = value;
}
inline void KeyPoint::set_radius(double value) {
  _internal_set_radius(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.KeyPoint.radius)
}

// -------------------------------------------------------------------

// KeyPointCondition

// optional bool use_score = 1 [default = false];
inline bool KeyPointCondition::_internal_has_use_score() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool KeyPointCondition::has_use_score() const {
  return _internal_has_use_score();
}
inline void KeyPointCondition::clear_use_score() {
  use_score_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool KeyPointCondition::_internal_use_score() const {
  return use_score_;
}
inline bool KeyPointCondition::use_score() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.KeyPointCondition.use_score)
  return _internal_use_score();
}
inline void KeyPointCondition::_internal_set_use_score(bool value) {
  _has_bits_[0] |= 0x00000001u;
  use_score_ = value;
}
inline void KeyPointCondition::set_use_score(bool value) {
  _internal_set_use_score(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.KeyPointCondition.use_score)
}

// optional bool in_order = 2 [default = true];
inline bool KeyPointCondition::_internal_has_in_order() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool KeyPointCondition::has_in_order() const {
  return _internal_has_in_order();
}
inline void KeyPointCondition::clear_in_order() {
  in_order_ = true;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool KeyPointCondition::_internal_in_order() const {
  return in_order_;
}
inline bool KeyPointCondition::in_order() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.KeyPointCondition.in_order)
  return _internal_in_order();
}
inline void KeyPointCondition::_internal_set_in_order(bool value) {
  _has_bits_[0] |= 0x00000002u;
  in_order_ = value;
}
inline void KeyPointCondition::set_in_order(bool value) {
  _internal_set_in_order(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.KeyPointCondition.in_order)
}

// optional double radius = 3 [default = 2];
inline bool KeyPointCondition::_internal_has_radius() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool KeyPointCondition::has_radius() const {
  return _internal_has_radius();
}
inline void KeyPointCondition::clear_radius() {
  radius_ = 2;
  _has_bits_[0] &= ~0x00000004u;
}
inline double KeyPointCondition::_internal_radius() const {
  return radius_;
}
inline double KeyPointCondition::radius() const {
  // @@protoc_insertion_point(field_get:apollo.simulation.KeyPointCondition.radius)
  return _internal_radius();
}
inline void KeyPointCondition::_internal_set_radius(double value) {
  _has_bits_[0] |= 0x00000004u;
  radius_ = value;
}
inline void KeyPointCondition::set_radius(double value) {
  _internal_set_radius(value);
  // @@protoc_insertion_point(field_set:apollo.simulation.KeyPointCondition.radius)
}

// repeated .apollo.simulation.KeyPoint point = 4;
inline int KeyPointCondition::_internal_point_size() const {
  return point_.size();
}
inline int KeyPointCondition::point_size() const {
  return _internal_point_size();
}
inline void KeyPointCondition::clear_point() {
  point_.Clear();
}
inline ::apollo::simulation::KeyPoint* KeyPointCondition::mutable_point(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.simulation.KeyPointCondition.point)
  return point_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::simulation::KeyPoint >*
KeyPointCondition::mutable_point() {
  // @@protoc_insertion_point(field_mutable_list:apollo.simulation.KeyPointCondition.point)
  return &point_;
}
inline const ::apollo::simulation::KeyPoint& KeyPointCondition::_internal_point(int index) const {
  return point_.Get(index);
}
inline const ::apollo::simulation::KeyPoint& KeyPointCondition::point(int index) const {
  // @@protoc_insertion_point(field_get:apollo.simulation.KeyPointCondition.point)
  return _internal_point(index);
}
inline ::apollo::simulation::KeyPoint* KeyPointCondition::_internal_add_point() {
  return point_.Add();
}
inline ::apollo::simulation::KeyPoint* KeyPointCondition::add_point() {
  // @@protoc_insertion_point(field_add:apollo.simulation.KeyPointCondition.point)
  return _internal_add_point();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::simulation::KeyPoint >&
KeyPointCondition::point() const {
  // @@protoc_insertion_point(field_list:apollo.simulation.KeyPointCondition.point)
  return point_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace simulation
}  // namespace apollo

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::apollo::simulation::LogicalCondition_OperatorType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::simulation::LogicalCondition_OperatorType>() {
  return ::apollo::simulation::LogicalCondition_OperatorType_descriptor();
}
template <> struct is_proto_enum< ::apollo::simulation::ObjectOverlapCondition_DirectionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::simulation::ObjectOverlapCondition_DirectionType>() {
  return ::apollo::simulation::ObjectOverlapCondition_DirectionType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_modules_2fcommon_5fmsgs_2fsimulation_5fmsgs_2fgrading_5fcondition_2eproto
